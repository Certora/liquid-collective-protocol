Binary files src/.DS_Store and contracts/src/.DS_Store differ
diff -ruN src/RedeemManager.1.sol contracts/src/RedeemManager.1.sol
--- src/RedeemManager.1.sol	2023-12-15 14:04:57
+++ contracts/src/RedeemManager.1.sol	2024-01-16 15:06:39
@@ -369,12 +369,14 @@
                 LibUint256.min(_params.redeemRequest.amount, withdrawalEventEndPosition - _params.redeemRequest.height);
             // we can now compute the equivalent eth amount based on the withdrawal event details
             vars.ethAmount =
-                (vars.matchingAmount * _params.withdrawalEvent.withdrawnEth) / _params.withdrawalEvent.amount;
+                mulDivDown(vars.matchingAmount, _params.withdrawalEvent.withdrawnEth, _params.withdrawalEvent.amount);
+                // (vars.matchingAmount * _params.withdrawalEvent.withdrawnEth) / _params.withdrawalEvent.amount; // Munged by Certora
 
             // as each request has a maximum withdrawable amount, we verify that the eth amount is not exceeding this amount, pro rata
             // the amount that is matched
             uint256 maxRedeemableEthAmount =
-                (vars.matchingAmount * _params.redeemRequest.maxRedeemableEth) / _params.redeemRequest.amount;
+                mulDivDown(vars.matchingAmount, _params.redeemRequest.maxRedeemableEth, _params.redeemRequest.amount);
+                // (vars.matchingAmount * _params.redeemRequest.maxRedeemableEth) / _params.redeemRequest.amount; // Munged by Certora
 
             if (maxRedeemableEthAmount < vars.ethAmount) {
                 vars.exceedingEthAmount = vars.ethAmount - maxRedeemableEthAmount;
@@ -527,5 +529,9 @@
     function _setRedeemDemand(uint256 _newValue) internal {
         emit SetRedeemDemand(RedeemDemand.get(), _newValue);
         RedeemDemand.set(_newValue);
+    }
+
+    function mulDivDown(uint256 a, uint256 b, uint256 c) internal pure returns (uint256 res) {
+            res = a * b / c;
     }
 }
diff -ruN src/River.1.sol contracts/src/River.1.sol
--- src/River.1.sol	2024-01-16 15:03:11
+++ contracts/src/River.1.sol	2024-01-16 15:19:47
@@ -28,6 +28,11 @@
 import "./state/river/MetadataURI.sol";
 import "./state/river/LastConsensusLayerReport.sol";
 
+// munged by certora
+// interface ICVL {
+//     function increment_onDepositCounter() external view returns(bool);
+// }
+
 /// @title River (v1)
 /// @author Kiln
 /// @notice This contract merges all the manager contracts and implements all the virtual methods stitching all components together
@@ -298,10 +303,13 @@
         }
     }
 
+    function _onDepositCalledMunged(address _depositor, address _recipient, uint256 _amount) internal {} // munged by certora, this can be fixed once finished with CERT-4706
     /// @notice Overridden handler called whenever a user deposits ETH to the system. Mints the adequate amount of shares.
     /// @param _depositor User address that made the deposit
     /// @param _amount Amount of ETH deposited
     function _onDeposit(address _depositor, address _recipient, uint256 _amount) internal override {
+        // ICVL(address(0xdeadc0de)).increment_onDepositCounter();
+        _onDepositCalledMunged(_depositor, _recipient, _amount); // munged by Certora
         uint256 mintedShares = SharesManagerV1._mintShares(_depositor, _amount);
         IAllowlistV1 allowlist = IAllowlistV1(AllowlistAddress.get());
         if (_depositor == _recipient) {
@@ -360,9 +368,11 @@
         return collectedCoverageFunds;
     }
 
+    function _onEarningsCalledMunged(uint256 _profits) internal {} // munged by Certora, this can be fixed once finished with CERT-4706
     /// @notice Overridden handler called whenever the balance of ETH handled by the system increases. Computes the fees paid to the collector
     /// @param _amount Additional ETH received
     function _onEarnings(uint256 _amount) internal override {
+        _onEarningsCalledMunged(_amount); // munged by Certora
         uint256 oldTotalSupply = _totalSupply();
         if (oldTotalSupply == 0) {
             revert ZeroMintedShares();
diff -ruN src/components/OracleManager.1.sol contracts/src/components/OracleManager.1.sol
--- src/components/OracleManager.1.sol	2024-01-15 16:50:23
+++ contracts/src/components/OracleManager.1.sol	2024-01-24 15:17:28
@@ -241,27 +241,7 @@
         emit SetBounds(_newValue.annualAprUpperBound, _newValue.relativeLowerBound);
     }
 
-    /// @notice Structure holding internal variables used during reporting
-    struct ConsensusLayerDataReportingVariables {
-        uint256 preReportUnderlyingBalance;
-        uint256 postReportUnderlyingBalance;
-        uint256 lastReportExitedBalance;
-        uint256 lastReportSkimmedBalance;
-        uint256 exitedAmountIncrease;
-        uint256 skimmedAmountIncrease;
-        uint256 timeElapsedSinceLastReport;
-        uint256 availableAmountToUpperBound;
-        uint256 redeemManagerDemand;
-        ConsensusLayerDataReportingTrace trace;
-    }
-
-    /// @inheritdoc IOracleManagerV1
-    function setConsensusLayerData(IOracleManagerV1.ConsensusLayerReport calldata _report) external {
-        // only the oracle is allowed to call this endpoint
-        if (msg.sender != OracleAddress.get()) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-
+    function helper1(IOracleManagerV1.ConsensusLayerReport calldata _report) public returns (ConsensusLayerDataReportingVariables memory) {
         CLSpec.CLSpecStruct memory cls = CLSpec.get();
 
         // we start by verifying that the reported epoch is valid based on the consensus layer spec
@@ -313,28 +293,115 @@
 
         // we retrieve the current total underlying balance before any reporting data is applied to the system
         vars.preReportUnderlyingBalance = _assetBalance();
+        return vars;
+    }
 
+    function helper2(IOracleManagerV1.ConsensusLayerReport calldata _report) public {
+        // we update the system parameters, this will have an impact on how the total underlying balance is computed
+        IOracleManagerV1.StoredConsensusLayerReport memory storedReport;
+
+        storedReport.epoch = _report.epoch;
+        storedReport.validatorsBalance = _report.validatorsBalance;
+        storedReport.validatorsSkimmedBalance = _report.validatorsSkimmedBalance;
+        storedReport.validatorsExitedBalance = _report.validatorsExitedBalance;
+        storedReport.validatorsExitingBalance = _report.validatorsExitingBalance;
+        storedReport.validatorsCount = _report.validatorsCount;
+        storedReport.rebalanceDepositToRedeemMode = _report.rebalanceDepositToRedeemMode;
+        storedReport.slashingContainmentMode = _report.slashingContainmentMode;
+        LastConsensusLayerReport.set(storedReport);
+    }
+
+    function helper3_checkBounds(ConsensusLayerDataReportingVariables memory vars, ReportBounds.ReportBoundsStruct memory rb, uint256 maxDecrease) public {
+        if (
+                vars.postReportUnderlyingBalance
+                    < vars.preReportUnderlyingBalance - LibUint256.min(maxDecrease, vars.preReportUnderlyingBalance)
+        ) {
+            revert TotalValidatorBalanceDecreaseOutOfBound(
+                vars.preReportUnderlyingBalance,
+                vars.postReportUnderlyingBalance,
+                vars.timeElapsedSinceLastReport,
+                rb.relativeLowerBound
+            );
+        }
+    }
+
+    function helper4(ConsensusLayerDataReportingVariables memory vars) public {
+        // if we have available amount to upper bound after the reporting values are applied
+        if (vars.availableAmountToUpperBound > 0) {
+            // we pull the funds from the execution layer fee recipient
+            vars.trace.pulledELFees = _pullELFees(vars.availableAmountToUpperBound);
+            // we update the rewards
+            vars.trace.rewards += vars.trace.pulledELFees;
+            // we update the available amount accordingly
+            vars.availableAmountToUpperBound -= vars.trace.pulledELFees;
+        }
+    }
+
+    function helper5(ConsensusLayerDataReportingVariables memory vars) public {
+        // if we have available amount to upper bound after the execution layer fees are pulled
+        if (vars.availableAmountToUpperBound > 0) {
+            // we pull the funds from the exceeding eth buffer of the redeem manager
+            vars.trace.pulledRedeemManagerExceedingEthBuffer =
+                _pullRedeemManagerExceedingEth(vars.availableAmountToUpperBound);
+            // we update the available amount accordingly
+            vars.availableAmountToUpperBound -= vars.trace.pulledRedeemManagerExceedingEthBuffer;
+        }
+    }
+
+    function helper6(ConsensusLayerDataReportingVariables memory vars) public {
+        // if we have available amount to upper bound after pulling the exceeding eth buffer, we attempt to pull coverage funds
+        if (vars.availableAmountToUpperBound > 0) {
+            // we pull the funds from the coverage recipient
+            vars.trace.pulledCoverageFunds = _pullCoverageFunds(vars.availableAmountToUpperBound);
+            // we do not update the rewards as coverage is not considered rewards
+            // we do not update the available amount as there are no more pulling actions to perform afterwards
+        }
+    }
+
+    function helper7_onEarnings(ConsensusLayerDataReportingVariables memory vars) public {
+        // if our rewards are not null, we dispatch the fee to the collector
+        if (vars.trace.rewards > 0) {
+            _onEarnings(vars.trace.rewards);
+        }
+    }
+    function helper8(ConsensusLayerDataReportingVariables memory vars, IOracleManagerV1.ConsensusLayerReport calldata _report) public {
+        _requestExitsBasedOnRedeemDemandAfterRebalancings(
+            _report.validatorsExitingBalance,
+            _report.stoppedValidatorCountPerOperator,
+            _report.rebalanceDepositToRedeemMode,
+            _report.slashingContainmentMode
+        );
+    }
+    function helper9(ConsensusLayerDataReportingVariables memory vars) public {
+        // we use the updated balanceToRedeem value to report a withdraw event on the redeem manager
+        _reportWithdrawToRedeemManager();
+    }
+    function helper10(ConsensusLayerDataReportingVariables memory vars) public {
+        // if funds are left in the balance to redeem, we move them to the deposit balance
+        _skimExcessBalanceToRedeem();
+    }
+    function helper11(ConsensusLayerDataReportingVariables memory vars) public {
+        // we update the committable amount based on daily maximum allowed
+        _commitBalanceToDeposit(vars.timeElapsedSinceLastReport);
+    }
+
+    /// @inheritdoc IOracleManagerV1
+    function setConsensusLayerData(IOracleManagerV1.ConsensusLayerReport calldata _report) external {
+        // only the oracle is allowed to call this endpoint
+        if (msg.sender != OracleAddress.get()) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+        ConsensusLayerDataReportingVariables memory vars = helper1(_report);
+
+
         // if we have new exited / skimmed eth available, we pull funds from the consensus layer recipient
         if (vars.exitedAmountIncrease + vars.skimmedAmountIncrease > 0) {
             // this method pulls and updates ethToDeposit / ethToRedeem accordingly
             _pullCLFunds(vars.skimmedAmountIncrease, vars.exitedAmountIncrease);
         }
 
-        {
-            // we update the system parameters, this will have an impact on how the total underlying balance is computed
-            IOracleManagerV1.StoredConsensusLayerReport memory storedReport;
+        helper2(_report);
 
-            storedReport.epoch = _report.epoch;
-            storedReport.validatorsBalance = _report.validatorsBalance;
-            storedReport.validatorsSkimmedBalance = _report.validatorsSkimmedBalance;
-            storedReport.validatorsExitedBalance = _report.validatorsExitedBalance;
-            storedReport.validatorsExitingBalance = _report.validatorsExitingBalance;
-            storedReport.validatorsCount = _report.validatorsCount;
-            storedReport.rebalanceDepositToRedeemMode = _report.rebalanceDepositToRedeemMode;
-            storedReport.slashingContainmentMode = _report.slashingContainmentMode;
-            LastConsensusLayerReport.set(storedReport);
-        }
-
         ReportBounds.ReportBoundsStruct memory rb = ReportBounds.get();
 
         // we compute the maximum allowed increase in balance based on the pre report value
@@ -370,70 +437,28 @@
             uint256 maxDecrease = _maxDecrease(rb, vars.preReportUnderlyingBalance);
 
             // we verify that the bound is not crossed
-            if (
-                vars.postReportUnderlyingBalance
-                    < vars.preReportUnderlyingBalance - LibUint256.min(maxDecrease, vars.preReportUnderlyingBalance)
-            ) {
-                revert TotalValidatorBalanceDecreaseOutOfBound(
-                    vars.preReportUnderlyingBalance,
-                    vars.postReportUnderlyingBalance,
-                    vars.timeElapsedSinceLastReport,
-                    rb.relativeLowerBound
-                );
-            }
+            helper3_checkBounds(vars, rb, maxDecrease);
 
             // we update the available amount to upper bound to be equal to the maximum allowed increase plus the negative delta due to the loss
             vars.availableAmountToUpperBound =
                 maxIncrease + (vars.preReportUnderlyingBalance - vars.postReportUnderlyingBalance);
         }
 
-        // if we have available amount to upper bound after the reporting values are applied
-        if (vars.availableAmountToUpperBound > 0) {
-            // we pull the funds from the execution layer fee recipient
-            vars.trace.pulledELFees = _pullELFees(vars.availableAmountToUpperBound);
-            // we update the rewards
-            vars.trace.rewards += vars.trace.pulledELFees;
-            // we update the available amount accordingly
-            vars.availableAmountToUpperBound -= vars.trace.pulledELFees;
-        }
+        helper4(vars);
 
-        // if we have available amount to upper bound after the execution layer fees are pulled
-        if (vars.availableAmountToUpperBound > 0) {
-            // we pull the funds from the exceeding eth buffer of the redeem manager
-            vars.trace.pulledRedeemManagerExceedingEthBuffer =
-                _pullRedeemManagerExceedingEth(vars.availableAmountToUpperBound);
-            // we update the available amount accordingly
-            vars.availableAmountToUpperBound -= vars.trace.pulledRedeemManagerExceedingEthBuffer;
-        }
+        helper5(vars);
 
-        // if we have available amount to upper bound after pulling the exceeding eth buffer, we attempt to pull coverage funds
-        if (vars.availableAmountToUpperBound > 0) {
-            // we pull the funds from the coverage recipient
-            vars.trace.pulledCoverageFunds = _pullCoverageFunds(vars.availableAmountToUpperBound);
-            // we do not update the rewards as coverage is not considered rewards
-            // we do not update the available amount as there are no more pulling actions to perform afterwards
-        }
+        helper6(vars);
 
-        // if our rewards are not null, we dispatch the fee to the collector
-        if (vars.trace.rewards > 0) {
-            _onEarnings(vars.trace.rewards);
-        }
+        helper7_onEarnings(vars);
 
-        _requestExitsBasedOnRedeemDemandAfterRebalancings(
-            _report.validatorsExitingBalance,
-            _report.stoppedValidatorCountPerOperator,
-            _report.rebalanceDepositToRedeemMode,
-            _report.slashingContainmentMode
-        );
+        helper8(vars, _report);
 
-        // we use the updated balanceToRedeem value to report a withdraw event on the redeem manager
-        _reportWithdrawToRedeemManager();
+        helper9(vars);
 
-        // if funds are left in the balance to redeem, we move them to the deposit balance
-        _skimExcessBalanceToRedeem();
+        helper10(vars);
 
-        // we update the committable amount based on daily maximum allowed
-        _commitBalanceToDeposit(vars.timeElapsedSinceLastReport);
+        helper11(vars);
 
         // we emit a summary event with all the reporting details
         emit ProcessedConsensusLayerReport(_report, vars.trace);
@@ -494,4 +519,4 @@
     {
         return (_epochNow - _epochPast) * (_cls.secondsPerSlot * _cls.slotsPerEpoch);
     }
-}
+}
\ No newline at end of file
diff -ruN src/components/SharesManager.1.sol contracts/src/components/SharesManager.1.sol
--- src/components/SharesManager.1.sol	2023-12-11 15:38:07
+++ contracts/src/components/SharesManager.1.sol	2024-01-16 15:06:39
@@ -192,6 +192,11 @@
         return true;
     }
 
+    function mulDivDown(uint256 a, uint256 b, uint256 c) internal pure returns (uint256 res)
+    {
+        res = a * b / c;
+    }
+
     /// @notice Internal utility to retrieve the underlying asset balance for the given shares
     /// @param _shares Amount of shares to convert
     /// @return The balance from the given shares
@@ -202,7 +207,8 @@
             return 0;
         }
 
-        return ((_shares * _assetBalance())) / _totalSharesValue;
+        // return ((_shares * _assetBalance())) / _totalSharesValue;
+        return mulDivDown(_shares , _assetBalance(), _totalSharesValue); // Munged by Certora
     }
 
     /// @notice Internal utility to retrieve the shares count for a given underlying asset amount
@@ -215,7 +221,8 @@
             return 0;
         }
 
-        return (_balance * _totalSharesValue) / _assetBalance();
+        // return (_balance * _totalSharesValue) / _assetBalance();
+        return mulDivDown(_balance, _totalSharesValue, _assetBalance()); // Munged by Certora
     }
 
     /// @notice Internal utility to mint shares for the specified user
@@ -230,7 +237,8 @@
             sharesToMint = _underlyingAssetValue;
             _mintRawShares(_owner, _underlyingAssetValue);
         } else {
-            sharesToMint = (_underlyingAssetValue * _totalSupply()) / oldTotalAssetBalance;
+            // sharesToMint = (_underlyingAssetValue * _totalSupply()) / oldTotalAssetBalance;
+            sharesToMint = mulDivDown(_underlyingAssetValue, _totalSupply(), oldTotalAssetBalance); // Munged by Certora
             _mintRawShares(_owner, sharesToMint);
         }
     }
diff -ruN src/interfaces/components/IOracleManager.1.sol contracts/src/interfaces/components/IOracleManager.1.sol
--- src/interfaces/components/IOracleManager.1.sol	2023-12-11 15:38:07
+++ contracts/src/interfaces/components/IOracleManager.1.sol	2024-01-24 15:17:25
@@ -102,6 +102,20 @@
         uint256 pulledCoverageFunds;
     }
 
+    /// @notice Structure holding internal variables used during reporting
+    struct ConsensusLayerDataReportingVariables {
+        uint256 preReportUnderlyingBalance;
+        uint256 postReportUnderlyingBalance;
+        uint256 lastReportExitedBalance;
+        uint256 lastReportSkimmedBalance;
+        uint256 exitedAmountIncrease;
+        uint256 skimmedAmountIncrease;
+        uint256 timeElapsedSinceLastReport;
+        uint256 availableAmountToUpperBound;
+        uint256 redeemManagerDemand;
+        ConsensusLayerDataReportingTrace trace;
+    }
+
     /// @notice The format of the oracle report
     struct ConsensusLayerReport {
         // this is the epoch at which the report was performed
