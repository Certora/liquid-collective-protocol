diff -ruN src/Administrable.sol Administrable.sol
--- src/Administrable.sol	2023-12-15 12:41:00
+++ Administrable.sol	2024-01-16 15:06:39
@@ -1,70 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "./interfaces/IAdministrable.sol";
-
-import "./libraries/LibAdministrable.sol";
-import "./libraries/LibSanitize.sol";
-
-/// @title Administrable
-/// @author Kiln
-/// @notice This contract handles the administration of the contracts
-abstract contract Administrable is IAdministrable {
-    /// @notice Prevents unauthorized calls
-    modifier onlyAdmin() {
-        if (msg.sender != LibAdministrable._getAdmin()) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-        _;
-    }
-
-    /// @notice Prevents unauthorized calls
-    modifier onlyPendingAdmin() {
-        if (msg.sender != LibAdministrable._getPendingAdmin()) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-        _;
-    }
-
-    /// @inheritdoc IAdministrable
-    function getAdmin() external view returns (address) {
-        return LibAdministrable._getAdmin();
-    }
-
-    /// @inheritdoc IAdministrable
-    function getPendingAdmin() external view returns (address) {
-        return LibAdministrable._getPendingAdmin();
-    }
-
-    /// @inheritdoc IAdministrable
-    function proposeAdmin(address _newAdmin) external onlyAdmin {
-        _setPendingAdmin(_newAdmin);
-    }
-
-    /// @inheritdoc IAdministrable
-    function acceptAdmin() external onlyPendingAdmin {
-        _setAdmin(LibAdministrable._getPendingAdmin());
-        _setPendingAdmin(address(0));
-    }
-
-    /// @notice Internal utility to set the admin address
-    /// @param _admin Address to set as admin
-    function _setAdmin(address _admin) internal {
-        LibSanitize._notZeroAddress(_admin);
-        LibAdministrable._setAdmin(_admin);
-        emit SetAdmin(_admin);
-    }
-
-    /// @notice Internal utility to set the pending admin address
-    /// @param _pendingAdmin Address to set as pending admin
-    function _setPendingAdmin(address _pendingAdmin) internal {
-        LibAdministrable._setPendingAdmin(_pendingAdmin);
-        emit SetPendingAdmin(_pendingAdmin);
-    }
-
-    /// @notice Internal utility to retrieve the address of the current admin
-    /// @return The address of admin
-    function _getAdmin() internal view returns (address) {
-        return LibAdministrable._getAdmin();
-    }
-}
diff -ruN src/Allowlist.1.sol Allowlist.1.sol
--- src/Allowlist.1.sol	2023-12-11 15:38:07
+++ Allowlist.1.sol	2024-01-16 15:06:39
@@ -1,157 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "./interfaces/IAllowlist.1.sol";
-
-import "./libraries/LibAllowlistMasks.sol";
-import "./Initializable.sol";
-import "./Administrable.sol";
-
-import "./state/allowlist/AllowerAddress.sol";
-import "./state/allowlist/DenierAddress.sol";
-import "./state/allowlist/Allowlist.sol";
-
-/// @title Allowlist (v1)
-/// @author Kiln
-/// @notice This contract handles the list of allowed recipients.
-/// @notice All accounts have an uint256 value associated with their addresses where
-/// @notice each bit represents a right in the system. The DENY_MASK defined the mask
-/// @notice used to identify if the denied bit is on, preventing users from interacting
-/// @notice with the system
-contract AllowlistV1 is IAllowlistV1, Initializable, Administrable {
-    /// @inheritdoc IAllowlistV1
-    function initAllowlistV1(address _admin, address _allower) external init(0) {
-        _setAdmin(_admin);
-        AllowerAddress.set(_allower);
-        emit SetAllower(_allower);
-    }
-
-    function initAllowlistV1_1(address _denier) external init(1) {
-        DenierAddress.set(_denier);
-        emit SetDenier(_denier);
-    }
-
-    /// @inheritdoc IAllowlistV1
-    function getAllower() external view returns (address) {
-        return AllowerAddress.get();
-    }
-
-    /// @inheritdoc IAllowlistV1
-    function getDenier() external view returns (address) {
-        return DenierAddress.get();
-    }
-
-    /// @inheritdoc IAllowlistV1
-    function isAllowed(address _account, uint256 _mask) external view returns (bool) {
-        uint256 userPermissions = Allowlist.get(_account);
-        if (userPermissions & LibAllowlistMasks.DENY_MASK == LibAllowlistMasks.DENY_MASK) {
-            return false;
-        }
-        return userPermissions & _mask == _mask;
-    }
-
-    /// @inheritdoc IAllowlistV1
-    function isDenied(address _account) external view returns (bool) {
-        return Allowlist.get(_account) & LibAllowlistMasks.DENY_MASK == LibAllowlistMasks.DENY_MASK;
-    }
-
-    /// @inheritdoc IAllowlistV1
-    function hasPermission(address _account, uint256 _mask) external view returns (bool) {
-        return Allowlist.get(_account) & _mask == _mask;
-    }
-
-    /// @inheritdoc IAllowlistV1
-    function getPermissions(address _account) external view returns (uint256) {
-        return Allowlist.get(_account);
-    }
-
-    /// @inheritdoc IAllowlistV1
-    function onlyAllowed(address _account, uint256 _mask) external view {
-        uint256 userPermissions = Allowlist.get(_account);
-        if (userPermissions & LibAllowlistMasks.DENY_MASK == LibAllowlistMasks.DENY_MASK) {
-            revert Denied(_account);
-        }
-        if (userPermissions & _mask != _mask) {
-            revert LibErrors.Unauthorized(_account);
-        }
-    }
-
-    /// @inheritdoc IAllowlistV1
-    function setAllower(address _newAllowerAddress) external onlyAdmin {
-        AllowerAddress.set(_newAllowerAddress);
-        emit SetAllower(_newAllowerAddress);
-    }
-
-    /// @inheritdoc IAllowlistV1
-    function setDenier(address _newDenierAddress) external onlyAdmin {
-        DenierAddress.set(_newDenierAddress);
-        emit SetDenier(_newDenierAddress);
-    }
-
-    /// @inheritdoc IAllowlistV1
-    function setAllowPermissions(address[] calldata _accounts, uint256[] calldata _permissions) external {
-        if (msg.sender != AllowerAddress.get()) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-
-        if (_accounts.length == 0) {
-            revert InvalidCount();
-        }
-
-        if (_accounts.length != _permissions.length) {
-            revert MismatchedArrayLengths();
-        }
-
-        for (uint256 i = 0; i < _accounts.length;) {
-            LibSanitize._notZeroAddress(_accounts[i]);
-
-            // Check if account is already denied
-            if (Allowlist.get(_accounts[i]) & LibAllowlistMasks.DENY_MASK == LibAllowlistMasks.DENY_MASK) {
-                revert AttemptToRemoveDenyPermission();
-            }
-
-            // Check if DENY permission is present in new permission
-            if (_permissions[i] & LibAllowlistMasks.DENY_MASK == LibAllowlistMasks.DENY_MASK) {
-                revert AttemptToSetDenyPermission();
-            }
-
-            Allowlist.set(_accounts[i], _permissions[i]);
-            unchecked {
-                ++i;
-            }
-        }
-
-        emit SetAllowlistPermissions(_accounts, _permissions);
-    }
-
-    /// @inheritdoc IAllowlistV1
-    function setDenyPermissions(address[] calldata _accounts, uint256[] calldata _permissions) external {
-        if (msg.sender != DenierAddress.get()) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-
-        if (_accounts.length == 0) {
-            revert InvalidCount();
-        }
-
-        if (_accounts.length != _permissions.length) {
-            revert MismatchedArrayLengths();
-        }
-
-        for (uint256 i = 0; i < _accounts.length;) {
-            LibSanitize._notZeroAddress(_accounts[i]);
-            if (_permissions[i] & LibAllowlistMasks.DENY_MASK == LibAllowlistMasks.DENY_MASK) {
-                // Apply deny mask
-                Allowlist.set(_accounts[i], LibAllowlistMasks.DENY_MASK);
-            } else {
-                // Remove deny mask
-                Allowlist.set(_accounts[i], 0);
-            }
-            unchecked {
-                ++i;
-            }
-        }
-
-        emit SetAllowlistPermissions(_accounts, _permissions);
-    }
-}
diff -ruN src/CoverageFund.1.sol CoverageFund.1.sol
--- src/CoverageFund.1.sol	2023-12-11 15:38:07
+++ CoverageFund.1.sol	2024-01-16 15:06:39
@@ -1,74 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "./interfaces/IRiver.1.sol";
-import "./interfaces/IAllowlist.1.sol";
-import "./interfaces/ICoverageFund.1.sol";
-
-import "./libraries/LibUint256.sol";
-import "./libraries/LibAllowlistMasks.sol";
-
-import "./Initializable.sol";
-
-import "./state/shared/RiverAddress.sol";
-import "./state/slashingCoverage/BalanceForCoverage.sol";
-
-/// @title Coverage Fund (v1)
-/// @author Kiln
-/// @notice This contract receive donations for the slashing coverage fund and pull the funds into river
-/// @notice This contract acts as a temporary buffer for funds that should be pulled in case of a loss of money on the consensus layer due to slashing events.
-/// @notice There is no fee taken on these funds, they are entirely distributed to the LsETH holders, and no shares will get minted.
-/// @notice Funds will be distributed by increasing the underlying value of every LsETH share.
-/// @notice The fund will be called on every report and if eth is available in the contract, River will attempt to pull as much
-/// @notice ETH as possible. This maximum is defined by the upper bound allowed by the Oracle. This means that it might take multiple
-/// @notice reports for funds to be pulled entirely into the system due to this upper bound, ensuring a lower secondary market impact.
-/// @notice The value provided to this contract is computed off-chain and provided manually by Alluvial or any authorized insurance entity.
-/// @notice The Coverage funds are pulled upon an oracle report, after the ELFees have been pulled in the system, if there is a margin left
-/// @notice before crossing the upper bound. The reason behind this is to favor the revenue stream, that depends on market and network usage, while
-/// @notice the coverage fund will be pulled after the revenue stream, and there won't be any commission on the eth pulled.
-/// @notice Once a Slashing event occurs, the team will do its best to inject the recovery funds in at maximum 365 days
-/// @notice The entities allowed to donate are selected by the team. It will mainly be treasury entities or insurance protocols able to fill this coverage fund properly.
-contract CoverageFundV1 is Initializable, ICoverageFundV1 {
-    /// @inheritdoc ICoverageFundV1
-    function initCoverageFundV1(address _riverAddress) external init(0) {
-        RiverAddress.set(_riverAddress);
-        emit SetRiver(_riverAddress);
-    }
-
-    /// @inheritdoc ICoverageFundV1
-    function pullCoverageFunds(uint256 _maxAmount) external {
-        address river = RiverAddress.get();
-        if (msg.sender != river) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-        uint256 amount = LibUint256.min(_maxAmount, BalanceForCoverage.get());
-
-        if (amount > 0) {
-            BalanceForCoverage.set(BalanceForCoverage.get() - amount);
-            IRiverV1(payable(river)).sendCoverageFunds{value: amount}();
-        }
-    }
-
-    /// @inheritdoc ICoverageFundV1
-    function donate() external payable {
-        if (msg.value == 0) {
-            revert EmptyDonation();
-        }
-        BalanceForCoverage.set(BalanceForCoverage.get() + msg.value);
-
-        IAllowlistV1 allowlist = IAllowlistV1(IRiverV1(payable(RiverAddress.get())).getAllowlist());
-        allowlist.onlyAllowed(msg.sender, LibAllowlistMasks.DONATE_MASK);
-
-        emit Donate(msg.sender, msg.value);
-    }
-
-    /// @inheritdoc ICoverageFundV1
-    receive() external payable {
-        revert InvalidCall();
-    }
-
-    /// @inheritdoc ICoverageFundV1
-    fallback() external payable {
-        revert InvalidCall();
-    }
-}
diff -ruN src/ELFeeRecipient.1.sol ELFeeRecipient.1.sol
--- src/ELFeeRecipient.1.sol	2023-12-11 15:38:07
+++ ELFeeRecipient.1.sol	2024-01-16 15:06:39
@@ -1,45 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "./interfaces/IRiver.1.sol";
-import "./interfaces/IELFeeRecipient.1.sol";
-
-import "./libraries/LibUint256.sol";
-
-import "./Initializable.sol";
-
-import "./state/shared/RiverAddress.sol";
-
-/// @title Execution Layer Fee Recipient (v1)
-/// @author Kiln
-/// @notice This contract receives all the execution layer fees from the proposed blocks + bribes
-contract ELFeeRecipientV1 is Initializable, IELFeeRecipientV1 {
-    /// @inheritdoc IELFeeRecipientV1
-    function initELFeeRecipientV1(address _riverAddress) external init(0) {
-        RiverAddress.set(_riverAddress);
-        emit SetRiver(_riverAddress);
-    }
-
-    /// @inheritdoc IELFeeRecipientV1
-    function pullELFees(uint256 _maxAmount) external {
-        address river = RiverAddress.get();
-        if (msg.sender != river) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-        uint256 amount = LibUint256.min(_maxAmount, address(this).balance);
-
-        if (amount > 0) {
-            IRiverV1(payable(river)).sendELFees{value: amount}();
-        }
-    }
-
-    /// @inheritdoc IELFeeRecipientV1
-    receive() external payable {
-        this;
-    }
-
-    /// @inheritdoc IELFeeRecipientV1
-    fallback() external payable {
-        revert InvalidCall();
-    }
-}
diff -ruN src/Firewall.sol Firewall.sol
--- src/Firewall.sol	2023-12-11 15:38:07
+++ Firewall.sol	2024-01-16 15:06:39
@@ -1,118 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "./interfaces/IFirewall.sol";
-
-import "./Administrable.sol";
-
-/// @title Firewall
-/// @author Figment
-/// @notice This contract accepts calls to admin-level functions of an underlying contract, and
-///         ensures the caller holds an appropriate role for calling that function. There are two roles:
-///          - An Admin can call anything
-///          - An Executor can call specific functions. The list of function is customisable.
-///         Random callers cannot call anything through this contract, even if the underlying function
-///         is unpermissioned in the underlying contract.
-///         Calls to non-admin functions should be called at the underlying contract directly.
-contract Firewall is IFirewall, Administrable {
-    /// @inheritdoc IFirewall
-    address public executor;
-
-    /// @inheritdoc IFirewall
-    address public destination;
-
-    /// @inheritdoc IFirewall
-    mapping(bytes4 => bool) public executorCanCall;
-
-    /// @param _admin Address of the administrator, that is able to perform all calls via the Firewall
-    /// @param _executor Address of the executor, that is able to perform only a subset of calls via the Firewall
-    /// @param _executorCallableSelectors Initial list of allowed selectors for the executor
-    constructor(address _admin, address _executor, address _destination, bytes4[] memory _executorCallableSelectors) {
-        LibSanitize._notZeroAddress(_executor);
-        LibSanitize._notZeroAddress(_destination);
-        _setAdmin(_admin);
-        executor = _executor;
-        destination = _destination;
-
-        emit SetExecutor(_executor);
-        emit SetDestination(_destination);
-
-        for (uint256 i; i < _executorCallableSelectors.length;) {
-            executorCanCall[_executorCallableSelectors[i]] = true;
-            emit SetExecutorPermissions(_executorCallableSelectors[i], true);
-            unchecked {
-                ++i;
-            }
-        }
-    }
-
-    /// @notice Prevents unauthorized calls
-    modifier onlyAdminOrExecutor() {
-        if (_getAdmin() != msg.sender && msg.sender != executor) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-        _;
-    }
-
-    /// @inheritdoc IFirewall
-    function setExecutor(address _newExecutor) external onlyAdminOrExecutor {
-        LibSanitize._notZeroAddress(_newExecutor);
-        executor = _newExecutor;
-        emit SetExecutor(_newExecutor);
-    }
-
-    /// @inheritdoc IFirewall
-    function allowExecutor(bytes4 _functionSelector, bool _executorCanCall) external onlyAdmin {
-        executorCanCall[_functionSelector] = _executorCanCall;
-        emit SetExecutorPermissions(_functionSelector, _executorCanCall);
-    }
-
-    /// @inheritdoc IFirewall
-    fallback() external payable virtual {
-        _fallback();
-    }
-
-    /// @inheritdoc IFirewall
-    receive() external payable virtual {
-        _fallback();
-    }
-
-    /// @notice Performs call checks to verify that the caller is able to perform the call
-    function _checkCallerRole() internal view {
-        if (msg.sender == _getAdmin() || (executorCanCall[msg.sig] && msg.sender == executor)) {
-            return;
-        }
-        revert LibErrors.Unauthorized(msg.sender);
-    }
-
-    /// @notice Forwards the current call parameters to the destination address
-    /// @param _destination Address on which the forwarded call is performed
-    /// @param _value Message value to attach to the call
-    function _forward(address _destination, uint256 _value) internal {
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            // Copy msg.data. We take full control of memory in this inline assembly
-            // block because it will not return to Solidity code. We overwrite the
-            // Solidity scratch pad at memory position 0.
-            calldatacopy(0, 0, calldatasize())
-
-            // Call the destination.
-            // out and outsize are 0 because we don't know the size yet.
-            let result := call(gas(), _destination, _value, 0, calldatasize(), 0, 0)
-
-            // Copy the returned data.
-            returndatacopy(0, 0, returndatasize())
-
-            switch result
-            // call returns 0 on error.
-            case 0 { revert(0, returndatasize()) }
-            default { return(0, returndatasize()) }
-        }
-    }
-
-    /// @notice Internal utility to perform authorization checks and forward a call
-    function _fallback() internal virtual {
-        _checkCallerRole();
-        _forward(destination, msg.value);
-    }
-}
diff -ruN src/Initializable.sol Initializable.sol
--- src/Initializable.sol	2023-12-11 15:38:07
+++ Initializable.sol	2024-01-16 15:06:39
@@ -1,36 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "./state/shared/Version.sol";
-
-/// @title Initializable
-/// @author Kiln
-/// @notice This contract ensures that initializers are called only once per version
-contract Initializable {
-    /// @notice Disable initialization on implementations
-    constructor() {
-        Version.set(type(uint256).max);
-        emit Initialize(type(uint256).max, msg.data);
-    }
-
-    /// @notice An error occured during the initialization
-    /// @param version The version that was attempting to be initialized
-    /// @param expectedVersion The version that was expected
-    error InvalidInitialization(uint256 version, uint256 expectedVersion);
-
-    /// @notice Emitted when the contract is properly initialized
-    /// @param version New version of the contracts
-    /// @param cdata Complete calldata that was used during the initialization
-    event Initialize(uint256 version, bytes cdata);
-
-    /// @notice Use this modifier on initializers along with a hard-coded version number
-    /// @param _version Version to initialize
-    modifier init(uint256 _version) {
-        if (_version != Version.get()) {
-            revert InvalidInitialization(_version, Version.get());
-        }
-        Version.set(_version + 1); // prevents reentrency on the called method
-        _;
-        emit Initialize(_version, msg.data);
-    }
-}
diff -ruN src/OperatorsRegistry.1.sol OperatorsRegistry.1.sol
--- src/OperatorsRegistry.1.sol	2023-12-11 15:38:07
+++ OperatorsRegistry.1.sol	2024-01-16 15:06:39
@@ -1,858 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "./interfaces/IOperatorRegistry.1.sol";
-import "./interfaces/IRiver.1.sol";
-
-import "./libraries/LibUint256.sol";
-
-import "./Initializable.sol";
-import "./Administrable.sol";
-
-import "./state/operatorsRegistry/Operators.1.sol";
-import "./state/operatorsRegistry/Operators.2.sol";
-import "./state/operatorsRegistry/ValidatorKeys.sol";
-import "./state/operatorsRegistry/TotalValidatorExitsRequested.sol";
-import "./state/operatorsRegistry/CurrentValidatorExitsDemand.sol";
-import "./state/shared/RiverAddress.sol";
-
-import "./state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_KeyIndex.sol";
-import "./state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex.sol";
-
-/// @title Operators Registry (v1)
-/// @author Kiln
-/// @notice This contract handles the list of operators and their keys
-contract OperatorsRegistryV1 is IOperatorsRegistryV1, Initializable, Administrable {
-    /// @notice Maximum validators given to an operator per selection loop round
-    uint256 internal constant MAX_VALIDATOR_ATTRIBUTION_PER_ROUND = 5;
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function initOperatorsRegistryV1(address _admin, address _river) external init(0) {
-        _setAdmin(_admin);
-        RiverAddress.set(_river);
-        emit SetRiver(_river);
-    }
-
-    /// @notice Internal migration utility to migrate all operators to OperatorsV2 format
-    function _migrateOperators_V1_1() internal {
-        uint256 opCount = OperatorsV1.getCount();
-
-        for (uint256 idx = 0; idx < opCount;) {
-            OperatorsV1.Operator memory oldOperatorValue = OperatorsV1.get(idx);
-
-            OperatorsV2.push(
-                OperatorsV2.Operator({
-                    limit: uint32(oldOperatorValue.limit),
-                    funded: uint32(oldOperatorValue.funded),
-                    requestedExits: 0,
-                    keys: uint32(oldOperatorValue.keys),
-                    latestKeysEditBlockNumber: uint64(oldOperatorValue.latestKeysEditBlockNumber),
-                    active: oldOperatorValue.active,
-                    name: oldOperatorValue.name,
-                    operator: oldOperatorValue.operator
-                })
-            );
-
-            unchecked {
-                ++idx;
-            }
-        }
-    }
-
-    /// MIGRATION: FUNDED VALIDATOR KEY EVENT REBROADCASTING
-    /// As the event for funded keys was moved from River to this contract because we needed to be able to bind
-    /// operator indexes to public keys, we need to rebroadcast the past funded validator keys with the new event
-    /// to keep retro-compatibility
-
-    /// Emitted when the event rebroadcasting is done and we attempt to broadcast new events
-    error FundedKeyEventMigrationComplete();
-
-    /// Utility to force the broadcasting of events. Will keep its progress in storage to prevent being DoSed by the number of keys
-    /// @param _amountToEmit The amount of events to emit at maximum in this call
-    function forceFundedValidatorKeysEventEmission(uint256 _amountToEmit) external {
-        uint256 operatorIndex = OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex.get();
-        if (operatorIndex == type(uint256).max) {
-            revert FundedKeyEventMigrationComplete();
-        }
-        if (OperatorsV2.getCount() == 0) {
-            OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex.set(type(uint256).max);
-            return;
-        }
-        uint256 keyIndex = OperatorsRegistry_FundedKeyEventRebroadcasting_KeyIndex.get();
-        while (_amountToEmit > 0 && operatorIndex != type(uint256).max) {
-            OperatorsV2.Operator memory operator = OperatorsV2.get(operatorIndex);
-
-            (bytes[] memory publicKeys,) = ValidatorKeys.getKeys(
-                operatorIndex, keyIndex, LibUint256.min(_amountToEmit, operator.funded - keyIndex)
-            );
-            emit FundedValidatorKeys(operatorIndex, publicKeys, true);
-            if (keyIndex + publicKeys.length == operator.funded) {
-                keyIndex = 0;
-                if (operatorIndex == OperatorsV2.getCount() - 1) {
-                    operatorIndex = type(uint256).max;
-                } else {
-                    ++operatorIndex;
-                }
-            } else {
-                keyIndex += publicKeys.length;
-            }
-            _amountToEmit -= publicKeys.length;
-        }
-        OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex.set(operatorIndex);
-        OperatorsRegistry_FundedKeyEventRebroadcasting_KeyIndex.set(keyIndex);
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function initOperatorsRegistryV1_1() external init(1) {
-        _migrateOperators_V1_1();
-    }
-
-    /// @notice Prevent unauthorized calls
-    modifier onlyRiver() virtual {
-        if (msg.sender != RiverAddress.get()) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-        _;
-    }
-
-    /// @notice Prevents anyone except the admin or the given operator to make the call. Also checks if operator is active
-    /// @notice The admin is able to call this method on behalf of any operator, even if inactive
-    /// @param _index The index identifying the operator
-    modifier onlyOperatorOrAdmin(uint256 _index) {
-        if (msg.sender == _getAdmin()) {
-            _;
-            return;
-        }
-        OperatorsV2.Operator storage operator = OperatorsV2.get(_index);
-        if (!operator.active) {
-            revert InactiveOperator(_index);
-        }
-        if (msg.sender != operator.operator) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-        _;
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function getRiver() external view returns (address) {
-        return RiverAddress.get();
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function getOperator(uint256 _index) external view returns (OperatorsV2.Operator memory) {
-        return OperatorsV2.get(_index);
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function getOperatorStoppedValidatorCount(uint256 _idx) external view returns (uint32) {
-        return _getStoppedValidatorsCount(_idx);
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function getTotalStoppedValidatorCount() external view returns (uint32) {
-        return _getTotalStoppedValidatorCount();
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function getTotalValidatorExitsRequested() external view returns (uint256) {
-        return TotalValidatorExitsRequested.get();
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function getCurrentValidatorExitsDemand() external view returns (uint256) {
-        return CurrentValidatorExitsDemand.get();
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function getStoppedAndRequestedExitCounts() external view returns (uint32, uint256) {
-        return
-            (_getTotalStoppedValidatorCount(), TotalValidatorExitsRequested.get() + CurrentValidatorExitsDemand.get());
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function getOperatorCount() external view returns (uint256) {
-        return OperatorsV2.getCount();
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function getStoppedValidatorCountPerOperator() external view returns (uint32[] memory) {
-        uint32[] memory completeList = OperatorsV2.getStoppedValidators();
-        uint256 listLength = completeList.length;
-
-        if (listLength > 0) {
-            assembly {
-                // no need to use free memory pointer as we reuse the same memory range
-
-                // erase previous word storing length
-                mstore(completeList, 0)
-
-                // move memory pointer up by a word
-                completeList := add(completeList, 0x20)
-
-                // store updated length at new memory pointer location
-                mstore(completeList, sub(listLength, 1))
-            }
-        }
-
-        return completeList;
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function getValidator(uint256 _operatorIndex, uint256 _validatorIndex)
-        external
-        view
-        returns (bytes memory publicKey, bytes memory signature, bool funded)
-    {
-        (publicKey, signature) = ValidatorKeys.get(_operatorIndex, _validatorIndex);
-        funded = _validatorIndex < OperatorsV2.get(_operatorIndex).funded;
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function listActiveOperators() external view returns (OperatorsV2.Operator[] memory) {
-        return OperatorsV2.getAllActive();
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function reportStoppedValidatorCounts(uint32[] calldata _stoppedValidatorCounts, uint256 _depositedValidatorCount)
-        external
-        onlyRiver
-    {
-        _setStoppedValidatorCounts(_stoppedValidatorCounts, _depositedValidatorCount);
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function addOperator(string calldata _name, address _operator) external onlyAdmin returns (uint256) {
-        OperatorsV2.Operator memory newOperator = OperatorsV2.Operator({
-            active: true,
-            operator: _operator,
-            name: _name,
-            limit: 0,
-            funded: 0,
-            keys: 0,
-            requestedExits: 0,
-            latestKeysEditBlockNumber: uint64(block.number)
-        });
-
-        uint256 operatorIndex = OperatorsV2.push(newOperator) - 1;
-
-        emit AddedOperator(operatorIndex, _name, _operator);
-        return operatorIndex;
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function setOperatorAddress(uint256 _index, address _newOperatorAddress) external onlyOperatorOrAdmin(_index) {
-        LibSanitize._notZeroAddress(_newOperatorAddress);
-        OperatorsV2.Operator storage operator = OperatorsV2.get(_index);
-
-        operator.operator = _newOperatorAddress;
-
-        emit SetOperatorAddress(_index, _newOperatorAddress);
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function setOperatorName(uint256 _index, string calldata _newName) external onlyOperatorOrAdmin(_index) {
-        LibSanitize._notEmptyString(_newName);
-        OperatorsV2.Operator storage operator = OperatorsV2.get(_index);
-        operator.name = _newName;
-
-        emit SetOperatorName(_index, _newName);
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function setOperatorStatus(uint256 _index, bool _newStatus) external onlyAdmin {
-        OperatorsV2.Operator storage operator = OperatorsV2.get(_index);
-        operator.active = _newStatus;
-
-        emit SetOperatorStatus(_index, _newStatus);
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function setOperatorLimits(
-        uint256[] calldata _operatorIndexes,
-        uint32[] calldata _newLimits,
-        uint256 _snapshotBlock
-    ) external onlyAdmin {
-        if (_operatorIndexes.length != _newLimits.length) {
-            revert InvalidArrayLengths();
-        }
-        if (_operatorIndexes.length == 0) {
-            revert InvalidEmptyArray();
-        }
-        for (uint256 idx = 0; idx < _operatorIndexes.length;) {
-            uint256 operatorIndex = _operatorIndexes[idx];
-            uint32 newLimit = _newLimits[idx];
-
-            // prevents duplicates
-            if (idx > 0 && !(operatorIndex > _operatorIndexes[idx - 1])) {
-                revert UnorderedOperatorList();
-            }
-
-            OperatorsV2.Operator storage operator = OperatorsV2.get(operatorIndex);
-
-            uint32 currentLimit = operator.limit;
-            if (newLimit == currentLimit) {
-                emit OperatorLimitUnchanged(operatorIndex, newLimit);
-                unchecked {
-                    ++idx;
-                }
-                continue;
-            }
-
-            // we enter this condition if the operator edited its keys after the off-chain key audit was made
-            // we will skip any limit update on that operator unless it was a decrease in the initial limit
-            if (_snapshotBlock < operator.latestKeysEditBlockNumber && newLimit > currentLimit) {
-                emit OperatorEditsAfterSnapshot(
-                    operatorIndex, currentLimit, newLimit, operator.latestKeysEditBlockNumber, _snapshotBlock
-                );
-                unchecked {
-                    ++idx;
-                }
-                continue;
-            }
-
-            // otherwise, we check for limit invariants that shouldn't happen if the off-chain key audit
-            // was made properly, and if everything is respected, we update the limit
-
-            if (newLimit > operator.keys) {
-                revert OperatorLimitTooHigh(operatorIndex, newLimit, operator.keys);
-            }
-
-            if (newLimit < operator.funded) {
-                revert OperatorLimitTooLow(operatorIndex, newLimit, operator.funded);
-            }
-
-            operator.limit = newLimit;
-            emit SetOperatorLimit(operatorIndex, newLimit);
-
-            unchecked {
-                ++idx;
-            }
-        }
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function addValidators(uint256 _index, uint32 _keyCount, bytes calldata _publicKeysAndSignatures)
-        external
-        onlyOperatorOrAdmin(_index)
-    {
-        if (_keyCount == 0) {
-            revert InvalidKeyCount();
-        }
-
-        if (
-            _publicKeysAndSignatures.length
-                != _keyCount * (ValidatorKeys.PUBLIC_KEY_LENGTH + ValidatorKeys.SIGNATURE_LENGTH)
-        ) {
-            revert InvalidKeysLength();
-        }
-
-        OperatorsV2.Operator storage operator = OperatorsV2.get(_index);
-
-        for (uint256 idx = 0; idx < _keyCount;) {
-            bytes memory publicKeyAndSignature = LibBytes.slice(
-                _publicKeysAndSignatures,
-                idx * (ValidatorKeys.PUBLIC_KEY_LENGTH + ValidatorKeys.SIGNATURE_LENGTH),
-                ValidatorKeys.PUBLIC_KEY_LENGTH + ValidatorKeys.SIGNATURE_LENGTH
-            );
-            ValidatorKeys.set(_index, operator.keys + idx, publicKeyAndSignature);
-            unchecked {
-                ++idx;
-            }
-        }
-        OperatorsV2.setKeys(_index, operator.keys + _keyCount);
-
-        emit AddedValidatorKeys(_index, _publicKeysAndSignatures);
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function removeValidators(uint256 _index, uint256[] calldata _indexes) external onlyOperatorOrAdmin(_index) {
-        uint256 indexesLength = _indexes.length;
-        if (indexesLength == 0) {
-            revert InvalidKeyCount();
-        }
-
-        OperatorsV2.Operator storage operator = OperatorsV2.get(_index);
-
-        uint32 totalKeys = operator.keys;
-
-        if (!(_indexes[0] < totalKeys)) {
-            revert InvalidIndexOutOfBounds();
-        }
-
-        uint256 lastIndex = _indexes[indexesLength - 1];
-
-        if (lastIndex < operator.funded) {
-            revert InvalidFundedKeyDeletionAttempt();
-        }
-
-        bool limitEqualsKeyCount = operator.keys == operator.limit;
-        OperatorsV2.setKeys(_index, totalKeys - uint32(indexesLength));
-
-        uint256 idx;
-        for (; idx < indexesLength;) {
-            uint256 keyIndex = _indexes[idx];
-
-            if (idx > 0 && !(keyIndex < _indexes[idx - 1])) {
-                revert InvalidUnsortedIndexes();
-            }
-
-            unchecked {
-                ++idx;
-            }
-
-            uint256 lastKeyIndex = totalKeys - idx;
-
-            (bytes memory removedPublicKey,) = ValidatorKeys.get(_index, keyIndex);
-            (bytes memory lastPublicKeyAndSignature) = ValidatorKeys.getRaw(_index, lastKeyIndex);
-            ValidatorKeys.set(_index, keyIndex, lastPublicKeyAndSignature);
-            ValidatorKeys.set(_index, lastKeyIndex, new bytes(0));
-
-            emit RemovedValidatorKey(_index, removedPublicKey);
-        }
-
-        if (limitEqualsKeyCount) {
-            operator.limit = operator.keys;
-        } else if (lastIndex < operator.limit) {
-            operator.limit = uint32(lastIndex);
-        }
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function pickNextValidatorsToDeposit(uint256 _count)
-        external
-        onlyRiver
-        returns (bytes[] memory publicKeys, bytes[] memory signatures)
-    {
-        return _pickNextValidatorsToDepositFromActiveOperators(_count);
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function requestValidatorExits(uint256 _count) external {
-        uint256 currentValidatorExitsDemand = CurrentValidatorExitsDemand.get();
-        uint256 exitRequestsToPerform = LibUint256.min(currentValidatorExitsDemand, _count);
-        if (exitRequestsToPerform == 0) {
-            revert NoExitRequestsToPerform();
-        }
-        uint256 savedCurrentValidatorExitsDemand = currentValidatorExitsDemand;
-        currentValidatorExitsDemand -= _pickNextValidatorsToExitFromActiveOperators(exitRequestsToPerform);
-
-        _setCurrentValidatorExitsDemand(savedCurrentValidatorExitsDemand, currentValidatorExitsDemand);
-    }
-
-    /// @inheritdoc IOperatorsRegistryV1
-    function demandValidatorExits(uint256 _count, uint256 _depositedValidatorCount) external onlyRiver {
-        uint256 currentValidatorExitsDemand = CurrentValidatorExitsDemand.get();
-        uint256 totalValidatorExitsRequested = TotalValidatorExitsRequested.get();
-        _count = LibUint256.min(
-            _count, _depositedValidatorCount - (totalValidatorExitsRequested + currentValidatorExitsDemand)
-        );
-        if (_count > 0) {
-            _setCurrentValidatorExitsDemand(currentValidatorExitsDemand, currentValidatorExitsDemand + _count);
-        }
-    }
-
-    /// @notice Internal utility to retrieve the total stopped validator count
-    /// @return The total stopped validator count
-    function _getTotalStoppedValidatorCount() internal view returns (uint32) {
-        uint32[] storage stoppedValidatorCounts = OperatorsV2.getStoppedValidators();
-        if (stoppedValidatorCounts.length == 0) {
-            return 0;
-        }
-        return stoppedValidatorCounts[0];
-    }
-
-    /// @notice Internal utility to set the current validator exits demand
-    /// @param _currentValue The current value
-    /// @param _newValue The new value
-    function _setCurrentValidatorExitsDemand(uint256 _currentValue, uint256 _newValue) internal {
-        CurrentValidatorExitsDemand.set(_newValue);
-        emit SetCurrentValidatorExitsDemand(_currentValue, _newValue);
-    }
-
-    /// @notice Internal structure to hold variables for the _setStoppedValidatorCounts method
-    struct SetStoppedValidatorCountInternalVars {
-        uint256 stoppedValidatorCountsLength;
-        uint32[] currentStoppedValidatorCounts;
-        uint256 currentStoppedValidatorCountsLength;
-        uint32 totalStoppedValidatorCount;
-        uint32 count;
-        uint256 currentValidatorExitsDemand;
-        uint256 cachedCurrentValidatorExitsDemand;
-        uint256 totalRequestedExits;
-        uint256 cachedTotalRequestedExits;
-    }
-
-    /// @notice Internal utiltiy to set the stopped validator array after sanity checks
-    /// @param _stoppedValidatorCounts The stopped validators counts for every operator + the total count in index 0
-    /// @param _depositedValidatorCount The current deposited validator count
-    function _setStoppedValidatorCounts(uint32[] calldata _stoppedValidatorCounts, uint256 _depositedValidatorCount)
-        internal
-    {
-        SetStoppedValidatorCountInternalVars memory vars;
-        // we check that the array is not empty
-        vars.stoppedValidatorCountsLength = _stoppedValidatorCounts.length;
-        if (vars.stoppedValidatorCountsLength == 0) {
-            revert InvalidEmptyStoppedValidatorCountsArray();
-        }
-
-        OperatorsV2.Operator[] storage operators = OperatorsV2.getAll();
-
-        // we check that the cells containing operator stopped values are no more than the current operator count
-        if (vars.stoppedValidatorCountsLength - 1 > operators.length) {
-            revert StoppedValidatorCountsTooHigh();
-        }
-
-        vars.currentStoppedValidatorCounts = OperatorsV2.getStoppedValidators();
-        vars.currentStoppedValidatorCountsLength = vars.currentStoppedValidatorCounts.length;
-
-        // we check that the number of stopped values is not decreasing
-        if (vars.stoppedValidatorCountsLength < vars.currentStoppedValidatorCountsLength) {
-            revert StoppedValidatorCountArrayShrinking();
-        }
-
-        vars.totalStoppedValidatorCount = _stoppedValidatorCounts[0];
-        vars.count = 0;
-
-        // create value to track unsollicited validator exits (e.g. to cover cases when Node Operator exit a validator without being requested to)
-        vars.currentValidatorExitsDemand = CurrentValidatorExitsDemand.get();
-        vars.cachedCurrentValidatorExitsDemand = vars.currentValidatorExitsDemand;
-        vars.totalRequestedExits = TotalValidatorExitsRequested.get();
-        vars.cachedTotalRequestedExits = vars.totalRequestedExits;
-
-        uint256 idx = 1;
-        uint256 unsollicitedExitsSum;
-        for (; idx < vars.currentStoppedValidatorCountsLength;) {
-            // if the previous array was long enough, we check that the values are not decreasing
-            if (_stoppedValidatorCounts[idx] < vars.currentStoppedValidatorCounts[idx]) {
-                revert StoppedValidatorCountsDecreased();
-            }
-
-            // we check that the count of stopped validators is not above the funded validator count of an operator
-            if (_stoppedValidatorCounts[idx] > operators[idx - 1].funded) {
-                revert StoppedValidatorCountAboveFundedCount(
-                    idx - 1, _stoppedValidatorCounts[idx], operators[idx - 1].funded
-                );
-            }
-
-            // if the stopped validator count is greater than its requested exit count, we update the requested exit count
-            if (_stoppedValidatorCounts[idx] > operators[idx - 1].requestedExits) {
-                emit UpdatedRequestedValidatorExitsUponStopped(
-                    idx - 1, operators[idx - 1].requestedExits, _stoppedValidatorCounts[idx]
-                );
-                unsollicitedExitsSum += _stoppedValidatorCounts[idx] - operators[idx - 1].requestedExits;
-                operators[idx - 1].requestedExits = _stoppedValidatorCounts[idx];
-            }
-            emit SetOperatorStoppedValidatorCount(idx - 1, _stoppedValidatorCounts[idx]);
-
-            // we recompute the total to ensure it's not an invalid sum
-            vars.count += _stoppedValidatorCounts[idx];
-            unchecked {
-                ++idx;
-            }
-        }
-
-        // In case of a new operator we do not check against the current stopped validator count (would revert OOB)
-        for (; idx < vars.stoppedValidatorCountsLength;) {
-            // we check that the count of stopped validators is not above the funded validator count of an operator
-            if (_stoppedValidatorCounts[idx] > operators[idx - 1].funded) {
-                revert StoppedValidatorCountAboveFundedCount(
-                    idx - 1, _stoppedValidatorCounts[idx], operators[idx - 1].funded
-                );
-            }
-
-            // if the stopped validator count is greater than its requested exit count, we update the requested exit count
-            if (_stoppedValidatorCounts[idx] > operators[idx - 1].requestedExits) {
-                emit UpdatedRequestedValidatorExitsUponStopped(
-                    idx - 1, operators[idx - 1].requestedExits, _stoppedValidatorCounts[idx]
-                );
-                unsollicitedExitsSum += _stoppedValidatorCounts[idx] - operators[idx - 1].requestedExits;
-                operators[idx - 1].requestedExits = _stoppedValidatorCounts[idx];
-            }
-            emit SetOperatorStoppedValidatorCount(idx - 1, _stoppedValidatorCounts[idx]);
-
-            // we recompute the total to ensure it's not an invalid sum
-            vars.count += _stoppedValidatorCounts[idx];
-            unchecked {
-                ++idx;
-            }
-        }
-
-        vars.totalRequestedExits += unsollicitedExitsSum;
-        // we decrease the demand, considering unsollicited exits as if they were answering the demand
-        vars.currentValidatorExitsDemand -= LibUint256.min(unsollicitedExitsSum, vars.currentValidatorExitsDemand);
-
-        if (vars.totalRequestedExits != vars.cachedTotalRequestedExits) {
-            _setTotalValidatorExitsRequested(vars.cachedTotalRequestedExits, vars.totalRequestedExits);
-        }
-
-        if (vars.currentValidatorExitsDemand != vars.cachedCurrentValidatorExitsDemand) {
-            _setCurrentValidatorExitsDemand(vars.cachedCurrentValidatorExitsDemand, vars.currentValidatorExitsDemand);
-        }
-
-        // we check that the total is matching the sum of the individual values
-        if (vars.totalStoppedValidatorCount != vars.count) {
-            revert InvalidStoppedValidatorCountsSum();
-        }
-        // we check that the total is not higher than the current deposited validator count
-        if (vars.totalStoppedValidatorCount > _depositedValidatorCount) {
-            revert StoppedValidatorCountsTooHigh();
-        }
-        // we set the new stopped validators counts
-        OperatorsV2.setRawStoppedValidators(_stoppedValidatorCounts);
-        emit UpdatedStoppedValidators(_stoppedValidatorCounts);
-    }
-
-    /// @notice Internal utility to concatenate bytes arrays together
-    /// @param _arr1 First array
-    /// @param _arr2 Second array
-    /// @return The result of the concatenation of _arr1 + _arr2
-    function _concatenateByteArrays(bytes[] memory _arr1, bytes[] memory _arr2)
-        internal
-        pure
-        returns (bytes[] memory)
-    {
-        bytes[] memory res = new bytes[](_arr1.length + _arr2.length);
-        for (uint256 idx = 0; idx < _arr1.length;) {
-            res[idx] = _arr1[idx];
-            unchecked {
-                ++idx;
-            }
-        }
-        for (uint256 idx = 0; idx < _arr2.length;) {
-            res[idx + _arr1.length] = _arr2[idx];
-            unchecked {
-                ++idx;
-            }
-        }
-        return res;
-    }
-
-    /// @notice Internal utility to verify if an operator has fundable keys during the selection process
-    /// @param _operator The Operator structure in memory
-    /// @return True if at least one fundable key is available
-    function _hasFundableKeys(OperatorsV2.CachedOperator memory _operator) internal pure returns (bool) {
-        return (_operator.funded + _operator.picked) < _operator.limit;
-    }
-
-    /// @notice Internal utility to retrieve the actual stopped validator count of an operator from the reported array
-    /// @param _operatorIndex The operator index
-    /// @return The count of stopped validators
-    function _getStoppedValidatorsCount(uint256 _operatorIndex) internal view returns (uint32) {
-        return OperatorsV2._getStoppedValidatorCountAtIndex(OperatorsV2.getStoppedValidators(), _operatorIndex);
-    }
-
-    /// @notice Internal utility to get the count of active validators during the deposit selection process
-    /// @param _operator The Operator structure in memory
-    /// @return The count of active validators for the operator
-    function _getActiveValidatorCountForDeposits(OperatorsV2.CachedOperator memory _operator)
-        internal
-        view
-        returns (uint256)
-    {
-        return (_operator.funded + _operator.picked) - _getStoppedValidatorsCount(_operator.index);
-    }
-
-    /// @notice Internal utility to retrieve _count or lower fundable keys
-    /// @dev The selection process starts by retrieving the full list of active operators with at least one fundable key.
-    /// @dev
-    /// @dev An operator is considered to have at least one fundable key when their staking limit is higher than their funded key count.
-    /// @dev
-    /// @dev    isFundable = operator.active && operator.limit > operator.funded
-    /// @dev
-    /// @dev The internal utility will loop on all operators and select the operator with the lowest active validator count.
-    /// @dev The active validator count is computed by subtracting the stopped validator count to the funded validator count.
-    /// @dev
-    /// @dev    activeValidatorCount = operator.funded - operator.stopped
-    /// @dev
-    /// @dev During the selection process, we keep in memory all previously selected operators and the number of given validators inside a field
-    /// @dev called picked that only exists on the CachedOperator structure in memory.
-    /// @dev
-    /// @dev    isFundable = operator.active && operator.limit > (operator.funded + operator.picked)
-    /// @dev    activeValidatorCount = (operator.funded + operator.picked) - operator.stopped
-    /// @dev
-    /// @dev When we reach the requested key count or when all available keys are used, we perform a final loop on all the operators and extract keys
-    /// @dev if any operator has a positive picked count. We then update the storage counters and return the arrays with the public keys and signatures.
-    /// @param _count Amount of keys required. Contract is expected to send _count or lower.
-    /// @return publicKeys An array of fundable public keys
-    /// @return signatures An array of signatures linked to the public keys
-    function _pickNextValidatorsToDepositFromActiveOperators(uint256 _count)
-        internal
-        returns (bytes[] memory publicKeys, bytes[] memory signatures)
-    {
-        (OperatorsV2.CachedOperator[] memory operators, uint256 fundableOperatorCount) = OperatorsV2.getAllFundable();
-
-        if (fundableOperatorCount == 0) {
-            return (new bytes[](0), new bytes[](0));
-        }
-
-        while (_count > 0) {
-            // loop on operators to find the first that has fundable keys, taking into account previous loop round attributions
-            uint256 selectedOperatorIndex = 0;
-            for (; selectedOperatorIndex < fundableOperatorCount;) {
-                if (_hasFundableKeys(operators[selectedOperatorIndex])) {
-                    break;
-                }
-                unchecked {
-                    ++selectedOperatorIndex;
-                }
-            }
-
-            // if we reach the end, we have allocated all keys
-            if (selectedOperatorIndex == fundableOperatorCount) {
-                break;
-            }
-
-            // we start from the next operator and we try to find one that has fundable keys but a lower (funded + picked) - stopped value
-            for (uint256 idx = selectedOperatorIndex + 1; idx < fundableOperatorCount;) {
-                if (
-                    _getActiveValidatorCountForDeposits(operators[idx])
-                        < _getActiveValidatorCountForDeposits(operators[selectedOperatorIndex])
-                        && _hasFundableKeys(operators[idx])
-                ) {
-                    selectedOperatorIndex = idx;
-                }
-                unchecked {
-                    ++idx;
-                }
-            }
-
-            // we take the smallest value between limit - (funded + picked), _requestedAmount and MAX_VALIDATOR_ATTRIBUTION_PER_ROUND
-            uint256 pickedKeyCount = LibUint256.min(
-                LibUint256.min(
-                    operators[selectedOperatorIndex].limit
-                        - (operators[selectedOperatorIndex].funded + operators[selectedOperatorIndex].picked),
-                    MAX_VALIDATOR_ATTRIBUTION_PER_ROUND
-                ),
-                _count
-            );
-
-            // we update the cached picked amount
-            operators[selectedOperatorIndex].picked += uint32(pickedKeyCount);
-
-            // we update the requested amount count
-            _count -= pickedKeyCount;
-        }
-
-        // we loop on all operators
-        for (uint256 idx = 0; idx < fundableOperatorCount; ++idx) {
-            // if we picked keys on any operator, we extract the keys from storage and concatenate them in the result
-            // we then update the funded value
-            if (operators[idx].picked > 0) {
-                (bytes[] memory _publicKeys, bytes[] memory _signatures) =
-                    ValidatorKeys.getKeys(operators[idx].index, operators[idx].funded, operators[idx].picked);
-                emit FundedValidatorKeys(operators[idx].index, _publicKeys, false);
-                publicKeys = _concatenateByteArrays(publicKeys, _publicKeys);
-                signatures = _concatenateByteArrays(signatures, _signatures);
-                (OperatorsV2.get(operators[idx].index)).funded += operators[idx].picked;
-            }
-        }
-    }
-
-    /// @notice Internal utility to get the count of active validators during the exit selection process
-    /// @param _operator The Operator structure in memory
-    /// @return The count of active validators for the operator
-    function _getActiveValidatorCountForExitRequests(OperatorsV2.CachedExitableOperator memory _operator)
-        internal
-        pure
-        returns (uint32)
-    {
-        return _operator.funded - (_operator.requestedExits + _operator.picked);
-    }
-
-    /// @notice Internal utility to pick the next validator counts to exit for every operator
-    /// @param _count The count of validators to request exits for
-    function _pickNextValidatorsToExitFromActiveOperators(uint256 _count) internal returns (uint256) {
-        (OperatorsV2.CachedExitableOperator[] memory operators, uint256 exitableOperatorCount) =
-            OperatorsV2.getAllExitable();
-
-        if (exitableOperatorCount == 0) {
-            return 0;
-        }
-
-        uint256 initialExitRequestDemand = _count;
-        uint256 totalRequestedExitsValue = TotalValidatorExitsRequested.get();
-        uint256 totalRequestedExitsCopy = totalRequestedExitsValue;
-
-        // we loop to find the highest count of active validators, the number of operators that have this amount and the second highest amount
-        while (_count > 0) {
-            uint32 highestActiveCount = 0;
-            uint32 secondHighestActiveCount = 0;
-            uint32 siblings = 0;
-
-            for (uint256 idx = 0; idx < exitableOperatorCount;) {
-                uint32 activeCount = _getActiveValidatorCountForExitRequests(operators[idx]);
-
-                if (activeCount == highestActiveCount) {
-                    ++siblings;
-                } else if (activeCount > highestActiveCount) {
-                    secondHighestActiveCount = highestActiveCount;
-                    highestActiveCount = activeCount;
-                    siblings = 1;
-                } else if (activeCount > secondHighestActiveCount) {
-                    secondHighestActiveCount = activeCount;
-                }
-
-                unchecked {
-                    ++idx;
-                }
-            }
-
-            // we exited all exitable validators
-            if (highestActiveCount == 0) {
-                break;
-            }
-            // The optimal amount is how much we should dispatch to all the operators with the highest count for them to get the same amount
-            // of active validators as the second highest count. We then take the minimum between this value and the total we need to exit
-            uint32 optimalTotalDispatchCount =
-                uint32(LibUint256.min((highestActiveCount - secondHighestActiveCount) * siblings, _count));
-
-            // We lookup the operators again to assign the exit requests
-            uint256 rest = optimalTotalDispatchCount % siblings;
-            uint32 baseExitRequestAmount = optimalTotalDispatchCount / siblings;
-            for (uint256 idx = 0; idx < exitableOperatorCount;) {
-                if (_getActiveValidatorCountForExitRequests(operators[idx]) == highestActiveCount) {
-                    uint32 additionalRequestedExits = baseExitRequestAmount + (rest > 0 ? 1 : 0);
-                    operators[idx].picked += additionalRequestedExits;
-                    if (rest > 0) {
-                        --rest;
-                    }
-                }
-                unchecked {
-                    ++idx;
-                }
-            }
-
-            totalRequestedExitsValue += optimalTotalDispatchCount;
-            _count -= optimalTotalDispatchCount;
-        }
-
-        // We loop over the operators and apply the change, also emit the exit request event
-        for (uint256 idx = 0; idx < exitableOperatorCount;) {
-            if (operators[idx].picked > 0) {
-                uint256 opIndex = operators[idx].index;
-                uint32 newRequestedExits = operators[idx].requestedExits + operators[idx].picked;
-
-                OperatorsV2.get(opIndex).requestedExits = newRequestedExits;
-                emit RequestedValidatorExits(opIndex, newRequestedExits);
-            }
-
-            unchecked {
-                ++idx;
-            }
-        }
-
-        if (totalRequestedExitsValue != totalRequestedExitsCopy) {
-            _setTotalValidatorExitsRequested(totalRequestedExitsCopy, totalRequestedExitsValue);
-        }
-
-        return initialExitRequestDemand - _count;
-    }
-
-    /// @notice Internal utility to set the total validator exits requested by the system
-    /// @param _currentValue The current value of the total validator exits requested
-    /// @param _newValue The new value of the total validator exits requested
-    function _setTotalValidatorExitsRequested(uint256 _currentValue, uint256 _newValue) internal {
-        TotalValidatorExitsRequested.set(_newValue);
-        emit SetTotalValidatorExitsRequested(_currentValue, _newValue);
-    }
-}
diff -ruN src/Oracle.1.sol Oracle.1.sol
--- src/Oracle.1.sol	2023-12-11 15:38:07
+++ Oracle.1.sol	2024-01-16 15:06:39
@@ -1,283 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "./interfaces/IRiver.1.sol";
-import "./interfaces/IOracle.1.sol";
-
-import "./Administrable.sol";
-import "./Initializable.sol";
-
-import "./state/shared/RiverAddress.sol";
-
-import "./state/oracle/LastEpochId.sol";
-import "./state/oracle/OracleMembers.sol";
-import "./state/oracle/Quorum.sol";
-import "./state/oracle/ReportsPositions.sol";
-
-/// @title Oracle (v1)
-/// @author Kiln
-/// @notice This contract handles the input from the allowed oracle members. Highly inspired by Lido's implementation.
-contract OracleV1 is IOracleV1, Initializable, Administrable {
-    modifier onlyAdminOrMember(address _oracleMember) {
-        if (msg.sender != _getAdmin() && msg.sender != _oracleMember) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-        _;
-    }
-
-    /// @inheritdoc IOracleV1
-    function initOracleV1(
-        address _riverAddress,
-        address _administratorAddress,
-        uint64 _epochsPerFrame,
-        uint64 _slotsPerEpoch,
-        uint64 _secondsPerSlot,
-        uint64 _genesisTime,
-        uint256 _annualAprUpperBound,
-        uint256 _relativeLowerBound
-    ) external init(0) {
-        _setAdmin(_administratorAddress);
-        RiverAddress.set(_riverAddress);
-        emit SetRiver(_riverAddress);
-        CLSpec.set(
-            CLSpec.CLSpecStruct({
-                epochsPerFrame: _epochsPerFrame,
-                slotsPerEpoch: _slotsPerEpoch,
-                secondsPerSlot: _secondsPerSlot,
-                genesisTime: _genesisTime,
-                epochsToAssumedFinality: 0
-            })
-        );
-        emit SetSpec(_epochsPerFrame, _slotsPerEpoch, _secondsPerSlot, _genesisTime);
-        ReportBounds.set(
-            ReportBounds.ReportBoundsStruct({
-                annualAprUpperBound: _annualAprUpperBound,
-                relativeLowerBound: _relativeLowerBound
-            })
-        );
-        emit SetBounds(_annualAprUpperBound, _relativeLowerBound);
-        Quorum.set(0);
-        emit SetQuorum(0);
-    }
-
-    /// @inheritdoc IOracleV1
-    function initOracleV1_1() external init(1) {
-        _clearReports();
-    }
-
-    /// @inheritdoc IOracleV1
-    function getRiver() external view returns (address) {
-        return RiverAddress.get();
-    }
-
-    /// @inheritdoc IOracleV1
-    function getMemberReportStatus(address _oracleMember) external view returns (bool) {
-        int256 memberIndex = OracleMembers.indexOf(_oracleMember);
-        return memberIndex != -1 && ReportsPositions.get(uint256(memberIndex));
-    }
-
-    /// @inheritdoc IOracleV1
-    function getGlobalReportStatus() external view returns (uint256) {
-        return ReportsPositions.getRaw();
-    }
-
-    /// @inheritdoc IOracleV1
-    function getReportVariantsCount() external view returns (uint256) {
-        return ReportsVariants.get().length;
-    }
-
-    /// @inheritdoc IOracleV1
-    function getReportVariantDetails(uint256 _idx)
-        external
-        view
-        returns (ReportsVariants.ReportVariantDetails memory)
-    {
-        if (ReportsVariants.get().length <= _idx) {
-            revert ReportIndexOutOfBounds(_idx, ReportsVariants.get().length);
-        }
-        return ReportsVariants.get()[_idx];
-    }
-
-    /// @inheritdoc IOracleV1
-    function getQuorum() external view returns (uint256) {
-        return Quorum.get();
-    }
-
-    /// @inheritdoc IOracleV1
-    function getOracleMembers() external view returns (address[] memory) {
-        return OracleMembers.get();
-    }
-
-    /// @inheritdoc IOracleV1
-    function isMember(address _memberAddress) external view returns (bool) {
-        return OracleMembers.indexOf(_memberAddress) >= 0;
-    }
-
-    /// @inheritdoc IOracleV1
-    function getLastReportedEpochId() external view returns (uint256) {
-        return LastEpochId.get();
-    }
-
-    /// @inheritdoc IOracleV1
-    function addMember(address _newOracleMember, uint256 _newQuorum) external onlyAdmin {
-        int256 memberIdx = OracleMembers.indexOf(_newOracleMember);
-        if (memberIdx >= 0) {
-            revert AddressAlreadyInUse(_newOracleMember);
-        }
-        OracleMembers.push(_newOracleMember);
-        uint256 previousQuorum = Quorum.get();
-        _clearReportsAndSetQuorum(_newQuorum, previousQuorum);
-        emit AddMember(_newOracleMember);
-    }
-
-    /// @inheritdoc IOracleV1
-    function removeMember(address _oracleMember, uint256 _newQuorum) external onlyAdmin {
-        int256 memberIdx = OracleMembers.indexOf(_oracleMember);
-        if (memberIdx < 0) {
-            revert LibErrors.InvalidCall();
-        }
-        OracleMembers.deleteItem(uint256(memberIdx));
-        uint256 previousQuorum = Quorum.get();
-        _clearReportsAndSetQuorum(_newQuorum, previousQuorum);
-        emit RemoveMember(_oracleMember);
-    }
-
-    /// @inheritdoc IOracleV1
-    function setMember(address _oracleMember, address _newAddress) external onlyAdminOrMember(_oracleMember) {
-        LibSanitize._notZeroAddress(_newAddress);
-        if (OracleMembers.indexOf(_newAddress) >= 0) {
-            revert AddressAlreadyInUse(_newAddress);
-        }
-        int256 memberIdx = OracleMembers.indexOf(_oracleMember);
-        if (memberIdx < 0) {
-            revert LibErrors.InvalidCall();
-        }
-        OracleMembers.set(uint256(memberIdx), _newAddress);
-        emit SetMember(_oracleMember, _newAddress);
-    }
-
-    /// @inheritdoc IOracleV1
-    function setQuorum(uint256 _newQuorum) external onlyAdmin {
-        uint256 previousQuorum = Quorum.get();
-        if (previousQuorum == _newQuorum) {
-            revert LibErrors.InvalidArgument();
-        }
-        _clearReportsAndSetQuorum(_newQuorum, previousQuorum);
-    }
-
-    /// @inheritdoc IOracleV1
-    function reportConsensusLayerData(IRiverV1.ConsensusLayerReport calldata _report) external {
-        // retrieve member index and revert if not oracle member
-        int256 memberIndex = OracleMembers.indexOf(msg.sender);
-        if (memberIndex == -1) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-
-        // store last reported epoch to stack
-        uint256 lastReportedEpochValue = LastEpochId.get();
-
-        // checks that the report epoch is not too old
-        if (_report.epoch < lastReportedEpochValue) {
-            revert EpochTooOld(_report.epoch, LastEpochId.get());
-        }
-        IRiverV1 river = IRiverV1(payable(RiverAddress.get()));
-        // checks that the report epoch is not invalid
-        if (!river.isValidEpoch(_report.epoch)) {
-            revert InvalidEpoch(_report.epoch);
-        }
-        // if valid and greater than the lastReportedEpoch, we clear the reporting data
-        if (_report.epoch > lastReportedEpochValue) {
-            _clearReports();
-            LastEpochId.set(_report.epoch);
-            emit SetLastReportedEpoch(_report.epoch);
-        }
-        // we retrieve the voting status of the caller, and revert if already voted
-        if (ReportsPositions.get(uint256(memberIndex))) {
-            revert AlreadyReported(_report.epoch, msg.sender);
-        }
-        // we register the caller
-        ReportsPositions.register(uint256(memberIndex));
-
-        // we compute the variant by hashing the report
-        bytes32 variant = _reportChecksum(_report);
-        // we retrieve the details for the given variant
-        (int256 variantIndex, uint256 variantVotes) = _getReportVariantIndexAndVotes(variant);
-        // we retrieve the quorum to stack
-        uint256 quorum = Quorum.get();
-
-        emit ReportedConsensusLayerData(msg.sender, variant, _report, variantVotes + 1, quorum);
-
-        // if adding this vote reaches quorum
-        if (variantVotes + 1 >= quorum) {
-            // we clear the reporting data
-            _clearReports();
-            // we increment the lastReportedEpoch to force reports to be on the last frame
-            LastEpochId.set(_report.epoch + 1);
-            // we push the report to river
-            river.setConsensusLayerData(_report);
-            emit SetLastReportedEpoch(_report.epoch + 1);
-        } else if (variantVotes == 0) {
-            // if we have no votes for the variant, we create the variant details
-            ReportsVariants.push(ReportsVariants.ReportVariantDetails({variant: variant, votes: 1}));
-        } else {
-            // otherwise we increment the vote
-            ReportsVariants.get()[uint256(variantIndex)].votes += 1;
-        }
-    }
-
-    /// @notice Internal utility to clear all the reports and edit the quorum if a new value is provided
-    /// @dev Ensures that the quorum respects invariants
-    /// @dev The admin is in charge of providing a proper quorum based on the oracle member count
-    /// @dev The quorum value Q should respect the following invariant, where O is oracle member count
-    /// @dev (O / 2) + 1 <= Q <= O
-    /// @param _newQuorum New quorum value
-    /// @param _previousQuorum The old quorum value
-    function _clearReportsAndSetQuorum(uint256 _newQuorum, uint256 _previousQuorum) internal {
-        uint256 memberCount = OracleMembers.get().length;
-        if ((_newQuorum == 0 && memberCount > 0) || _newQuorum > memberCount) {
-            revert LibErrors.InvalidArgument();
-        }
-        _clearReports();
-        if (_newQuorum != _previousQuorum) {
-            Quorum.set(_newQuorum);
-            emit SetQuorum(_newQuorum);
-        }
-    }
-
-    /// @notice Internal utility to hash and retrieve the variant id of a report
-    /// @param _report The reported data structure
-    /// @return The report variant
-    function _reportChecksum(IRiverV1.ConsensusLayerReport calldata _report) internal pure returns (bytes32) {
-        return keccak256(abi.encode(_report));
-    }
-
-    /// @notice Internal utility to clear all reporting details
-    function _clearReports() internal {
-        ReportsVariants.clear();
-        ReportsPositions.clear();
-        emit ClearedReporting();
-    }
-
-    /// @notice Internal utility to retrieve index and vote count for a given variant
-    /// @param _variant The variant to lookup
-    /// @return The index of the variant, -1 if not found
-    /// @return The vote count of the variant
-    function _getReportVariantIndexAndVotes(bytes32 _variant) internal view returns (int256, uint256) {
-        uint256 reportVariantsLength = ReportsVariants.get().length;
-        for (uint256 idx = 0; idx < reportVariantsLength;) {
-            if (ReportsVariants.get()[idx].variant == _variant) {
-                return (int256(idx), ReportsVariants.get()[idx].votes);
-            }
-            unchecked {
-                ++idx;
-            }
-        }
-        return (-1, 0);
-    }
-
-    /// @notice Internal utility to retrieve a casted River interface
-    /// @return The casted River interface
-    function _river() internal view returns (IRiverV1) {
-        return IRiverV1(payable(RiverAddress.get()));
-    }
-}
diff -ruN src/RedeemManager.1.sol RedeemManager.1.sol
--- src/RedeemManager.1.sol	2023-12-15 14:04:57
+++ RedeemManager.1.sol	2024-01-16 15:06:39
@@ -1,531 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "./interfaces/IAllowlist.1.sol";
-import "./interfaces/IRiver.1.sol";
-import "./interfaces/IRedeemManager.1.sol";
-import "./libraries/LibAllowlistMasks.sol";
-import "./libraries/LibUint256.sol";
-import "./Initializable.sol";
-
-import "./state/shared/RiverAddress.sol";
-import "./state/redeemManager/RedeemQueue.sol";
-import "./state/redeemManager/WithdrawalStack.sol";
-import "./state/redeemManager/BufferedExceedingEth.sol";
-import "./state/redeemManager/RedeemDemand.sol";
-
-/// @title Redeem Manager (v1)
-/// @author Kiln
-/// @notice This contract handles the redeem requests of all users
-contract RedeemManagerV1 is Initializable, IRedeemManagerV1 {
-    /// @notice Value returned when resolving a redeem request that is unsatisfied
-    int64 internal constant RESOLVE_UNSATISFIED = -1;
-    /// @notice Value returned when resolving a redeem request that is out of bounds
-    int64 internal constant RESOLVE_OUT_OF_BOUNDS = -2;
-    /// @notice Value returned when resolving a redeem request that is already claimed
-    int64 internal constant RESOLVE_FULLY_CLAIMED = -3;
-
-    /// @notice Status value returned when fully claiming a redeem request
-    uint8 internal constant CLAIM_FULLY_CLAIMED = 0;
-    /// @notice Status value returned when partially claiming a redeem request
-    uint8 internal constant CLAIM_PARTIALLY_CLAIMED = 1;
-    /// @notice Status value returned when a redeem request is already claimed and skipped during a claim
-    uint8 internal constant CLAIM_SKIPPED = 2;
-
-    modifier onlyRiver() {
-        if (msg.sender != RiverAddress.get()) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-        _;
-    }
-
-    modifier onlyRedeemerOrRiver() {
-        {
-            IRiverV1 river = _castedRiver();
-            if (msg.sender != address(river)) {
-                IAllowlistV1(river.getAllowlist()).onlyAllowed(msg.sender, LibAllowlistMasks.REDEEM_MASK);
-            }
-        }
-        _;
-    }
-
-    modifier onlyRedeemer() {
-        {
-            IRiverV1 river = _castedRiver();
-            IAllowlistV1(river.getAllowlist()).onlyAllowed(msg.sender, LibAllowlistMasks.REDEEM_MASK);
-        }
-        _;
-    }
-
-    /// @inheritdoc IRedeemManagerV1
-    function initializeRedeemManagerV1(address _river) external init(0) {
-        RiverAddress.set(_river);
-        emit SetRiver(_river);
-    }
-
-    /// @inheritdoc IRedeemManagerV1
-    function getRiver() external view returns (address) {
-        return RiverAddress.get();
-    }
-
-    /// @inheritdoc IRedeemManagerV1
-    function getRedeemRequestCount() external view returns (uint256) {
-        return RedeemQueue.get().length;
-    }
-
-    /// @inheritdoc IRedeemManagerV1
-    function getRedeemRequestDetails(uint32 _redeemRequestId)
-        external
-        view
-        returns (RedeemQueue.RedeemRequest memory)
-    {
-        return RedeemQueue.get()[_redeemRequestId];
-    }
-
-    /// @inheritdoc IRedeemManagerV1
-    function getWithdrawalEventCount() external view returns (uint256) {
-        return WithdrawalStack.get().length;
-    }
-
-    /// @inheritdoc IRedeemManagerV1
-    function getWithdrawalEventDetails(uint32 _withdrawalEventId)
-        external
-        view
-        returns (WithdrawalStack.WithdrawalEvent memory)
-    {
-        return WithdrawalStack.get()[_withdrawalEventId];
-    }
-
-    /// @inheritdoc IRedeemManagerV1
-    function getBufferedExceedingEth() external view returns (uint256) {
-        return BufferedExceedingEth.get();
-    }
-
-    /// @inheritdoc IRedeemManagerV1
-    function getRedeemDemand() external view returns (uint256) {
-        return RedeemDemand.get();
-    }
-
-    /// @inheritdoc IRedeemManagerV1
-    function resolveRedeemRequests(uint32[] calldata _redeemRequestIds)
-        external
-        view
-        returns (int64[] memory withdrawalEventIds)
-    {
-        withdrawalEventIds = new int64[](_redeemRequestIds.length);
-        WithdrawalStack.WithdrawalEvent memory lastWithdrawalEvent;
-        WithdrawalStack.WithdrawalEvent[] storage withdrawalEvents = WithdrawalStack.get();
-        uint256 withdrawalEventsLength = withdrawalEvents.length;
-        if (withdrawalEventsLength > 0) {
-            lastWithdrawalEvent = withdrawalEvents[withdrawalEventsLength - 1];
-        }
-        for (uint256 idx = 0; idx < _redeemRequestIds.length; ++idx) {
-            withdrawalEventIds[idx] = _resolveRedeemRequestId(_redeemRequestIds[idx], lastWithdrawalEvent);
-        }
-    }
-
-    /// @inheritdoc IRedeemManagerV1
-    function requestRedeem(uint256 _lsETHAmount, address _recipient)
-        external
-        onlyRedeemerOrRiver
-        returns (uint32 redeemRequestId)
-    {
-        return _requestRedeem(_lsETHAmount, _recipient);
-    }
-
-    /// @inheritdoc IRedeemManagerV1
-    function requestRedeem(uint256 _lsETHAmount) external onlyRedeemer returns (uint32 redeemRequestId) {
-        return _requestRedeem(_lsETHAmount, msg.sender);
-    }
-
-    /// @inheritdoc IRedeemManagerV1
-    function claimRedeemRequests(
-        uint32[] calldata redeemRequestIds,
-        uint32[] calldata withdrawalEventIds,
-        bool skipAlreadyClaimed,
-        uint16 _depth
-    ) external returns (uint8[] memory claimStatuses) {
-        return _claimRedeemRequests(redeemRequestIds, withdrawalEventIds, skipAlreadyClaimed, _depth);
-    }
-
-    /// @inheritdoc IRedeemManagerV1
-    function claimRedeemRequests(uint32[] calldata _redeemRequestIds, uint32[] calldata _withdrawalEventIds)
-        external
-        returns (uint8[] memory claimStatuses)
-    {
-        return _claimRedeemRequests(_redeemRequestIds, _withdrawalEventIds, true, type(uint16).max);
-    }
-
-    /// @inheritdoc IRedeemManagerV1
-    function reportWithdraw(uint256 _lsETHWithdrawable) external payable onlyRiver {
-        uint256 redeemDemand = RedeemDemand.get();
-        if (_lsETHWithdrawable > redeemDemand) {
-            revert WithdrawalExceedsRedeemDemand(_lsETHWithdrawable, redeemDemand);
-        }
-        WithdrawalStack.WithdrawalEvent[] storage withdrawalEvents = WithdrawalStack.get();
-        uint32 withdrawalEventId = uint32(withdrawalEvents.length);
-        uint256 height = 0;
-        uint256 msgValue = msg.value;
-        if (withdrawalEventId != 0) {
-            WithdrawalStack.WithdrawalEvent memory previousWithdrawalEvent = withdrawalEvents[withdrawalEventId - 1];
-            height = previousWithdrawalEvent.height + previousWithdrawalEvent.amount;
-        }
-        withdrawalEvents.push(
-            WithdrawalStack.WithdrawalEvent({height: height, amount: _lsETHWithdrawable, withdrawnEth: msgValue})
-        );
-        _setRedeemDemand(redeemDemand - _lsETHWithdrawable);
-        emit ReportedWithdrawal(height, _lsETHWithdrawable, msgValue, withdrawalEventId);
-    }
-
-    /// @inheritdoc IRedeemManagerV1
-    function pullExceedingEth(uint256 _max) external onlyRiver {
-        uint256 amountToSend = LibUint256.min(BufferedExceedingEth.get(), _max);
-        if (amountToSend > 0) {
-            BufferedExceedingEth.set(BufferedExceedingEth.get() - amountToSend);
-            _castedRiver().sendRedeemManagerExceedingFunds{value: amountToSend}();
-        }
-    }
-
-    /// @notice Internal utility to load and cast the River address
-    /// @return The casted river address
-    function _castedRiver() internal view returns (IRiverV1) {
-        return IRiverV1(payable(RiverAddress.get()));
-    }
-
-    /// @notice Internal utility to verify if a redeem request and a withdrawal event are matching
-    /// @param _redeemRequest The loaded redeem request
-    /// @param _withdrawalEvent The load withdrawal event
-    /// @return True if matching
-    function _isMatch(
-        RedeemQueue.RedeemRequest memory _redeemRequest,
-        WithdrawalStack.WithdrawalEvent memory _withdrawalEvent
-    ) internal pure returns (bool) {
-        return (
-            _redeemRequest.height < _withdrawalEvent.height + _withdrawalEvent.amount
-                && _redeemRequest.height >= _withdrawalEvent.height
-        );
-    }
-
-    /// @notice Internal utility to perform a dichotomic search of the withdrawal event to use to claim the redeem request
-    /// @param _redeemRequest The redeem request to resolve
-    /// @return The matching withdrawal event
-    function _performDichotomicResolution(RedeemQueue.RedeemRequest memory _redeemRequest)
-        internal
-        view
-        returns (int64)
-    {
-        WithdrawalStack.WithdrawalEvent[] storage withdrawalEvents = WithdrawalStack.get();
-
-        int64 max = int64(int256(WithdrawalStack.get().length - 1));
-
-        if (_isMatch(_redeemRequest, withdrawalEvents[uint64(max)])) {
-            return max;
-        }
-
-        int64 min = 0;
-
-        if (_isMatch(_redeemRequest, withdrawalEvents[uint64(min)])) {
-            return min;
-        }
-
-        // we start a dichotomic search between min and max
-        while (min != max) {
-            int64 mid = (min + max) / 2;
-
-            // we identify and verify that the middle element is not matching
-            WithdrawalStack.WithdrawalEvent memory midWithdrawalEvent = withdrawalEvents[uint64(mid)];
-            if (_isMatch(_redeemRequest, midWithdrawalEvent)) {
-                return mid;
-            }
-
-            // depending on the position of the middle element, we update max or min to get our min max range
-            // closer to our redeem request position
-            if (_redeemRequest.height < midWithdrawalEvent.height) {
-                max = mid;
-            } else {
-                min = mid;
-            }
-        }
-        return min;
-    }
-
-    /// @notice Internal utility to resolve a redeem request and retrieve its satisfying withdrawal event id, or identify possible errors
-    /// @param _redeemRequestId The redeem request id
-    /// @param _lastWithdrawalEvent The last withdrawal event loaded in memory
-    /// @return withdrawalEventId The id of the withdrawal event matching the redeem request or error code
-    function _resolveRedeemRequestId(
-        uint32 _redeemRequestId,
-        WithdrawalStack.WithdrawalEvent memory _lastWithdrawalEvent
-    ) internal view returns (int64 withdrawalEventId) {
-        RedeemQueue.RedeemRequest[] storage redeemRequests = RedeemQueue.get();
-        // if the redeem request id is >= than the size of requests, we know it's out of bounds and doesn't exist
-        if (_redeemRequestId >= redeemRequests.length) {
-            return RESOLVE_OUT_OF_BOUNDS;
-        }
-        RedeemQueue.RedeemRequest memory redeemRequest = redeemRequests[_redeemRequestId];
-        // if the redeem request remaining amount is 0, we know that the request has been entirely claimed
-        if (redeemRequest.amount == 0) {
-            return RESOLVE_FULLY_CLAIMED;
-        }
-        // if there are no existing withdrawal events or if the height of the redeem request is higher than the height and
-        // amount of the last withdrawal element, we know that the redeem request is not yet satisfied
-        if (
-            WithdrawalStack.get().length == 0
-                || (_lastWithdrawalEvent.height + _lastWithdrawalEvent.amount) <= redeemRequest.height
-        ) {
-            return RESOLVE_UNSATISFIED;
-        }
-        // we know for sure that the redeem request has funds yet to be claimed and there is a withdrawal event we need to identify
-        // that would allow the user to claim the redeem request
-        return _performDichotomicResolution(redeemRequest);
-    }
-
-    /// @notice Perform a new redeem request for the specified recipient
-    /// @param _lsETHAmount The amount of LsETH to redeem
-    /// @param _recipient The recipient owning the request
-    /// @return redeemRequestId The id of the newly created redeem request
-    function _requestRedeem(uint256 _lsETHAmount, address _recipient) internal returns (uint32 redeemRequestId) {
-        LibSanitize._notZeroAddress(_recipient);
-        if (_lsETHAmount == 0) {
-            revert InvalidZeroAmount();
-        }
-        if (!_castedRiver().transferFrom(msg.sender, address(this), _lsETHAmount)) {
-            revert TransferError();
-        }
-        RedeemQueue.RedeemRequest[] storage redeemRequests = RedeemQueue.get();
-        redeemRequestId = uint32(redeemRequests.length);
-        uint256 height = 0;
-        if (redeemRequestId != 0) {
-            RedeemQueue.RedeemRequest memory previousRedeemRequest = redeemRequests[redeemRequestId - 1];
-            height = previousRedeemRequest.height + previousRedeemRequest.amount;
-        }
-
-        uint256 maxRedeemableEth = _castedRiver().underlyingBalanceFromShares(_lsETHAmount);
-
-        redeemRequests.push(
-            RedeemQueue.RedeemRequest({
-                height: height,
-                amount: _lsETHAmount,
-                owner: _recipient,
-                maxRedeemableEth: maxRedeemableEth
-            })
-        );
-
-        _setRedeemDemand(RedeemDemand.get() + _lsETHAmount);
-
-        emit RequestedRedeem(_recipient, height, _lsETHAmount, maxRedeemableEth, redeemRequestId);
-    }
-
-    /// @notice Internal structure used to optimize stack usage in _claimRedeemRequest
-    struct ClaimRedeemRequestParameters {
-        /// @custom:attribute The id of the redeem request to claim
-        uint32 redeemRequestId;
-        /// @custom:attribute The structure of the redeem request to claim
-        RedeemQueue.RedeemRequest redeemRequest;
-        /// @custom:attribute The id of the withdrawal event to use to claim the redeem request
-        uint32 withdrawalEventId;
-        /// @custom:attribute The structure of the withdrawal event to use to claim the redeem request
-        WithdrawalStack.WithdrawalEvent withdrawalEvent;
-        /// @custom:attribute The count of withdrawal events
-        uint32 withdrawalEventCount;
-        /// @custom:attribute The current depth of the recursive call
-        uint16 depth;
-        /// @custom:attribute The amount of LsETH redeemed/matched, needs to be reset to 0 for each call/before calling the recursive function
-        uint256 lsETHAmount;
-        /// @custom:attribute The amount of eth redeemed/matched, needs to be rest to 0 for each call/before calling the recursive function
-        uint256 ethAmount;
-    }
-
-    /// @notice Internal structure used to optimize stack usage in _claimRedeemRequest
-    struct ClaimRedeemRequestInternalVariables {
-        /// @custom:attribute The eth amount claimed by the user
-        uint256 ethAmount;
-        /// @custom:attribute The amount of LsETH matched during this step
-        uint256 matchingAmount;
-        /// @custom:attribute The amount of eth redirected to the exceeding eth buffer
-        uint256 exceedingEthAmount;
-    }
-
-    /// @notice Internal utility to save a redeem request to storage
-    /// @param _params The parameters of the claim redeem request call
-    function _saveRedeemRequest(ClaimRedeemRequestParameters memory _params) internal {
-        RedeemQueue.RedeemRequest[] storage redeemRequests = RedeemQueue.get();
-        redeemRequests[_params.redeemRequestId].height = _params.redeemRequest.height;
-        redeemRequests[_params.redeemRequestId].amount = _params.redeemRequest.amount;
-        redeemRequests[_params.redeemRequestId].maxRedeemableEth = _params.redeemRequest.maxRedeemableEth;
-    }
-
-    /// @notice Internal utility to claim a redeem request if possible
-    /// @dev Will call itself recursively if the redeem requests overflows its matching withdrawal event
-    /// @param _params The parameters of the claim redeem request call
-    function _claimRedeemRequest(ClaimRedeemRequestParameters memory _params) internal {
-        ClaimRedeemRequestInternalVariables memory vars;
-        {
-            uint256 withdrawalEventEndPosition = _params.withdrawalEvent.height + _params.withdrawalEvent.amount;
-
-            // it can occur that the redeem request is overlapping the provided withdrawal event
-            // the amount that is matched in the withdrawal event is adapted depending on this
-            vars.matchingAmount =
-                LibUint256.min(_params.redeemRequest.amount, withdrawalEventEndPosition - _params.redeemRequest.height);
-            // we can now compute the equivalent eth amount based on the withdrawal event details
-            vars.ethAmount =
-                (vars.matchingAmount * _params.withdrawalEvent.withdrawnEth) / _params.withdrawalEvent.amount;
-
-            // as each request has a maximum withdrawable amount, we verify that the eth amount is not exceeding this amount, pro rata
-            // the amount that is matched
-            uint256 maxRedeemableEthAmount =
-                (vars.matchingAmount * _params.redeemRequest.maxRedeemableEth) / _params.redeemRequest.amount;
-
-            if (maxRedeemableEthAmount < vars.ethAmount) {
-                vars.exceedingEthAmount = vars.ethAmount - maxRedeemableEthAmount;
-                BufferedExceedingEth.set(BufferedExceedingEth.get() + vars.exceedingEthAmount);
-                vars.ethAmount = maxRedeemableEthAmount;
-            }
-
-            // height and amount are updated to reflect the amount that was matched.
-            // we will always keep this invariant true oldRequest.height + oldRequest.amount == newRequest.height + newRequest.amount
-            // this also means that if the request wasn't entirely matched, it will now be automatically be assigned to the next
-            // withdrawal event in the queue, because height is updated based on the amount matched and is now equal to the height
-            // of the next withdrawal event
-            // the end position of a redeem request (height + amount) is an invariant that never changes throughout the lifetime of a request
-            // this end position is used to define the starting position of the next redeem request
-            _params.redeemRequest.height += vars.matchingAmount;
-            _params.redeemRequest.amount -= vars.matchingAmount;
-            _params.redeemRequest.maxRedeemableEth -= vars.ethAmount;
-
-            _params.lsETHAmount += vars.matchingAmount;
-            _params.ethAmount += vars.ethAmount;
-
-            // this event signals that an amount has been matched from a redeem request on a withdrawal event
-            // this event can be triggered several times for the same redeem request, depending on its size and
-            // how many withdrawal events it overlaps.
-            emit SatisfiedRedeemRequest(
-                _params.redeemRequestId,
-                _params.withdrawalEventId,
-                vars.matchingAmount,
-                vars.ethAmount,
-                _params.redeemRequest.amount,
-                vars.exceedingEthAmount
-            );
-        }
-
-        // in the case where we haven't claimed all the redeem request AND that there are other withdrawal events
-        // available next in the stack, we load the next withdrawal event and call this method recursively
-        // also we stop the claim process if the claim depth is about to be 0
-        if (
-            _params.redeemRequest.amount > 0 && _params.withdrawalEventId + 1 < _params.withdrawalEventCount
-                && _params.depth > 0
-        ) {
-            WithdrawalStack.WithdrawalEvent[] storage withdrawalEvents = WithdrawalStack.get();
-
-            ++_params.withdrawalEventId;
-            _params.withdrawalEvent = withdrawalEvents[_params.withdrawalEventId];
-            --_params.depth;
-
-            _claimRedeemRequest(_params);
-        } else {
-            // if we end up here, we either claimed everything or we reached the end of the withdrawal event stack
-            // in this case we save the current redeem request state to storage and return the status according to the
-            // remaining claimable amount on the redeem request
-            _saveRedeemRequest(_params);
-        }
-    }
-
-    /// @notice Internal utility to claim several redeem requests at once
-    /// @param _redeemRequestIds The list of redeem requests to claim
-    /// @param _withdrawalEventIds The list of withdrawal events to use for each redeem request. Should have the same length.
-    /// @param _skipAlreadyClaimed True if the system should skip redeem requests already claimed, otherwise will revert
-    /// @param _depth The depth of the recursion to use when claiming a redeem request
-    /// @return claimStatuses The claim statuses for each redeem request
-    function _claimRedeemRequests(
-        uint32[] calldata _redeemRequestIds,
-        uint32[] calldata _withdrawalEventIds,
-        bool _skipAlreadyClaimed,
-        uint16 _depth
-    ) internal returns (uint8[] memory claimStatuses) {
-        uint256 redeemRequestIdsLength = _redeemRequestIds.length;
-        if (redeemRequestIdsLength != _withdrawalEventIds.length) {
-            revert IncompatibleArrayLengths();
-        }
-        claimStatuses = new uint8[](redeemRequestIdsLength);
-
-        RedeemQueue.RedeemRequest[] storage redeemRequests = RedeemQueue.get();
-        WithdrawalStack.WithdrawalEvent[] storage withdrawalEvents = WithdrawalStack.get();
-
-        ClaimRedeemRequestParameters memory params;
-        params.withdrawalEventCount = uint32(withdrawalEvents.length);
-        uint32 redeemRequestCount = uint32(redeemRequests.length);
-
-        for (uint256 idx = 0; idx < redeemRequestIdsLength;) {
-            // both ids are loaded into params
-            params.redeemRequestId = _redeemRequestIds[idx];
-            params.withdrawalEventId = _withdrawalEventIds[idx];
-
-            // we start by checking that the id is not out of bounds for the redeem requests
-            if (params.redeemRequestId >= redeemRequestCount) {
-                revert RedeemRequestOutOfBounds(params.redeemRequestId);
-            }
-
-            // we check that the withdrawal event id is not out of bounds
-            if (params.withdrawalEventId >= params.withdrawalEventCount) {
-                revert WithdrawalEventOutOfBounds(params.withdrawalEventId);
-            }
-
-            // we load the redeem request in memory
-            params.redeemRequest = redeemRequests[_redeemRequestIds[idx]];
-
-            // we check that the redeem request is not already claimed
-            if (params.redeemRequest.amount == 0) {
-                if (_skipAlreadyClaimed) {
-                    claimStatuses[idx] = CLAIM_SKIPPED;
-                    unchecked {
-                        ++idx;
-                    }
-                    continue;
-                }
-                revert RedeemRequestAlreadyClaimed(params.redeemRequestId);
-            }
-
-            // we load the withdrawal event in memory
-            params.withdrawalEvent = withdrawalEvents[_withdrawalEventIds[idx]];
-
-            // now that both entities are loaded in memory, we verify that they indeed match, otherwise we revert
-            if (!_isMatch(params.redeemRequest, params.withdrawalEvent)) {
-                revert DoesNotMatch(params.redeemRequestId, params.withdrawalEventId);
-            }
-
-            params.depth = _depth;
-            params.ethAmount = 0;
-            params.lsETHAmount = 0;
-
-            _claimRedeemRequest(params);
-
-            claimStatuses[idx] = params.redeemRequest.amount == 0 ? CLAIM_FULLY_CLAIMED : CLAIM_PARTIALLY_CLAIMED;
-
-            {
-                (bool success, bytes memory rdata) = params.redeemRequest.owner.call{value: params.ethAmount}("");
-                if (!success) {
-                    revert ClaimRedeemFailed(params.redeemRequest.owner, rdata);
-                }
-            }
-            emit ClaimedRedeemRequest(
-                _redeemRequestIds[idx],
-                params.redeemRequest.owner,
-                params.ethAmount,
-                params.lsETHAmount,
-                params.redeemRequest.amount
-            );
-
-            unchecked {
-                ++idx;
-            }
-        }
-    }
-
-    /// @notice Internal utility to set the redeem demand
-    /// @param _newValue The new value to set
-    function _setRedeemDemand(uint256 _newValue) internal {
-        emit SetRedeemDemand(RedeemDemand.get(), _newValue);
-        RedeemDemand.set(_newValue);
-    }
-}
diff -ruN src/River.1.sol River.1.sol
--- src/River.1.sol	2024-01-16 15:03:11
+++ River.1.sol	2024-01-16 15:06:39
@@ -1,606 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "./interfaces/IAllowlist.1.sol";
-import "./interfaces/IOperatorRegistry.1.sol";
-import "./interfaces/IRiver.1.sol";
-import "./interfaces/IWithdraw.1.sol";
-import "./interfaces/IELFeeRecipient.1.sol";
-import "./interfaces/ICoverageFund.1.sol";
-
-import "./components/ConsensusLayerDepositManager.1.sol";
-import "./components/UserDepositManager.1.sol";
-import "./components/SharesManager.1.sol";
-import "./components/OracleManager.1.sol";
-import "./Initializable.sol";
-import "./Administrable.sol";
-
-import "./libraries/LibAllowlistMasks.sol";
-
-import "./state/river/AllowlistAddress.sol";
-import "./state/river/RedeemManagerAddress.sol";
-import "./state/river/OperatorsRegistryAddress.sol";
-import "./state/river/CollectorAddress.sol";
-import "./state/river/ELFeeRecipientAddress.sol";
-import "./state/river/CoverageFundAddress.sol";
-import "./state/river/BalanceToRedeem.sol";
-import "./state/river/GlobalFee.sol";
-import "./state/river/MetadataURI.sol";
-import "./state/river/LastConsensusLayerReport.sol";
-
-/// @title River (v1)
-/// @author Kiln
-/// @notice This contract merges all the manager contracts and implements all the virtual methods stitching all components together
-contract RiverV1 is
-    ConsensusLayerDepositManagerV1,
-    UserDepositManagerV1,
-    SharesManagerV1,
-    OracleManagerV1,
-    Initializable,
-    Administrable,
-    IRiverV1
-{
-    /// @inheritdoc IRiverV1
-    function initRiverV1(
-        address _depositContractAddress,
-        address _elFeeRecipientAddress,
-        bytes32 _withdrawalCredentials,
-        address _oracleAddress,
-        address _systemAdministratorAddress,
-        address _allowlistAddress,
-        address _operatorRegistryAddress,
-        address _collectorAddress,
-        uint256 _globalFee
-    ) external init(0) {
-        _setAdmin(_systemAdministratorAddress);
-
-        CollectorAddress.set(_collectorAddress);
-        emit SetCollector(_collectorAddress);
-
-        GlobalFee.set(_globalFee);
-        emit SetGlobalFee(_globalFee);
-
-        ELFeeRecipientAddress.set(_elFeeRecipientAddress);
-        emit SetELFeeRecipient(_elFeeRecipientAddress);
-
-        AllowlistAddress.set(_allowlistAddress);
-        emit SetAllowlist(_allowlistAddress);
-
-        OperatorsRegistryAddress.set(_operatorRegistryAddress);
-        emit SetOperatorsRegistry(_operatorRegistryAddress);
-
-        ConsensusLayerDepositManagerV1.initConsensusLayerDepositManagerV1(
-            _depositContractAddress, _withdrawalCredentials
-        );
-
-        OracleManagerV1.initOracleManagerV1(_oracleAddress);
-    }
-
-    /// @inheritdoc IRiverV1
-    function initRiverV1_1(
-        address _redeemManager,
-        uint64 _epochsPerFrame,
-        uint64 _slotsPerEpoch,
-        uint64 _secondsPerSlot,
-        uint64 _genesisTime,
-        uint64 _epochsToAssumedFinality,
-        uint256 _annualAprUpperBound,
-        uint256 _relativeLowerBound,
-        uint128 _minDailyNetCommittableAmount_,
-        uint128 _maxDailyRelativeCommittableAmount_
-    ) external init(1) {
-        RedeemManagerAddress.set(_redeemManager);
-        emit SetRedeemManager(_redeemManager);
-
-        _setDailyCommittableLimits(
-            DailyCommittableLimits.DailyCommittableLimitsStruct({
-                minDailyNetCommittableAmount: _minDailyNetCommittableAmount_,
-                maxDailyRelativeCommittableAmount: _maxDailyRelativeCommittableAmount_
-            })
-        );
-
-        initOracleManagerV1_1(
-            _epochsPerFrame,
-            _slotsPerEpoch,
-            _secondsPerSlot,
-            _genesisTime,
-            _epochsToAssumedFinality,
-            _annualAprUpperBound,
-            _relativeLowerBound
-        );
-
-        _approve(address(this), _redeemManager, type(uint256).max);
-    }
-
-    /// @inheritdoc IRiverV1
-    function initRiverV1_2() external init(2) {
-        // force committed balance to a multiple of 32 ETH and
-        // move extra funds back to the deposit buffer
-        uint256 dustToUncommit = CommittedBalance.get() % DEPOSIT_SIZE;
-        _setCommittedBalance(CommittedBalance.get() - dustToUncommit);
-        _setBalanceToDeposit(BalanceToDeposit.get() + dustToUncommit);
-    }
-
-    /// @inheritdoc IRiverV1
-    function getGlobalFee() external view returns (uint256) {
-        return GlobalFee.get();
-    }
-
-    /// @inheritdoc IRiverV1
-    function getAllowlist() external view returns (address) {
-        return AllowlistAddress.get();
-    }
-
-    /// @inheritdoc IRiverV1
-    function getCollector() external view returns (address) {
-        return CollectorAddress.get();
-    }
-
-    /// @inheritdoc IRiverV1
-    function getELFeeRecipient() external view returns (address) {
-        return ELFeeRecipientAddress.get();
-    }
-
-    /// @inheritdoc IRiverV1
-    function getCoverageFund() external view returns (address) {
-        return CoverageFundAddress.get();
-    }
-
-    /// @inheritdoc IRiverV1
-    function getRedeemManager() external view returns (address) {
-        return RedeemManagerAddress.get();
-    }
-
-    /// @inheritdoc IRiverV1
-    function getMetadataURI() external view returns (string memory) {
-        return MetadataURI.get();
-    }
-
-    /// @inheritdoc IRiverV1
-    function getDailyCommittableLimits()
-        external
-        view
-        returns (DailyCommittableLimits.DailyCommittableLimitsStruct memory)
-    {
-        return DailyCommittableLimits.get();
-    }
-
-    /// @inheritdoc IRiverV1
-    function setDailyCommittableLimits(DailyCommittableLimits.DailyCommittableLimitsStruct memory _dcl)
-        external
-        onlyAdmin
-    {
-        _setDailyCommittableLimits(_dcl);
-    }
-
-    /// @inheritdoc IRiverV1
-    function getBalanceToRedeem() external view returns (uint256) {
-        return BalanceToRedeem.get();
-    }
-
-    /// @inheritdoc IRiverV1
-    function resolveRedeemRequests(uint32[] calldata _redeemRequestIds)
-        external
-        view
-        returns (int64[] memory withdrawalEventIds)
-    {
-        return IRedeemManagerV1(RedeemManagerAddress.get()).resolveRedeemRequests(_redeemRequestIds);
-    }
-
-    /// @inheritdoc IRiverV1
-    function requestRedeem(uint256 _lsETHAmount, address _recipient) external returns (uint32 _redeemRequestId) {
-        IAllowlistV1(AllowlistAddress.get()).onlyAllowed(msg.sender, LibAllowlistMasks.REDEEM_MASK);
-        _transfer(msg.sender, address(this), _lsETHAmount);
-        return IRedeemManagerV1(RedeemManagerAddress.get()).requestRedeem(_lsETHAmount, _recipient);
-    }
-
-    /// @inheritdoc IRiverV1
-    function claimRedeemRequests(uint32[] calldata _redeemRequestIds, uint32[] calldata _withdrawalEventIds)
-        external
-        returns (uint8[] memory claimStatuses)
-    {
-        return IRedeemManagerV1(RedeemManagerAddress.get()).claimRedeemRequests(
-            _redeemRequestIds, _withdrawalEventIds, true, type(uint16).max
-        );
-    }
-
-    /// @inheritdoc IRiverV1
-    function setGlobalFee(uint256 _newFee) external onlyAdmin {
-        GlobalFee.set(_newFee);
-        emit SetGlobalFee(_newFee);
-    }
-
-    /// @inheritdoc IRiverV1
-    function setAllowlist(address _newAllowlist) external onlyAdmin {
-        AllowlistAddress.set(_newAllowlist);
-        emit SetAllowlist(_newAllowlist);
-    }
-
-    /// @inheritdoc IRiverV1
-    function setCollector(address _newCollector) external onlyAdmin {
-        CollectorAddress.set(_newCollector);
-        emit SetCollector(_newCollector);
-    }
-
-    /// @inheritdoc IRiverV1
-    function setELFeeRecipient(address _newELFeeRecipient) external onlyAdmin {
-        ELFeeRecipientAddress.set(_newELFeeRecipient);
-        emit SetELFeeRecipient(_newELFeeRecipient);
-    }
-
-    /// @inheritdoc IRiverV1
-    function setCoverageFund(address _newCoverageFund) external onlyAdmin {
-        CoverageFundAddress.set(_newCoverageFund);
-        emit SetCoverageFund(_newCoverageFund);
-    }
-
-    /// @inheritdoc IRiverV1
-    function setMetadataURI(string memory _metadataURI) external onlyAdmin {
-        LibSanitize._notEmptyString(_metadataURI);
-        MetadataURI.set(_metadataURI);
-        emit SetMetadataURI(_metadataURI);
-    }
-
-    /// @inheritdoc IRiverV1
-    function getOperatorsRegistry() external view returns (address) {
-        return OperatorsRegistryAddress.get();
-    }
-
-    /// @inheritdoc IRiverV1
-    function sendELFees() external payable {
-        if (msg.sender != ELFeeRecipientAddress.get()) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-    }
-
-    /// @inheritdoc IRiverV1
-    function sendCLFunds() external payable {
-        if (msg.sender != WithdrawalCredentials.getAddress()) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-    }
-
-    /// @inheritdoc IRiverV1
-    function sendCoverageFunds() external payable {
-        if (msg.sender != CoverageFundAddress.get()) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-    }
-
-    /// @inheritdoc IRiverV1
-    function sendRedeemManagerExceedingFunds() external payable {
-        if (msg.sender != RedeemManagerAddress.get()) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-    }
-
-    /// @notice Overridden handler to pass the system admin inside components
-    /// @return The address of the admin
-    function _getRiverAdmin()
-        internal
-        view
-        override(OracleManagerV1, ConsensusLayerDepositManagerV1)
-        returns (address)
-    {
-        return Administrable._getAdmin();
-    }
-
-    /// @notice Overridden handler called whenever a token transfer is triggered
-    /// @param _from Token sender
-    /// @param _to Token receiver
-    function _onTransfer(address _from, address _to) internal view override {
-        IAllowlistV1 allowlist = IAllowlistV1(AllowlistAddress.get());
-        if (allowlist.isDenied(_from)) {
-            revert Denied(_from);
-        }
-        if (allowlist.isDenied(_to)) {
-            revert Denied(_to);
-        }
-    }
-
-    /// @notice Overridden handler called whenever a user deposits ETH to the system. Mints the adequate amount of shares.
-    /// @param _depositor User address that made the deposit
-    /// @param _amount Amount of ETH deposited
-    function _onDeposit(address _depositor, address _recipient, uint256 _amount) internal override {
-        uint256 mintedShares = SharesManagerV1._mintShares(_depositor, _amount);
-        IAllowlistV1 allowlist = IAllowlistV1(AllowlistAddress.get());
-        if (_depositor == _recipient) {
-            allowlist.onlyAllowed(_depositor, LibAllowlistMasks.DEPOSIT_MASK); // this call reverts if unauthorized or denied
-        } else {
-            allowlist.onlyAllowed(_depositor, LibAllowlistMasks.DEPOSIT_MASK); // this call reverts if unauthorized or denied
-            if (allowlist.isDenied(_recipient)) {
-                revert Denied(_recipient);
-            }
-            _transfer(_depositor, _recipient, mintedShares);
-        }
-    }
-
-    /// @notice Overridden handler called whenever a deposit to the consensus layer is made. Should retrieve _requestedAmount or lower keys
-    /// @param _requestedAmount Amount of keys required. Contract is expected to send _requestedAmount or lower.
-    /// @return publicKeys Array of fundable public keys
-    /// @return signatures Array of signatures linked to the public keys
-    function _getNextValidators(uint256 _requestedAmount)
-        internal
-        override
-        returns (bytes[] memory publicKeys, bytes[] memory signatures)
-    {
-        return IOperatorsRegistryV1(OperatorsRegistryAddress.get()).pickNextValidatorsToDeposit(_requestedAmount);
-    }
-
-    /// @notice Overridden handler to pull funds from the execution layer fee recipient to River and return the delta in the balance
-    /// @param _max The maximum amount to pull from the execution layer fee recipient
-    /// @return The amount pulled from the execution layer fee recipient
-    function _pullELFees(uint256 _max) internal override returns (uint256) {
-        address elFeeRecipient = ELFeeRecipientAddress.get();
-        uint256 initialBalance = address(this).balance;
-        IELFeeRecipientV1(payable(elFeeRecipient)).pullELFees(_max);
-        uint256 collectedELFees = address(this).balance - initialBalance;
-        if (collectedELFees > 0) {
-            _setBalanceToDeposit(BalanceToDeposit.get() + collectedELFees);
-        }
-        emit PulledELFees(collectedELFees);
-        return collectedELFees;
-    }
-
-    /// @notice Overridden handler to pull funds from the coverage fund to River and return the delta in the balance
-    /// @param _max The maximum amount to pull from the coverage fund
-    /// @return The amount pulled from the coverage fund
-    function _pullCoverageFunds(uint256 _max) internal override returns (uint256) {
-        address coverageFund = CoverageFundAddress.get();
-        if (coverageFund == address(0)) {
-            return 0;
-        }
-        uint256 initialBalance = address(this).balance;
-        ICoverageFundV1(payable(coverageFund)).pullCoverageFunds(_max);
-        uint256 collectedCoverageFunds = address(this).balance - initialBalance;
-        if (collectedCoverageFunds > 0) {
-            _setBalanceToDeposit(BalanceToDeposit.get() + collectedCoverageFunds);
-        }
-        emit PulledCoverageFunds(collectedCoverageFunds);
-        return collectedCoverageFunds;
-    }
-
-    /// @notice Overridden handler called whenever the balance of ETH handled by the system increases. Computes the fees paid to the collector
-    /// @param _amount Additional ETH received
-    function _onEarnings(uint256 _amount) internal override {
-        uint256 oldTotalSupply = _totalSupply();
-        if (oldTotalSupply == 0) {
-            revert ZeroMintedShares();
-        }
-        uint256 newTotalBalance = _assetBalance();
-        uint256 globalFee = GlobalFee.get();
-        uint256 numerator = _amount * oldTotalSupply * globalFee;
-        uint256 denominator = (newTotalBalance * LibBasisPoints.BASIS_POINTS_MAX) - (_amount * globalFee);
-        uint256 sharesToMint = denominator == 0 ? 0 : (numerator / denominator);
-
-        if (sharesToMint > 0) {
-            address collector = CollectorAddress.get();
-            _mintRawShares(collector, sharesToMint);
-            uint256 newTotalSupply = _totalSupply();
-            uint256 oldTotalBalance = newTotalBalance - _amount;
-            emit RewardsEarned(collector, oldTotalBalance, oldTotalSupply, newTotalBalance, newTotalSupply);
-        }
-    }
-
-    /// @notice Overridden handler called whenever the total balance of ETH is requested
-    /// @return The current total asset balance managed by River
-    function _assetBalance() internal view override(SharesManagerV1, OracleManagerV1) returns (uint256) {
-        IOracleManagerV1.StoredConsensusLayerReport storage storedReport = LastConsensusLayerReport.get();
-        uint256 clValidatorCount = storedReport.validatorsCount;
-        uint256 depositedValidatorCount = DepositedValidatorCount.get();
-        if (clValidatorCount < depositedValidatorCount) {
-            return storedReport.validatorsBalance + BalanceToDeposit.get() + CommittedBalance.get()
-                + BalanceToRedeem.get()
-                + (depositedValidatorCount - clValidatorCount) * ConsensusLayerDepositManagerV1.DEPOSIT_SIZE;
-        } else {
-            return
-                storedReport.validatorsBalance + BalanceToDeposit.get() + CommittedBalance.get() + BalanceToRedeem.get();
-        }
-    }
-
-    /// @notice Internal utility to set the daily committable limits
-    /// @param _dcl The new daily committable limits
-    function _setDailyCommittableLimits(DailyCommittableLimits.DailyCommittableLimitsStruct memory _dcl) internal {
-        DailyCommittableLimits.set(_dcl);
-        emit SetMaxDailyCommittableAmounts(_dcl.minDailyNetCommittableAmount, _dcl.maxDailyRelativeCommittableAmount);
-    }
-
-    /// @notice Sets the balance to deposit, but not yet committed
-    /// @param _newBalanceToDeposit The new balance to deposit value
-    function _setBalanceToDeposit(uint256 _newBalanceToDeposit) internal override(UserDepositManagerV1) {
-        emit SetBalanceToDeposit(BalanceToDeposit.get(), _newBalanceToDeposit);
-        BalanceToDeposit.set(_newBalanceToDeposit);
-    }
-
-    /// @notice Sets the balance to redeem, to be used to satisfy redeem requests on the redeem manager
-    /// @param _newBalanceToRedeem The new balance to redeem value
-    function _setBalanceToRedeem(uint256 _newBalanceToRedeem) internal {
-        emit SetBalanceToRedeem(BalanceToRedeem.get(), _newBalanceToRedeem);
-        BalanceToRedeem.set(_newBalanceToRedeem);
-    }
-
-    /// @notice Sets the committed balance, ready to be deposited to the consensus layer
-    /// @param _newCommittedBalance The new committed balance value
-    function _setCommittedBalance(uint256 _newCommittedBalance) internal override(ConsensusLayerDepositManagerV1) {
-        emit SetBalanceCommittedToDeposit(CommittedBalance.get(), _newCommittedBalance);
-        CommittedBalance.set(_newCommittedBalance);
-    }
-
-    /// @notice Pulls funds from the Withdraw contract, and adds funds to deposit and redeem balances
-    /// @param _skimmedEthAmount The new amount of skimmed eth to pull
-    /// @param _exitedEthAmount The new amount of exited eth to pull
-    function _pullCLFunds(uint256 _skimmedEthAmount, uint256 _exitedEthAmount) internal override {
-        uint256 currentBalance = address(this).balance;
-        uint256 totalAmountToPull = _skimmedEthAmount + _exitedEthAmount;
-        IWithdrawV1(WithdrawalCredentials.getAddress()).pullEth(totalAmountToPull);
-        uint256 collectedCLFunds = address(this).balance - currentBalance;
-        if (collectedCLFunds != _skimmedEthAmount + _exitedEthAmount) {
-            revert InvalidPulledClFundsAmount(_skimmedEthAmount + _exitedEthAmount, collectedCLFunds);
-        }
-        if (_skimmedEthAmount > 0) {
-            _setBalanceToDeposit(BalanceToDeposit.get() + _skimmedEthAmount);
-        }
-        if (_exitedEthAmount > 0) {
-            _setBalanceToRedeem(BalanceToRedeem.get() + _exitedEthAmount);
-        }
-        emit PulledCLFunds(_skimmedEthAmount, _exitedEthAmount);
-    }
-
-    /// @notice Pulls funds from the redeem manager exceeding eth buffer
-    /// @param _max The maximum amount to pull
-    function _pullRedeemManagerExceedingEth(uint256 _max) internal override returns (uint256) {
-        uint256 currentBalance = address(this).balance;
-        IRedeemManagerV1(RedeemManagerAddress.get()).pullExceedingEth(_max);
-        uint256 collectedExceedingEth = address(this).balance - currentBalance;
-        if (collectedExceedingEth > 0) {
-            _setBalanceToDeposit(BalanceToDeposit.get() + collectedExceedingEth);
-        }
-        emit PulledRedeemManagerExceedingEth(collectedExceedingEth);
-        return collectedExceedingEth;
-    }
-
-    /// @notice Use the balance to redeem to report a withdrawal event on the redeem manager
-    function _reportWithdrawToRedeemManager() internal override {
-        IRedeemManagerV1 redeemManager_ = IRedeemManagerV1(RedeemManagerAddress.get());
-        uint256 underlyingAssetBalance = _assetBalance();
-        uint256 totalSupply = _totalSupply();
-
-        if (underlyingAssetBalance > 0 && totalSupply > 0) {
-            // we compute the redeem manager demands in eth and lsEth based on current conversion rate
-            uint256 redeemManagerDemand = redeemManager_.getRedeemDemand();
-            uint256 suppliedRedeemManagerDemand = redeemManagerDemand;
-            uint256 suppliedRedeemManagerDemandInEth = _balanceFromShares(suppliedRedeemManagerDemand);
-            uint256 availableBalanceToRedeem = BalanceToRedeem.get();
-
-            // if demand is higher than available eth, we update demand values to use the available eth
-            if (suppliedRedeemManagerDemandInEth > availableBalanceToRedeem) {
-                suppliedRedeemManagerDemandInEth = availableBalanceToRedeem;
-                suppliedRedeemManagerDemand = _sharesFromBalance(suppliedRedeemManagerDemandInEth);
-            }
-
-            emit ReportedRedeemManager(
-                redeemManagerDemand, suppliedRedeemManagerDemand, suppliedRedeemManagerDemandInEth
-            );
-
-            if (suppliedRedeemManagerDemandInEth > 0) {
-                // the available balance to redeem is updated
-                _setBalanceToRedeem(availableBalanceToRedeem - suppliedRedeemManagerDemandInEth);
-
-                // we burn the shares of the redeem manager associated with the amount of eth provided
-                _burnRawShares(address(redeemManager_), suppliedRedeemManagerDemand);
-
-                // perform a report withdraw call to the redeem manager
-                redeemManager_.reportWithdraw{value: suppliedRedeemManagerDemandInEth}(suppliedRedeemManagerDemand);
-            }
-        }
-    }
-
-    /// @notice Requests exits of validators after possibly rebalancing deposit and redeem balances
-    /// @param _exitingBalance The currently exiting funds, soon to be received on the execution layer
-    /// @param _depositToRedeemRebalancingAllowed True if rebalancing from deposit to redeem is allowed
-    function _requestExitsBasedOnRedeemDemandAfterRebalancings(
-        uint256 _exitingBalance,
-        uint32[] memory _stoppedValidatorCounts,
-        bool _depositToRedeemRebalancingAllowed,
-        bool _slashingContainmentModeEnabled
-    ) internal override {
-        IOperatorsRegistryV1(OperatorsRegistryAddress.get()).reportStoppedValidatorCounts(
-            _stoppedValidatorCounts, DepositedValidatorCount.get()
-        );
-
-        if (_slashingContainmentModeEnabled) {
-            return;
-        }
-
-        uint256 totalSupply = _totalSupply();
-        if (totalSupply > 0) {
-            uint256 availableBalanceToRedeem = BalanceToRedeem.get();
-            uint256 availableBalanceToDeposit = BalanceToDeposit.get();
-            uint256 redeemManagerDemandInEth =
-                _balanceFromShares(IRedeemManagerV1(RedeemManagerAddress.get()).getRedeemDemand());
-
-            // if after all rebalancings, the redeem manager demand is still higher than the balance to redeem and exiting eth, we compute
-            // the amount of validators to exit in order to cover the remaining demand
-            if (availableBalanceToRedeem + _exitingBalance < redeemManagerDemandInEth) {
-                // if reblancing is enabled and the redeem manager demand is higher than exiting eth, we add eth for deposit buffer to redeem buffer
-                if (_depositToRedeemRebalancingAllowed && availableBalanceToDeposit > 0) {
-                    uint256 rebalancingAmount = LibUint256.min(
-                        availableBalanceToDeposit, redeemManagerDemandInEth - _exitingBalance - availableBalanceToRedeem
-                    );
-                    if (rebalancingAmount > 0) {
-                        availableBalanceToRedeem += rebalancingAmount;
-                        _setBalanceToRedeem(availableBalanceToRedeem);
-                        _setBalanceToDeposit(availableBalanceToDeposit - rebalancingAmount);
-                    }
-                }
-
-                IOperatorsRegistryV1 or = IOperatorsRegistryV1(OperatorsRegistryAddress.get());
-
-                (uint256 totalStoppedValidatorCount, uint256 totalRequestedExitsCount) =
-                    or.getStoppedAndRequestedExitCounts();
-
-                // what we are calling pre-exiting balance is the amount of eth that should soon enter the exiting balance
-                // because exit requests have been made and operators might have a lag to process them
-                // we take them into account to not exit too many validators
-                uint256 preExitingBalance = (
-                    totalRequestedExitsCount > totalStoppedValidatorCount
-                        ? (totalRequestedExitsCount - totalStoppedValidatorCount)
-                        : 0
-                ) * DEPOSIT_SIZE;
-
-                if (availableBalanceToRedeem + _exitingBalance + preExitingBalance < redeemManagerDemandInEth) {
-                    uint256 validatorCountToExit = LibUint256.ceil(
-                        redeemManagerDemandInEth - (availableBalanceToRedeem + _exitingBalance + preExitingBalance),
-                        DEPOSIT_SIZE
-                    );
-
-                    or.demandValidatorExits(validatorCountToExit, DepositedValidatorCount.get());
-                }
-            }
-        }
-    }
-
-    /// @notice Skims the redeem balance and sends remaining funds to the deposit balance
-    function _skimExcessBalanceToRedeem() internal override {
-        uint256 availableBalanceToRedeem = BalanceToRedeem.get();
-
-        // if the available balance to redeem is not 0, it means that all the redeem requests are fulfilled, we should redirect funds for deposits
-        if (availableBalanceToRedeem > 0) {
-            _setBalanceToDeposit(BalanceToDeposit.get() + availableBalanceToRedeem);
-            _setBalanceToRedeem(0);
-        }
-    }
-
-    /// @notice Commits the deposit balance up to the allowed daily limit in batches of 32 ETH.
-    /// @notice Committed funds are funds waiting to be deposited but that cannot be used to fund the redeem manager anymore
-    /// @notice This two step process is required to prevent possible out of gas issues we would have from actually funding the validators at this point
-    /// @param _period The period between current and last report
-    function _commitBalanceToDeposit(uint256 _period) internal override {
-        uint256 underlyingAssetBalance = _assetBalance();
-        uint256 currentBalanceToDeposit = BalanceToDeposit.get();
-        DailyCommittableLimits.DailyCommittableLimitsStruct memory dcl = DailyCommittableLimits.get();
-
-        // we compute the max daily committable amount by taking the asset balance without the balance to deposit into account
-        // this value is the daily maximum amount we can commit for deposits
-        // we take the maximum value between a net amount and an amount relative to the asset balance
-        // this ensures that the amount we can commit is not too low in the beginning and that it is not too high when volumes grow
-        // the relative amount is computed from the committed and activated funds (on the CL or committed to be on the CL soon) and not
-        // the deposit balance
-        // this value is computed by subtracting the current balance to deposit from the underlying asset balance
-        uint256 currentMaxDailyCommittableAmount = LibUint256.max(
-            dcl.minDailyNetCommittableAmount,
-            (uint256(dcl.maxDailyRelativeCommittableAmount) * (underlyingAssetBalance - currentBalanceToDeposit))
-                / LibBasisPoints.BASIS_POINTS_MAX
-        );
-        // we adapt the value for the reporting period by using the asset balance as upper bound
-        uint256 currentMaxCommittableAmount =
-            LibUint256.min((currentMaxDailyCommittableAmount * _period) / 1 days, currentBalanceToDeposit);
-        // we only commit multiples of 32 ETH
-        currentMaxCommittableAmount = (currentMaxCommittableAmount / DEPOSIT_SIZE) * DEPOSIT_SIZE;
-
-        if (currentMaxCommittableAmount > 0) {
-            _setCommittedBalance(CommittedBalance.get() + currentMaxCommittableAmount);
-            _setBalanceToDeposit(currentBalanceToDeposit - currentMaxCommittableAmount);
-        }
-    }
-}
diff -ruN src/TLC.1.sol TLC.1.sol
--- src/TLC.1.sol	2023-12-11 15:38:07
+++ TLC.1.sol	2024-01-16 15:06:39
@@ -1,38 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "./components/ERC20VestableVotesUpgradeable.1.sol";
-import "./interfaces/ITLC.1.sol";
-
-/// @title TLC (v1)
-/// @author Alluvial
-/// @notice The TLC token has a max supply of 1,000,000,000 and 18 decimal places.
-/// @notice Upon deployment, all minted tokens are send to account provided at construction, in charge of creating the vesting schedules
-/// @notice The contract is based on ERC20Votes by OpenZeppelin. Users need to delegate their voting power to someone or themselves to be able to vote.
-/// @notice The contract contains vesting logics allowing vested users to still be able to delegate their voting power while their tokens are held in an escrow
-contract TLCV1 is ITLCV1, ERC20VestableVotesUpgradeableV1 {
-    // Token information
-    string internal constant NAME = "Liquid Collective";
-    string internal constant SYMBOL = "TLC";
-
-    // Initial supply of token minted
-    uint256 internal constant INITIAL_SUPPLY = 1_000_000_000e18; // 1 billion TLC
-
-    /// @notice Disables implementation initialization
-    constructor() {
-        _disableInitializers();
-    }
-
-    /// @inheritdoc ITLCV1
-    function initTLCV1(address _account) external initializer {
-        LibSanitize._notZeroAddress(_account);
-        __ERC20Permit_init(NAME);
-        __ERC20_init(NAME, SYMBOL);
-        _mint(_account, INITIAL_SUPPLY);
-    }
-
-    /// @inheritdoc ITLCV1
-    function migrateVestingSchedules() external reinitializer(2) {
-        ERC20VestableVotesUpgradeableV1.migrateVestingSchedulesFromV1ToV2();
-    }
-}
diff -ruN src/TUPProxy.sol TUPProxy.sol
--- src/TUPProxy.sol	2023-12-11 15:38:07
+++ TUPProxy.sol	2024-01-16 15:06:39
@@ -1,68 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "openzeppelin-contracts/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";
-
-/// @title TUPProxy (Transparent Upgradeable Pausable Proxy)
-/// @author Kiln
-/// @notice This contract extends the Transparent Upgradeable proxy and adds a system wide pause feature.
-///         When the system is paused, the fallback will fail no matter what calls are made.
-///         Address Zero is allowed to perform calls even if paused to allow view calls made
-///         from RPC providers to properly work.
-contract TUPProxy is TransparentUpgradeableProxy {
-    /// @notice Storage slot of the pause status value
-    bytes32 private constant _PAUSE_SLOT = bytes32(uint256(keccak256("river.tupproxy.pause")) - 1);
-
-    /// @notice A call happened while the system was paused
-    error CallWhenPaused();
-
-    /// @notice The system is now paused
-    /// @param admin The admin at the time of the pause event
-    event Paused(address admin);
-
-    /// @notice The system is now unpaused
-    /// @param admin The admin at the time of the unpause event
-    event Unpaused(address admin);
-
-    /// @dev The Admin of the proxy should not be the same as the
-    /// @dev admin on the implementation logics. The admin here is
-    /// @dev the only account allowed to perform calls on the proxy
-    /// @dev (the calls are never delegated to the implementation)
-    /// @param _logic Address of the implementation
-    /// @param __admin Address of the admin in charge of the proxy
-    /// @param _data Calldata for an atomic initialization
-    constructor(address _logic, address __admin, bytes memory _data)
-        payable
-        TransparentUpgradeableProxy(_logic, __admin, _data)
-    {}
-
-    /// @dev Retrieves Paused state
-    /// @return Paused state
-    function paused() external ifAdmin returns (bool) {
-        return StorageSlot.getBooleanSlot(_PAUSE_SLOT).value;
-    }
-
-    /// @dev Pauses system
-    function pause() external ifAdmin {
-        StorageSlot.getBooleanSlot(_PAUSE_SLOT).value = true;
-        emit Paused(msg.sender);
-    }
-
-    /// @dev Unpauses system
-    function unpause() external ifAdmin {
-        StorageSlot.getBooleanSlot(_PAUSE_SLOT).value = false;
-        emit Unpaused(msg.sender);
-    }
-
-    /// @dev Overrides the fallback method to check if system is not paused before
-    /// @dev Address Zero is allowed to perform calls even if system is paused. This allows
-    /// view functions to be called when the system is paused as rpc providers can easily
-    /// set the sender address to zero.
-    function _beforeFallback() internal override {
-        if (!StorageSlot.getBooleanSlot(_PAUSE_SLOT).value || msg.sender == address(0)) {
-            super._beforeFallback();
-        } else {
-            revert CallWhenPaused();
-        }
-    }
-}
diff -ruN src/WLSETH.1.sol WLSETH.1.sol
--- src/WLSETH.1.sol	2023-12-11 15:38:07
+++ WLSETH.1.sol	2024-01-16 15:06:39
@@ -1,196 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "openzeppelin-contracts/contracts/security/ReentrancyGuard.sol";
-
-import "./interfaces/IRiver.1.sol";
-import "./interfaces/IWLSETH.1.sol";
-
-import "./Initializable.sol";
-
-import "./state/shared/RiverAddress.sol";
-import "./state/shared/ApprovalsPerOwner.sol";
-import "./state/wlseth/BalanceOf.sol";
-
-/// @title Wrapped LsETH (v1)
-/// @author Kiln
-/// @notice This contract wraps the LsETH token into a rebase token, more suitable for some DeFi use-cases
-///         like stable swaps.
-contract WLSETHV1 is IWLSETHV1, Initializable, ReentrancyGuard {
-    /// @notice Ensures that the value is not 0
-    /// @param _value Value that must be > 0
-    modifier isNotNull(uint256 _value) {
-        if (_value == 0) {
-            revert NullTransfer();
-        }
-        _;
-    }
-
-    /// @notice Ensures that the owner has enough funds
-    /// @param _owner Owner of the balance to verify
-    /// @param _value Minimum required value
-    modifier hasFunds(address _owner, uint256 _value) {
-        if (_balanceOf(_owner) < _value) {
-            revert BalanceTooLow();
-        }
-        _;
-    }
-
-    /// @inheritdoc IWLSETHV1
-    function initWLSETHV1(address _river) external init(0) {
-        RiverAddress.set(_river);
-        emit SetRiver(_river);
-    }
-
-    /// @inheritdoc IWLSETHV1
-    function name() external pure returns (string memory) {
-        return "Wrapped Liquid Staked ETH";
-    }
-
-    /// @inheritdoc IWLSETHV1
-    function symbol() external pure returns (string memory) {
-        return "wLsETH";
-    }
-
-    /// @inheritdoc IWLSETHV1
-    function decimals() external pure returns (uint8) {
-        return 18;
-    }
-
-    /// @inheritdoc IWLSETHV1
-    function totalSupply() external view returns (uint256) {
-        return IRiverV1(payable(RiverAddress.get())).balanceOfUnderlying(address(this));
-    }
-
-    /// @inheritdoc IWLSETHV1
-    function balanceOf(address _owner) external view returns (uint256) {
-        return _balanceOf(_owner);
-    }
-
-    /// @inheritdoc IWLSETHV1
-    function sharesOf(address _owner) external view returns (uint256) {
-        return BalanceOf.get(_owner);
-    }
-
-    /// @inheritdoc IWLSETHV1
-    function allowance(address _owner, address _spender) external view returns (uint256) {
-        return ApprovalsPerOwner.get(_owner, _spender);
-    }
-
-    /// @inheritdoc IWLSETHV1
-    function transfer(address _to, uint256 _value)
-        external
-        isNotNull(_value)
-        hasFunds(msg.sender, _value)
-        returns (bool)
-    {
-        if (_to == address(0)) {
-            revert UnauthorizedTransfer(msg.sender, address(0));
-        }
-        return _transfer(msg.sender, _to, _value);
-    }
-
-    /// @inheritdoc IWLSETHV1
-    function transferFrom(address _from, address _to, uint256 _value)
-        external
-        isNotNull(_value)
-        hasFunds(_from, _value)
-        returns (bool)
-    {
-        if (_to == address(0)) {
-            revert UnauthorizedTransfer(_from, address(0));
-        }
-        _spendAllowance(_from, _value);
-        return _transfer(_from, _to, _value);
-    }
-
-    /// @inheritdoc IWLSETHV1
-    function approve(address _spender, uint256 _value) external returns (bool) {
-        _approve(msg.sender, _spender, _value);
-        return true;
-    }
-
-    /// @inheritdoc IWLSETHV1
-    function increaseAllowance(address _spender, uint256 _additionalValue) external returns (bool) {
-        _approve(msg.sender, _spender, ApprovalsPerOwner.get(msg.sender, _spender) + _additionalValue);
-        return true;
-    }
-
-    /// @inheritdoc IWLSETHV1
-    function decreaseAllowance(address _spender, uint256 _subtractableValue) external returns (bool) {
-        _approve(msg.sender, _spender, ApprovalsPerOwner.get(msg.sender, _spender) - _subtractableValue);
-        return true;
-    }
-
-    /// @inheritdoc IWLSETHV1
-    function mint(address _recipient, uint256 _shares) external nonReentrant {
-        BalanceOf.set(_recipient, BalanceOf.get(_recipient) + _shares);
-        IRiverV1 river = IRiverV1(payable(RiverAddress.get()));
-        if (!river.transferFrom(msg.sender, address(this), _shares)) {
-            revert TokenTransferError();
-        }
-        emit Mint(_recipient, _shares);
-        emit Transfer(address(0), _recipient, river.underlyingBalanceFromShares(_shares));
-    }
-
-    /// @inheritdoc IWLSETHV1
-    function burn(address _recipient, uint256 _shares) external nonReentrant {
-        uint256 shares = BalanceOf.get(msg.sender);
-        if (_shares > shares) {
-            revert BalanceTooLow();
-        }
-        BalanceOf.set(msg.sender, shares - _shares);
-        IRiverV1 river = IRiverV1(payable(RiverAddress.get()));
-        if (!river.transfer(_recipient, _shares)) {
-            revert TokenTransferError();
-        }
-        emit Transfer(msg.sender, address(0), river.underlyingBalanceFromShares(_shares));
-        emit Burn(_recipient, _shares);
-    }
-
-    /// @notice Internal utility to spend the allowance of an account from the message sender
-    /// @param _from Address owning the allowance
-    /// @param _value Amount of allowance to spend
-    function _spendAllowance(address _from, uint256 _value) internal {
-        uint256 currentAllowance = ApprovalsPerOwner.get(_from, msg.sender);
-        if (currentAllowance < _value) {
-            revert AllowanceTooLow(_from, msg.sender, currentAllowance, _value);
-        }
-        if (currentAllowance != type(uint256).max) {
-            _approve(_from, msg.sender, currentAllowance - _value);
-        }
-    }
-
-    /// @notice Internal utility to change the allowance of an owner to a spender
-    /// @param _owner The owner of the wrapped tokens
-    /// @param _spender The allowed spender of the wrapped tokens
-    /// @param _value The new allowance value
-    function _approve(address _owner, address _spender, uint256 _value) internal {
-        LibSanitize._notZeroAddress(_owner);
-        LibSanitize._notZeroAddress(_spender);
-        ApprovalsPerOwner.set(_owner, _spender, _value);
-        emit Approval(_owner, _spender, _value);
-    }
-
-    /// @notice Internal utility to retrieve the amount of token per owner
-    /// @param _owner Account to be checked
-    /// @return The balance of the account
-    function _balanceOf(address _owner) internal view returns (uint256) {
-        return IRiverV1(payable(RiverAddress.get())).underlyingBalanceFromShares(BalanceOf.get(_owner));
-    }
-
-    /// @notice Internal utility to perform an unchecked transfer
-    /// @param _from Address sending the tokens
-    /// @param _to Address receiving the tokens
-    /// @param _value Amount to be sent
-    /// @return True if success
-    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {
-        uint256 valueToShares = IRiverV1(payable(RiverAddress.get())).sharesFromUnderlyingBalance(_value);
-        BalanceOf.set(_from, BalanceOf.get(_from) - valueToShares);
-        BalanceOf.set(_to, BalanceOf.get(_to) + valueToShares);
-
-        emit Transfer(_from, _to, _value);
-
-        return true;
-    }
-}
diff -ruN src/Withdraw.1.sol Withdraw.1.sol
--- src/Withdraw.1.sol	2023-12-11 15:38:07
+++ Withdraw.1.sol	2024-01-16 15:06:39
@@ -1,54 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "./Initializable.sol";
-import "./interfaces/IRiver.1.sol";
-import "./interfaces/IWithdraw.1.sol";
-import "./libraries/LibErrors.sol";
-import "./libraries/LibUint256.sol";
-
-import "./state/shared/RiverAddress.sol";
-
-/// @title Withdraw (v1)
-/// @author Kiln
-/// @notice This contract is in charge of holding the exit and skimming funds and allow river to pull these funds
-contract WithdrawV1 is IWithdrawV1, Initializable {
-    modifier onlyRiver() {
-        if (msg.sender != RiverAddress.get()) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-        _;
-    }
-
-    /// @inheritdoc IWithdrawV1
-    function initializeWithdrawV1(address _river) external init(0) {
-        _setRiver(_river);
-    }
-
-    /// @inheritdoc IWithdrawV1
-    function getCredentials() external view returns (bytes32) {
-        return bytes32(
-            uint256(uint160(address(this))) + 0x0100000000000000000000000000000000000000000000000000000000000000
-        );
-    }
-
-    /// @inheritdoc IWithdrawV1
-    function getRiver() external view returns (address) {
-        return RiverAddress.get();
-    }
-
-    /// @inheritdoc IWithdrawV1
-    function pullEth(uint256 _max) external onlyRiver {
-        uint256 amountToPull = LibUint256.min(address(this).balance, _max);
-        if (amountToPull > 0) {
-            IRiverV1(payable(RiverAddress.get())).sendCLFunds{value: amountToPull}();
-        }
-    }
-
-    /// @notice Internal utility to set the river address
-    /// @param _river The new river address
-    function _setRiver(address _river) internal {
-        RiverAddress.set(_river);
-        emit SetRiver(_river);
-    }
-}
diff -ruN src/components/ConsensusLayerDepositManager.1.sol components/ConsensusLayerDepositManager.1.sol
--- src/components/ConsensusLayerDepositManager.1.sol	2023-12-11 15:38:07
+++ components/ConsensusLayerDepositManager.1.sol	2024-01-16 15:06:39
@@ -1,165 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../interfaces/components/IConsensusLayerDepositManager.1.sol";
-import "../interfaces/IDepositContract.sol";
-
-import "../libraries/LibBytes.sol";
-import "../libraries/LibUint256.sol";
-
-import "../state/river/DepositContractAddress.sol";
-import "../state/river/WithdrawalCredentials.sol";
-import "../state/river/DepositedValidatorCount.sol";
-import "../state/river/BalanceToDeposit.sol";
-import "../state/river/CommittedBalance.sol";
-
-/// @title Consensus Layer Deposit Manager (v1)
-/// @author Kiln
-/// @notice This contract handles the interactions with the official deposit contract, funding all validators
-/// @notice Whenever a deposit to the consensus layer is requested, this contract computed the amount of keys
-/// @notice that could be deposited depending on the amount available in the contract. It then tries to retrieve
-/// @notice validator keys by calling its internal virtual method _getNextValidators. This method should be
-/// @notice overridden by the implementing contract to provide [0; _keyCount] keys when invoked.
-abstract contract ConsensusLayerDepositManagerV1 is IConsensusLayerDepositManagerV1 {
-    /// @notice Size of a BLS Public key in bytes
-    uint256 public constant PUBLIC_KEY_LENGTH = 48;
-    /// @notice Size of a BLS Signature in bytes
-    uint256 public constant SIGNATURE_LENGTH = 96;
-    /// @notice Size of a deposit in ETH
-    uint256 public constant DEPOSIT_SIZE = 32 ether;
-
-    /// @notice Handler called to retrieve the internal River admin address
-    /// @dev Must be Overridden
-    function _getRiverAdmin() internal view virtual returns (address);
-
-    /// @notice Handler called to change the committed balance to deposit
-    /// @param newCommittedBalance The new committed balance value
-    function _setCommittedBalance(uint256 newCommittedBalance) internal virtual;
-
-    /// @notice Internal helper to retrieve validator keys ready to be funded
-    /// @dev Must be overridden
-    /// @param _keyCount The amount of keys (or less) to return.
-    function _getNextValidators(uint256 _keyCount)
-        internal
-        virtual
-        returns (bytes[] memory publicKeys, bytes[] memory signatures);
-
-    /// @notice Initializer to set the deposit contract address and the withdrawal credentials to use
-    /// @param _depositContractAddress The address of the deposit contract
-    /// @param _withdrawalCredentials The withdrawal credentials to apply to all deposits
-    function initConsensusLayerDepositManagerV1(address _depositContractAddress, bytes32 _withdrawalCredentials)
-        internal
-    {
-        DepositContractAddress.set(_depositContractAddress);
-        emit SetDepositContractAddress(_depositContractAddress);
-
-        WithdrawalCredentials.set(_withdrawalCredentials);
-        emit SetWithdrawalCredentials(_withdrawalCredentials);
-    }
-
-    /// @inheritdoc IConsensusLayerDepositManagerV1
-    function getCommittedBalance() external view returns (uint256) {
-        return CommittedBalance.get();
-    }
-
-    /// @inheritdoc IConsensusLayerDepositManagerV1
-    function getBalanceToDeposit() external view returns (uint256) {
-        return BalanceToDeposit.get();
-    }
-
-    /// @inheritdoc IConsensusLayerDepositManagerV1
-    function getWithdrawalCredentials() external view returns (bytes32) {
-        return WithdrawalCredentials.get();
-    }
-
-    /// @inheritdoc IConsensusLayerDepositManagerV1
-    function getDepositedValidatorCount() external view returns (uint256) {
-        return DepositedValidatorCount.get();
-    }
-
-    /// @inheritdoc IConsensusLayerDepositManagerV1
-    function depositToConsensusLayer(uint256 _maxCount) external {
-        uint256 committedBalance = CommittedBalance.get();
-        uint256 keyToDepositCount = LibUint256.min(committedBalance / DEPOSIT_SIZE, _maxCount);
-
-        if (keyToDepositCount == 0) {
-            revert NotEnoughFunds();
-        }
-
-        // it's up to the internal overriden _getNextValidators method to provide two array of the same
-        // size for the publicKeys and the signatures
-        (bytes[] memory publicKeys, bytes[] memory signatures) = _getNextValidators(keyToDepositCount);
-
-        uint256 receivedPublicKeyCount = publicKeys.length;
-
-        if (receivedPublicKeyCount == 0) {
-            revert NoAvailableValidatorKeys();
-        }
-
-        if (receivedPublicKeyCount > keyToDepositCount) {
-            revert InvalidPublicKeyCount();
-        }
-
-        bytes32 withdrawalCredentials = WithdrawalCredentials.get();
-
-        if (withdrawalCredentials == 0) {
-            revert InvalidWithdrawalCredentials();
-        }
-
-        for (uint256 idx = 0; idx < receivedPublicKeyCount;) {
-            _depositValidator(publicKeys[idx], signatures[idx], withdrawalCredentials);
-            unchecked {
-                ++idx;
-            }
-        }
-        _setCommittedBalance(committedBalance - DEPOSIT_SIZE * receivedPublicKeyCount);
-        uint256 currentDepositedValidatorCount = DepositedValidatorCount.get();
-        DepositedValidatorCount.set(currentDepositedValidatorCount + receivedPublicKeyCount);
-        emit SetDepositedValidatorCount(
-            currentDepositedValidatorCount, currentDepositedValidatorCount + receivedPublicKeyCount
-        );
-    }
-
-    /// @notice Deposits 32 ETH to the official Deposit contract
-    /// @param _publicKey The public key of the validator
-    /// @param _signature The signature provided by the operator
-    /// @param _withdrawalCredentials The withdrawal credentials provided by River
-    function _depositValidator(bytes memory _publicKey, bytes memory _signature, bytes32 _withdrawalCredentials)
-        internal
-    {
-        if (_publicKey.length != PUBLIC_KEY_LENGTH) {
-            revert InconsistentPublicKeys();
-        }
-
-        if (_signature.length != SIGNATURE_LENGTH) {
-            revert InconsistentSignatures();
-        }
-        uint256 value = DEPOSIT_SIZE;
-
-        uint256 depositAmount = value / 1 gwei;
-
-        bytes32 pubkeyRoot = sha256(bytes.concat(_publicKey, bytes16(0)));
-        bytes32 signatureRoot = sha256(
-            bytes.concat(
-                sha256(LibBytes.slice(_signature, 0, 64)),
-                sha256(bytes.concat(LibBytes.slice(_signature, 64, SIGNATURE_LENGTH - 64), bytes32(0)))
-            )
-        );
-
-        bytes32 depositDataRoot = sha256(
-            bytes.concat(
-                sha256(bytes.concat(pubkeyRoot, _withdrawalCredentials)),
-                sha256(bytes.concat(bytes32(LibUint256.toLittleEndian64(depositAmount)), signatureRoot))
-            )
-        );
-
-        uint256 targetBalance = address(this).balance - value;
-
-        IDepositContract(DepositContractAddress.get()).deposit{value: value}(
-            _publicKey, abi.encodePacked(_withdrawalCredentials), _signature, depositDataRoot
-        );
-        if (address(this).balance != targetBalance) {
-            revert ErrorOnDeposit();
-        }
-    }
-}
diff -ruN src/components/ERC20VestableVotesUpgradeable.1.sol components/ERC20VestableVotesUpgradeable.1.sol
--- src/components/ERC20VestableVotesUpgradeable.1.sol	2023-12-11 15:38:07
+++ components/ERC20VestableVotesUpgradeable.1.sol	2024-01-16 15:06:39
@@ -1,471 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol";
-import "openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol";
-
-import "../interfaces/components/IERC20VestableVotesUpgradeable.1.sol";
-
-import "../state/tlc/VestingSchedules.2.sol";
-import "../state/tlc/IgnoreGlobalUnlockSchedule.sol";
-
-import "../libraries/LibSanitize.sol";
-import "../libraries/LibUint256.sol";
-
-/// @title ERC20VestableVotesUpgradeableV1
-/// @author Alluvial
-/// @notice This is an ERC20 extension that
-/// @notice   - can be used as source of vote power (inherited from OpenZeppelin ERC20VotesUpgradeable)
-/// @notice   - can delegate vote power from an account to another account (inherited from OpenZeppelin ERC20VotesUpgradeable)
-/// @notice   - can manage token vestings: ownership is progressively transferred to a beneficiary according to a vesting schedule
-/// @notice   - keeps a history (checkpoints) of each account's vote power
-/// @notice
-/// @notice Notes from OpenZeppelin [ERC20VotesUpgradeable](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol)
-/// @notice   - vote power can be delegated either by calling the {delegate} function, or by providing a signature to be used with {delegateBySig}
-/// @notice   - keeps a history (checkpoints) of each account's vote power
-/// @notice   - power can be queried through the public accessors {getVotes} and {getPastVotes}.
-/// @notice   - by default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it
-/// @notice requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.
-/// @notice
-/// @notice Notes about token vesting
-/// @notice   - any token holder can call the method {createVestingSchedule} in order to transfer tokens to a beneficiary according to a vesting schedule. When
-/// @notice     creating a vesting schedule, tokens are transferred to an escrow that holds the token while the vesting progresses. Voting power of the escrowed token is delegated to the
-/// @notice     beneficiary or a delegatee account set by the vesting schedule creator
-/// @notice   - the schedule beneficiary call {releaseVestingSchedule} to get vested tokens transferred from escrow
-/// @notice   - the schedule creator can revoke a revocable schedule by calling {revokeVestingSchedule} in which case the non-vested tokens are transfered from the escrow back to the creator
-/// @notice   - the schedule beneficiary can delegate escrow voting power to any account by calling {delegateVestingEscrow}
-/// @notice
-/// @notice Vesting schedule attributes are
-/// @notice   - start : start time of the vesting period
-/// @notice   - cliff duration: duration before which first tokens gets ownable
-/// @notice   - total duration: duration of the entire vesting (sum of all vesting period durations)
-/// @notice   - period duration: duration of a single period of vesting
-/// @notice   - lock duration: duration before tokens gets unlocked. can exceed the duration of the vesting chedule
-/// @notice   - amount: amount of tokens granted by the vesting schedule
-/// @notice   - beneficiary: beneficiary of tokens after they are releaseVestingScheduled
-/// @notice   - revocable: whether the schedule can be revoked
-/// @notice   - ignoreGlobalUnlockSchedule: whether the schedule should ignore the global unlock schedule
-/// @notice
-/// @notice Vesting schedule
-/// @notice   - if currentTime < cliff: vestedToken = 0
-/// @notice   - if cliff <= currentTime < end: vestedToken = (vestedPeriodCount(currentTime) * periodDuration * amount) / totalDuration
-/// @notice   - if end < currentTime: vestedToken = amount
-/// @notice
-/// @notice Global unlock schedule
-/// @notice   - the global unlock schedule releases 1/24th of the total scheduled amount every month after the local lock end
-/// @notice   - the local lock end is the end of the lock period of the vesting schedule
-/// @notice   - the global unlock schedule is ignored if the vesting schedule has the ignoreGlobalUnlockSchedule flag set to true
-/// @notice   - the global unlock schedule is only a cap on the vested funds that can be withdrawn, it does not alter the vesting
-/// @notice
-/// @notice Remark: After cliff new tokens get vested at the end of each period
-/// @notice
-/// @notice Vested token & lock period
-/// @notice   - a vested token is a token that will be eventually releasable from the escrow to the beneficiary once the lock period is over
-/// @notice   - lock period prevents beneficiary from releasing vested tokens before the lock period ends. Vested tokens
-/// @notice will eventually be releasable once the lock period is over
-/// @notice
-/// @notice Example: Joe gets a vesting starting on Jan 1st 2022 with duration of 1 year and a lock period of 2 years.
-/// @notice On Jan 1st 2023, Joe will have all tokens vested but can not yet release it due to the lock period.
-/// @notice On Jan 1st 2024, lock period is over and Joe can release all tokens.
-abstract contract ERC20VestableVotesUpgradeableV1 is
-    Initializable,
-    ERC20VotesUpgradeable,
-    IERC20VestableVotesUpgradeableV1
-{
-    // internal used to compute the address of the escrow
-    bytes32 internal constant ESCROW = bytes32(uint256(keccak256("escrow")) - 1);
-
-    function __ERC20VestableVotes_init() internal onlyInitializing {}
-
-    function __ERC20VestableVotes_init_unchained() internal onlyInitializing {}
-
-    /// @notice This method migrates the state of the vesting schedules from V1 to V2
-    /// @dev This method should be used if deployment with the old version using V1 state models is upgraded
-    function migrateVestingSchedulesFromV1ToV2() internal {
-        if (VestingSchedulesV2.getCount() == 0) {
-            uint256 existingV1VestingSchedules = VestingSchedulesV1.getCount();
-            for (uint256 idx; idx < existingV1VestingSchedules;) {
-                uint256 scheduleAmount = VestingSchedulesV1.get(idx).amount;
-                uint256 releasedAmount =
-                    scheduleAmount - LibUint256.min(balanceOf(_deterministicVestingEscrow(idx)), scheduleAmount);
-                VestingSchedulesV2.migrateVestingScheduleFromV1(idx, releasedAmount);
-                unchecked {
-                    ++idx;
-                }
-            }
-        }
-    }
-
-    /// @inheritdoc IERC20VestableVotesUpgradeableV1
-    function getVestingSchedule(uint256 _index) external view returns (VestingSchedulesV2.VestingSchedule memory) {
-        return VestingSchedulesV2.get(_index);
-    }
-
-    /// @inheritdoc IERC20VestableVotesUpgradeableV1
-    function isGlobalUnlockedScheduleIgnored(uint256 _index) external view returns (bool) {
-        return IgnoreGlobalUnlockSchedule.get(_index);
-    }
-
-    /// @inheritdoc IERC20VestableVotesUpgradeableV1
-    function getVestingScheduleCount() external view returns (uint256) {
-        return VestingSchedulesV2.getCount();
-    }
-
-    /// @inheritdoc IERC20VestableVotesUpgradeableV1
-    function vestingEscrow(uint256 _index) external view returns (address) {
-        return _deterministicVestingEscrow(_index);
-    }
-
-    /// @inheritdoc IERC20VestableVotesUpgradeableV1
-    function computeVestingReleasableAmount(uint256 _index) external view returns (uint256) {
-        VestingSchedulesV2.VestingSchedule memory vestingSchedule = VestingSchedulesV2.get(_index);
-        return _computeVestingReleasableAmount(vestingSchedule, false, _index);
-    }
-
-    /// @inheritdoc IERC20VestableVotesUpgradeableV1
-    function computeVestingVestedAmount(uint256 _index) external view returns (uint256) {
-        VestingSchedulesV2.VestingSchedule memory vestingSchedule = VestingSchedulesV2.get(_index);
-        return _computeVestedAmount(vestingSchedule, LibUint256.min(_getCurrentTime(), vestingSchedule.end));
-    }
-
-    /// @inheritdoc IERC20VestableVotesUpgradeableV1
-    function createVestingSchedule(
-        uint64 _start,
-        uint32 _cliffDuration,
-        uint32 _duration,
-        uint32 _periodDuration,
-        uint32 _lockDuration,
-        bool _revocable,
-        uint256 _amount,
-        address _beneficiary,
-        address _delegatee,
-        bool _ignoreGlobalUnlockSchedule
-    ) external returns (uint256) {
-        return _createVestingSchedule(
-            msg.sender,
-            _beneficiary,
-            _delegatee,
-            _start,
-            _cliffDuration,
-            _duration,
-            _periodDuration,
-            _lockDuration,
-            _revocable,
-            _amount,
-            _ignoreGlobalUnlockSchedule
-        );
-    }
-
-    /// @inheritdoc IERC20VestableVotesUpgradeableV1
-    function revokeVestingSchedule(uint256 _index, uint64 _end) external returns (uint256) {
-        return _revokeVestingSchedule(_index, _end);
-    }
-
-    /// @inheritdoc IERC20VestableVotesUpgradeableV1
-    function releaseVestingSchedule(uint256 _index) external returns (uint256) {
-        return _releaseVestingSchedule(_index);
-    }
-
-    /// @inheritdoc IERC20VestableVotesUpgradeableV1
-    function delegateVestingEscrow(uint256 _index, address _delegatee) external returns (bool) {
-        return _delegateVestingEscrow(_index, _delegatee);
-    }
-
-    /// @notice Creates a new vesting schedule
-    /// @param _creator creator of the token vesting
-    /// @param _beneficiary beneficiary of tokens after they are releaseVestingScheduled
-    /// @param _delegatee address of the delegate escrowed tokens votes to (if address(0) then it defaults to the beneficiary)
-    /// @param _start start time of the vesting period
-    /// @param _cliffDuration duration before which first tokens gets ownable
-    /// @param _duration duration of the entire vesting (sum of all vesting period durations)
-    /// @param _periodDuration duration of a single period of vesting
-    /// @param _lockDuration duration before tokens gets unlocked. can exceed the duration of the vesting chedule
-    /// @param _revocable whether the schedule can be revoked
-    /// @param _amount amount of tokens granted by the vesting schedule
-    /// @param _ignoreGlobalUnlockSchedule whether the schedule should ignore the global unlock schedule
-    /// @return index of the created vesting schedule
-    function _createVestingSchedule(
-        address _creator,
-        address _beneficiary,
-        address _delegatee,
-        uint64 _start,
-        uint32 _cliffDuration,
-        uint32 _duration,
-        uint32 _periodDuration,
-        uint32 _lockDuration,
-        bool _revocable,
-        uint256 _amount,
-        bool _ignoreGlobalUnlockSchedule
-    ) internal returns (uint256) {
-        if (balanceOf(_creator) < _amount) {
-            revert UnsufficientVestingScheduleCreatorBalance();
-        }
-
-        // validate schedule parameters
-        if (_beneficiary == address(0)) {
-            revert InvalidVestingScheduleParameter("Vesting schedule beneficiary must be non zero address");
-        }
-
-        if (_duration == 0) {
-            revert InvalidVestingScheduleParameter("Vesting schedule duration must be > 0");
-        }
-
-        if (_amount == 0) {
-            revert InvalidVestingScheduleParameter("Vesting schedule amount must be > 0");
-        }
-
-        if (_periodDuration == 0) {
-            revert InvalidVestingScheduleParameter("Vesting schedule period must be > 0");
-        }
-
-        if (_duration % _periodDuration > 0) {
-            revert InvalidVestingScheduleParameter("Vesting schedule duration must split in exact periods");
-        }
-
-        if (_cliffDuration % _periodDuration > 0) {
-            revert InvalidVestingScheduleParameter("Vesting schedule cliff duration must split in exact periods");
-        }
-
-        if (_cliffDuration > _duration) {
-            revert InvalidVestingScheduleParameter(
-                "Vesting schedule duration must be greater than or equal to the cliff duration"
-            );
-        }
-
-        if ((_amount * _periodDuration) / _duration == 0) {
-            revert InvalidVestingScheduleParameter("Vesting schedule amount too low for duration and period");
-        }
-
-        // if input start time is 0 then default to the current block time
-        if (_start == 0) {
-            _start = uint64(block.timestamp);
-        }
-
-        // create new vesting schedule
-        VestingSchedulesV2.VestingSchedule memory vestingSchedule = VestingSchedulesV2.VestingSchedule({
-            start: _start,
-            end: _start + _duration,
-            lockDuration: _lockDuration,
-            cliffDuration: _cliffDuration,
-            duration: _duration,
-            periodDuration: _periodDuration,
-            amount: _amount,
-            creator: _creator,
-            beneficiary: _beneficiary,
-            revocable: _revocable,
-            releasedAmount: 0
-        });
-        uint256 index = VestingSchedulesV2.push(vestingSchedule) - 1;
-
-        IgnoreGlobalUnlockSchedule.set(index, _ignoreGlobalUnlockSchedule);
-
-        // compute escrow address that will hold the token during the vesting
-        address escrow = _deterministicVestingEscrow(index);
-
-        // transfer tokens to the escrow
-        _transfer(_creator, escrow, _amount);
-
-        // delegate escrow tokens
-        if (_delegatee == address(0)) {
-            // default delegatee to beneficiary address
-            _delegate(escrow, _beneficiary);
-        } else {
-            _delegate(escrow, _delegatee);
-        }
-
-        emit CreatedVestingSchedule(index, _creator, _beneficiary, _amount);
-
-        return index;
-    }
-
-    /// @notice Revoke vesting schedule
-    /// @param _index Index of the vesting schedule to revoke
-    /// @param _end End date for the schedule
-    /// @return returnedAmount amount returned to the vesting schedule creator
-    function _revokeVestingSchedule(uint256 _index, uint64 _end) internal returns (uint256) {
-        if (_end == 0) {
-            // if end time is 0 then default to current block time
-            _end = uint64(block.timestamp);
-        } else if (_end < block.timestamp) {
-            revert VestingScheduleNotRevocableInPast();
-        }
-
-        VestingSchedulesV2.VestingSchedule storage vestingSchedule = VestingSchedulesV2.get(_index);
-        if (!vestingSchedule.revocable) {
-            revert VestingScheduleNotRevocable();
-        }
-
-        // revoked end date MUST be after vesting schedule start and before current end
-        if ((_end < vestingSchedule.start) || (vestingSchedule.end < _end)) {
-            revert InvalidRevokedVestingScheduleEnd();
-        }
-
-        // only creator can revoke vesting schedule
-        if (vestingSchedule.creator != msg.sender) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-
-        // return tokens that will never be vested to creator
-        uint256 vestedAmountAtOldEnd = _computeVestedAmount(vestingSchedule, vestingSchedule.end);
-        uint256 vestedAmountAtNewEnd = _computeVestedAmount(vestingSchedule, _end);
-        uint256 returnedAmount = vestedAmountAtOldEnd - vestedAmountAtNewEnd;
-        if (returnedAmount > 0) {
-            address escrow = _deterministicVestingEscrow(_index);
-            _transfer(escrow, msg.sender, returnedAmount);
-        }
-
-        // set schedule end
-        vestingSchedule.end = uint64(_end);
-
-        emit RevokedVestingSchedule(_index, returnedAmount, _end);
-
-        return returnedAmount;
-    }
-
-    /// @notice Release vesting schedule
-    /// @param _index Index of the vesting schedule to release
-    /// @return released amount
-    function _releaseVestingSchedule(uint256 _index) internal returns (uint256) {
-        VestingSchedulesV2.VestingSchedule storage vestingSchedule = VestingSchedulesV2.get(_index);
-
-        // only beneficiary can release
-        if (msg.sender != vestingSchedule.beneficiary) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-
-        // compute releasable amount (taking into account local lock and global unlock schedule if it applies)
-        uint256 releasableAmount = _computeVestingReleasableAmount(vestingSchedule, true, _index);
-        if (releasableAmount == 0) {
-            revert ZeroReleasableAmount();
-        }
-
-        address escrow = _deterministicVestingEscrow(_index);
-
-        // transfer all releasable token to the beneficiary
-        _transfer(escrow, msg.sender, releasableAmount);
-
-        // increase released amount as per the release
-        vestingSchedule.releasedAmount += releasableAmount;
-
-        emit ReleasedVestingSchedule(_index, releasableAmount);
-
-        return releasableAmount;
-    }
-
-    /// @notice Delegate vesting escrowed tokens
-    /// @param _index index of the vesting schedule
-    /// @param _delegatee address to delegate the token to
-    /// @return True on success
-    function _delegateVestingEscrow(uint256 _index, address _delegatee) internal returns (bool) {
-        VestingSchedulesV2.VestingSchedule storage vestingSchedule = VestingSchedulesV2.get(_index);
-
-        // only beneficiary can delegate
-        if (msg.sender != vestingSchedule.beneficiary) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-
-        // update delegatee
-        address escrow = _deterministicVestingEscrow(_index);
-        address oldDelegatee = delegates(escrow);
-        _delegate(escrow, _delegatee);
-
-        emit DelegatedVestingEscrow(_index, oldDelegatee, _delegatee, msg.sender);
-
-        return true;
-    }
-
-    /// @notice Internal utility to compute the unique escrow deterministic address
-    /// @param _index index of the vesting schedule
-    /// @return escrow The deterministic escrow address for the vesting schedule index
-    function _deterministicVestingEscrow(uint256 _index) internal view returns (address escrow) {
-        bytes32 hash = keccak256(abi.encodePacked(address(this), ESCROW, _index));
-        return address(uint160(uint256(hash)));
-    }
-
-    /// @notice Computes the releasable amount of tokens for a vesting schedule.
-    /// @param _vestingSchedule vesting schedule to compute releasable tokens for
-    /// @param  _revertIfLocked if true will revert if the schedule is locked
-    /// @param _index index of the vesting schedule
-    /// @return amount of release tokens
-    function _computeVestingReleasableAmount(
-        VestingSchedulesV2.VestingSchedule memory _vestingSchedule,
-        bool _revertIfLocked,
-        uint256 _index
-    ) internal view returns (uint256) {
-        uint256 time = _getCurrentTime();
-        if (time < (_vestingSchedule.start + _vestingSchedule.lockDuration)) {
-            if (_revertIfLocked) {
-                revert VestingScheduleIsLocked();
-            } else {
-                return 0;
-            }
-        }
-        uint256 releasedAmount = _vestingSchedule.releasedAmount;
-        uint256 vestedAmount =
-            _computeVestedAmount(_vestingSchedule, time > _vestingSchedule.end ? _vestingSchedule.end : time);
-        if (vestedAmount > releasedAmount) {
-            if (!IgnoreGlobalUnlockSchedule.get(_index)) {
-                uint256 globalUnlocked = _computeGlobalUnlocked(
-                    _vestingSchedule.amount, time - (_vestingSchedule.start + _vestingSchedule.lockDuration)
-                );
-                if (releasedAmount > globalUnlocked) {
-                    revert GlobalUnlockUnderlfow();
-                }
-                return LibUint256.min(vestedAmount, globalUnlocked) - releasedAmount;
-            }
-            unchecked {
-                return vestedAmount - releasedAmount;
-            }
-        }
-
-        return 0;
-    }
-
-    /// @notice Computes the vested amount of tokens for a vesting schedule.
-    /// @param _vestingSchedule vesting schedule to compute vested tokens for
-    /// @param _time time to compute the vested amount at
-    /// @return amount of release tokens
-    function _computeVestedAmount(VestingSchedulesV2.VestingSchedule memory _vestingSchedule, uint256 _time)
-        internal
-        pure
-        returns (uint256)
-    {
-        if (_time < _vestingSchedule.start + _vestingSchedule.cliffDuration) {
-            // pre-cliff no tokens have been vested
-            return 0;
-        } else if (_time >= _vestingSchedule.start + _vestingSchedule.duration) {
-            // post vesting all tokens have been vested
-            return _vestingSchedule.amount;
-        } else {
-            uint256 timeFromStart = _time - _vestingSchedule.start;
-
-            // compute tokens vested for completely elapsed periods
-            uint256 vestedDuration = timeFromStart - timeFromStart % _vestingSchedule.periodDuration;
-
-            return (vestedDuration * _vestingSchedule.amount) / _vestingSchedule.duration;
-        }
-    }
-
-    /// @notice Computes the unlocked amount of tokens for a vesting schedule according to the global unlock schedule
-    /// @param scheduledAmount amount of tokens scheduled for the vesting schedule
-    /// @param timeSinceLocalLockEnd time since the local lock end
-    /// @return amount of unlocked tokens
-    function _computeGlobalUnlocked(uint256 scheduledAmount, uint256 timeSinceLocalLockEnd)
-        internal
-        pure
-        returns (uint256)
-    {
-        // 1/24 th of the amount per month
-        uint256 unlockedAmount = (scheduledAmount / 24) * (timeSinceLocalLockEnd / (365 days / 12));
-        if (unlockedAmount > scheduledAmount) {
-            return scheduledAmount;
-        }
-        return unlockedAmount;
-    }
-
-    /// @notice Returns current time
-    /// @return The current time
-    function _getCurrentTime() internal view virtual returns (uint256) {
-        return block.timestamp;
-    }
-}
diff -ruN src/components/OracleManager.1.sol components/OracleManager.1.sol
--- src/components/OracleManager.1.sol	2024-01-15 16:50:23
+++ components/OracleManager.1.sol	2024-01-16 15:06:39
@@ -1,497 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../interfaces/components/IOracleManager.1.sol";
-import "../interfaces/IRedeemManager.1.sol";
-
-import "../libraries/LibUint256.sol";
-
-import "../state/river/LastConsensusLayerReport.sol";
-import "../state/river/OracleAddress.sol";
-import "../state/river/CLValidatorTotalBalance.sol";
-import "../state/river/CLValidatorCount.sol";
-import "../state/river/DepositedValidatorCount.sol";
-import "../state/river/LastOracleRoundId.sol";
-
-/// @title Oracle Manager (v1)
-/// @author Kiln
-/// @notice This contract handles the inputs provided by the oracle
-/// @notice The Oracle contract is plugged to this contract and is in charge of pushing
-/// @notice data whenever a new report has been deemed valid. The report consists in two
-/// @notice values: the sum of all balances of all deposited validators and the count of
-/// @notice validators that have been activated on the consensus layer.
-abstract contract OracleManagerV1 is IOracleManagerV1 {
-    uint256 internal constant ONE_YEAR = 365 days;
-    /// @notice Size of a deposit in ETH
-    uint256 public constant _DEPOSIT_SIZE = 32 ether;
-
-    /// @notice Handler called if the delta between the last and new validator balance sum is positive
-    /// @dev Must be overridden
-    /// @param _profits The positive increase in the validator balance sum (staking rewards)
-    function _onEarnings(uint256 _profits) internal virtual;
-
-    /// @notice Handler called to pull the Execution layer fees from the recipient
-    /// @dev Must be overridden
-    /// @param _max The maximum amount to pull inside the system
-    /// @return The amount pulled inside the system
-    function _pullELFees(uint256 _max) internal virtual returns (uint256);
-
-    /// @notice Handler called to pull the coverage funds
-    /// @dev Must be overridden
-    /// @param _max The maximum amount to pull inside the system
-    /// @return The amount pulled inside the system
-    function _pullCoverageFunds(uint256 _max) internal virtual returns (uint256);
-
-    /// @notice Handler called to retrieve the system administrator address
-    /// @dev Must be overridden
-    /// @return The system administrator address
-    function _getRiverAdmin() internal view virtual returns (address);
-
-    /// @notice Overridden handler called whenever the total balance of ETH is requested
-    /// @return The current total asset balance managed by River
-    function _assetBalance() internal view virtual returns (uint256);
-
-    /// @notice Pulls funds from the Withdraw contract, and adds funds to deposit and redeem balances
-    /// @param _skimmedEthAmount The new amount of skimmed eth to pull
-    /// @param _exitedEthAmount The new amount of exited eth to pull
-    function _pullCLFunds(uint256 _skimmedEthAmount, uint256 _exitedEthAmount) internal virtual;
-
-    /// @notice Pulls funds from the redeem manager exceeding eth buffer
-    /// @param _max The maximum amount to pull
-    /// @return The amount pulled
-    function _pullRedeemManagerExceedingEth(uint256 _max) internal virtual returns (uint256);
-
-    /// @notice Use the balance to redeem to report a withdrawal event on the redeem manager
-    function _reportWithdrawToRedeemManager() internal virtual;
-
-    /// @notice Requests exits of validators after possibly rebalancing deposit and redeem balances
-    /// @param _exitingBalance The currently exiting funds, soon to be received on the execution layer
-    /// @param _depositToRedeemRebalancingAllowed True if rebalancing from deposit to redeem is allowed
-    function _requestExitsBasedOnRedeemDemandAfterRebalancings(
-        uint256 _exitingBalance,
-        uint32[] memory _stoppedValidatorCounts,
-        bool _depositToRedeemRebalancingAllowed,
-        bool _slashingContainmentModeEnabled
-    ) internal virtual;
-
-    /// @notice Skims the redeem balance and sends remaining funds to the deposit balance
-    function _skimExcessBalanceToRedeem() internal virtual;
-
-    /// @notice Commits the deposit balance up to the allowed daily limit
-    /// @param _period The period between current and last report
-    function _commitBalanceToDeposit(uint256 _period) internal virtual;
-
-    /// @notice Prevents unauthorized calls
-    modifier onlyAdmin_OMV1() {
-        if (msg.sender != _getRiverAdmin()) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-        _;
-    }
-
-    /// @notice Set the initial oracle address
-    /// @param _oracle Address of the oracle
-    function initOracleManagerV1(address _oracle) internal {
-        OracleAddress.set(_oracle);
-        emit SetOracle(_oracle);
-    }
-
-    /// @notice Initializes version 1.1 of the oracle manager
-    /// @param _epochsPerFrame The amounts of epochs in a frame
-    /// @param _slotsPerEpoch The slots inside an epoch
-    /// @param _secondsPerSlot The seconds inside a slot
-    /// @param _genesisTime The genesis timestamp
-    /// @param _epochsToAssumedFinality The number of epochs before an epoch is considered final on-chain
-    /// @param _annualAprUpperBound The reporting upper bound
-    /// @param _relativeLowerBound The reporting lower bound
-    function initOracleManagerV1_1(
-        uint64 _epochsPerFrame,
-        uint64 _slotsPerEpoch,
-        uint64 _secondsPerSlot,
-        uint64 _genesisTime,
-        uint64 _epochsToAssumedFinality,
-        uint256 _annualAprUpperBound,
-        uint256 _relativeLowerBound
-    ) internal {
-        CLSpec.set(
-            CLSpec.CLSpecStruct({
-                epochsPerFrame: _epochsPerFrame,
-                slotsPerEpoch: _slotsPerEpoch,
-                secondsPerSlot: _secondsPerSlot,
-                genesisTime: _genesisTime,
-                epochsToAssumedFinality: _epochsToAssumedFinality
-            })
-        );
-        emit SetSpec(_epochsPerFrame, _slotsPerEpoch, _secondsPerSlot, _genesisTime, _epochsToAssumedFinality);
-        ReportBounds.set(
-            ReportBounds.ReportBoundsStruct({
-                annualAprUpperBound: _annualAprUpperBound,
-                relativeLowerBound: _relativeLowerBound
-            })
-        );
-        emit SetBounds(_annualAprUpperBound, _relativeLowerBound);
-
-        IOracleManagerV1.StoredConsensusLayerReport memory storedReport;
-        storedReport.epoch = uint256(LastOracleRoundId.get());
-        storedReport.validatorsBalance = CLValidatorTotalBalance.get();
-        storedReport.validatorsSkimmedBalance = 0;
-        storedReport.validatorsExitedBalance = 0;
-        storedReport.validatorsExitingBalance = 0;
-        storedReport.validatorsCount = uint32(CLValidatorCount.get());
-        storedReport.rebalanceDepositToRedeemMode = false;
-        storedReport.slashingContainmentMode = false;
-        LastConsensusLayerReport.set(storedReport);
-    }
-
-    /// @inheritdoc IOracleManagerV1
-    function getOracle() external view returns (address) {
-        return OracleAddress.get();
-    }
-
-    /// @inheritdoc IOracleManagerV1
-    function getCLValidatorTotalBalance() external view returns (uint256) {
-        return LastConsensusLayerReport.get().validatorsBalance;
-    }
-
-    /// @inheritdoc IOracleManagerV1
-    function getCLValidatorCount() external view returns (uint256) {
-        return LastConsensusLayerReport.get().validatorsCount;
-    }
-
-    /// @inheritdoc IOracleManagerV1
-    function getExpectedEpochId() external view returns (uint256) {
-        CLSpec.CLSpecStruct memory cls = CLSpec.get();
-        uint256 currentEpoch = _currentEpoch(cls);
-        return LibUint256.max(
-            LastConsensusLayerReport.get().epoch + cls.epochsPerFrame,
-            currentEpoch - (currentEpoch % cls.epochsPerFrame)
-        );
-    }
-
-    /// @inheritdoc IOracleManagerV1
-    function isValidEpoch(uint256 _epoch) external view returns (bool) {
-        return _isValidEpoch(CLSpec.get(), _epoch);
-    }
-
-    /// @inheritdoc IOracleManagerV1
-    function getTime() external view returns (uint256) {
-        return block.timestamp;
-    }
-
-    /// @inheritdoc IOracleManagerV1
-    function getLastCompletedEpochId() external view returns (uint256) {
-        return LastConsensusLayerReport.get().epoch;
-    }
-
-    /// @inheritdoc IOracleManagerV1
-    function getCurrentEpochId() external view returns (uint256) {
-        return _currentEpoch(CLSpec.get());
-    }
-
-    /// @inheritdoc IOracleManagerV1
-    function getCLSpec() external view returns (CLSpec.CLSpecStruct memory) {
-        return CLSpec.get();
-    }
-
-    /// @inheritdoc IOracleManagerV1
-    function getCurrentFrame() external view returns (uint256 _startEpochId, uint256 _startTime, uint256 _endTime) {
-        CLSpec.CLSpecStruct memory cls = CLSpec.get();
-        uint256 currentEpoch = _currentEpoch(cls);
-        _startEpochId = currentEpoch - (currentEpoch % cls.epochsPerFrame);
-        _startTime = _startEpochId * cls.slotsPerEpoch * cls.secondsPerSlot;
-        _endTime = (_startEpochId + cls.epochsPerFrame) * cls.slotsPerEpoch * cls.secondsPerSlot - 1;
-    }
-
-    /// @inheritdoc IOracleManagerV1
-    function getFrameFirstEpochId(uint256 _epochId) external view returns (uint256) {
-        return _epochId - (_epochId % CLSpec.get().epochsPerFrame);
-    }
-
-    /// @inheritdoc IOracleManagerV1
-    function getReportBounds() external view returns (ReportBounds.ReportBoundsStruct memory) {
-        return ReportBounds.get();
-    }
-
-    /// @inheritdoc IOracleManagerV1
-    function getLastConsensusLayerReport() external view returns (IOracleManagerV1.StoredConsensusLayerReport memory) {
-        return LastConsensusLayerReport.get();
-    }
-
-    /// @inheritdoc IOracleManagerV1
-    function setOracle(address _oracleAddress) external onlyAdmin_OMV1 {
-        OracleAddress.set(_oracleAddress);
-        emit SetOracle(_oracleAddress);
-    }
-
-    /// @inheritdoc IOracleManagerV1
-    function setCLSpec(CLSpec.CLSpecStruct calldata _newValue) external onlyAdmin_OMV1 {
-        CLSpec.set(_newValue);
-        emit SetSpec(
-            _newValue.epochsPerFrame,
-            _newValue.slotsPerEpoch,
-            _newValue.secondsPerSlot,
-            _newValue.genesisTime,
-            _newValue.epochsToAssumedFinality
-        );
-    }
-
-    /// @inheritdoc IOracleManagerV1
-    function setReportBounds(ReportBounds.ReportBoundsStruct calldata _newValue) external onlyAdmin_OMV1 {
-        ReportBounds.set(_newValue);
-        emit SetBounds(_newValue.annualAprUpperBound, _newValue.relativeLowerBound);
-    }
-
-    /// @notice Structure holding internal variables used during reporting
-    struct ConsensusLayerDataReportingVariables {
-        uint256 preReportUnderlyingBalance;
-        uint256 postReportUnderlyingBalance;
-        uint256 lastReportExitedBalance;
-        uint256 lastReportSkimmedBalance;
-        uint256 exitedAmountIncrease;
-        uint256 skimmedAmountIncrease;
-        uint256 timeElapsedSinceLastReport;
-        uint256 availableAmountToUpperBound;
-        uint256 redeemManagerDemand;
-        ConsensusLayerDataReportingTrace trace;
-    }
-
-    /// @inheritdoc IOracleManagerV1
-    function setConsensusLayerData(IOracleManagerV1.ConsensusLayerReport calldata _report) external {
-        // only the oracle is allowed to call this endpoint
-        if (msg.sender != OracleAddress.get()) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-
-        CLSpec.CLSpecStruct memory cls = CLSpec.get();
-
-        // we start by verifying that the reported epoch is valid based on the consensus layer spec
-        if (!_isValidEpoch(cls, _report.epoch)) {
-            revert InvalidEpoch(_report.epoch);
-        }
-
-        ConsensusLayerDataReportingVariables memory vars;
-
-        {
-            IOracleManagerV1.StoredConsensusLayerReport storage lastStoredReport = LastConsensusLayerReport.get();
-
-            vars.lastReportExitedBalance = lastStoredReport.validatorsExitedBalance;
-
-            // we ensure that the reported total exited balance is not decreasing
-            if (_report.validatorsExitedBalance < vars.lastReportExitedBalance) {
-                revert InvalidDecreasingValidatorsExitedBalance(
-                    vars.lastReportExitedBalance, _report.validatorsExitedBalance
-                );
-            }
-
-            // we compute the exited amount increase by taking the delta between reports
-            vars.exitedAmountIncrease = _report.validatorsExitedBalance - vars.lastReportExitedBalance;
-
-            vars.lastReportSkimmedBalance = lastStoredReport.validatorsSkimmedBalance;
-
-            // we ensure that the reported total skimmed balance is not decreasing
-            if (_report.validatorsSkimmedBalance < vars.lastReportSkimmedBalance) {
-                revert InvalidDecreasingValidatorsSkimmedBalance(
-                    vars.lastReportSkimmedBalance, _report.validatorsSkimmedBalance
-                );
-            }
-
-            // we ensure that the reported validator count is not decreasing
-            if (
-                _report.validatorsCount > DepositedValidatorCount.get()
-                    || _report.validatorsCount < lastStoredReport.validatorsCount
-            ) {
-                revert InvalidValidatorCountReport(
-                    _report.validatorsCount, DepositedValidatorCount.get(), lastStoredReport.validatorsCount
-                );
-            }
-
-            // we compute the new skimmed amount by taking the delta between reports
-            vars.skimmedAmountIncrease = _report.validatorsSkimmedBalance - vars.lastReportSkimmedBalance;
-
-            vars.timeElapsedSinceLastReport = _timeBetweenEpochs(cls, lastStoredReport.epoch, _report.epoch);
-        }
-
-        // we retrieve the current total underlying balance before any reporting data is applied to the system
-        vars.preReportUnderlyingBalance = _assetBalance();
-
-        // if we have new exited / skimmed eth available, we pull funds from the consensus layer recipient
-        if (vars.exitedAmountIncrease + vars.skimmedAmountIncrease > 0) {
-            // this method pulls and updates ethToDeposit / ethToRedeem accordingly
-            _pullCLFunds(vars.skimmedAmountIncrease, vars.exitedAmountIncrease);
-        }
-
-        {
-            // we update the system parameters, this will have an impact on how the total underlying balance is computed
-            IOracleManagerV1.StoredConsensusLayerReport memory storedReport;
-
-            storedReport.epoch = _report.epoch;
-            storedReport.validatorsBalance = _report.validatorsBalance;
-            storedReport.validatorsSkimmedBalance = _report.validatorsSkimmedBalance;
-            storedReport.validatorsExitedBalance = _report.validatorsExitedBalance;
-            storedReport.validatorsExitingBalance = _report.validatorsExitingBalance;
-            storedReport.validatorsCount = _report.validatorsCount;
-            storedReport.rebalanceDepositToRedeemMode = _report.rebalanceDepositToRedeemMode;
-            storedReport.slashingContainmentMode = _report.slashingContainmentMode;
-            LastConsensusLayerReport.set(storedReport);
-        }
-
-        ReportBounds.ReportBoundsStruct memory rb = ReportBounds.get();
-
-        // we compute the maximum allowed increase in balance based on the pre report value
-        uint256 maxIncrease = _maxIncrease(rb, vars.preReportUnderlyingBalance, vars.timeElapsedSinceLastReport);
-
-        // we retrieve the new total underlying balance after system parameters are changed
-        vars.postReportUnderlyingBalance = _assetBalance();
-
-        // we can now compute the earned rewards from the consensus layer balances
-        // in order to properly account for the balance increase, we compare the sums of current balances, skimmed balance and exited balances
-        // we also synthetically increase the current balance by 32 eth per new activated validator, this way we have no discrepency due
-        // to currently activating funds that were not yet accounted in the consensus layer balances
-        if (vars.postReportUnderlyingBalance >= vars.preReportUnderlyingBalance) {
-            // if this happens, we revert and the reporting process is cancelled
-            if (vars.postReportUnderlyingBalance > vars.preReportUnderlyingBalance + maxIncrease) {
-                revert TotalValidatorBalanceIncreaseOutOfBound(
-                    vars.preReportUnderlyingBalance,
-                    vars.postReportUnderlyingBalance,
-                    vars.timeElapsedSinceLastReport,
-                    rb.annualAprUpperBound
-                );
-            }
-
-            // we update the rewards based on the balance delta
-            vars.trace.rewards = vars.postReportUnderlyingBalance - vars.preReportUnderlyingBalance;
-
-            // we update the available amount to upper bound (the amount of eth we can still pull and stay below the upper reporting bound)
-            vars.availableAmountToUpperBound = maxIncrease - vars.trace.rewards;
-        } else {
-            // otherwise if the balance has decreased, we verify that we are not exceeding the lower reporting bound
-
-            // we compute the maximum allowed decrease in balance
-            uint256 maxDecrease = _maxDecrease(rb, vars.preReportUnderlyingBalance);
-
-            // we verify that the bound is not crossed
-            if (
-                vars.postReportUnderlyingBalance
-                    < vars.preReportUnderlyingBalance - LibUint256.min(maxDecrease, vars.preReportUnderlyingBalance)
-            ) {
-                revert TotalValidatorBalanceDecreaseOutOfBound(
-                    vars.preReportUnderlyingBalance,
-                    vars.postReportUnderlyingBalance,
-                    vars.timeElapsedSinceLastReport,
-                    rb.relativeLowerBound
-                );
-            }
-
-            // we update the available amount to upper bound to be equal to the maximum allowed increase plus the negative delta due to the loss
-            vars.availableAmountToUpperBound =
-                maxIncrease + (vars.preReportUnderlyingBalance - vars.postReportUnderlyingBalance);
-        }
-
-        // if we have available amount to upper bound after the reporting values are applied
-        if (vars.availableAmountToUpperBound > 0) {
-            // we pull the funds from the execution layer fee recipient
-            vars.trace.pulledELFees = _pullELFees(vars.availableAmountToUpperBound);
-            // we update the rewards
-            vars.trace.rewards += vars.trace.pulledELFees;
-            // we update the available amount accordingly
-            vars.availableAmountToUpperBound -= vars.trace.pulledELFees;
-        }
-
-        // if we have available amount to upper bound after the execution layer fees are pulled
-        if (vars.availableAmountToUpperBound > 0) {
-            // we pull the funds from the exceeding eth buffer of the redeem manager
-            vars.trace.pulledRedeemManagerExceedingEthBuffer =
-                _pullRedeemManagerExceedingEth(vars.availableAmountToUpperBound);
-            // we update the available amount accordingly
-            vars.availableAmountToUpperBound -= vars.trace.pulledRedeemManagerExceedingEthBuffer;
-        }
-
-        // if we have available amount to upper bound after pulling the exceeding eth buffer, we attempt to pull coverage funds
-        if (vars.availableAmountToUpperBound > 0) {
-            // we pull the funds from the coverage recipient
-            vars.trace.pulledCoverageFunds = _pullCoverageFunds(vars.availableAmountToUpperBound);
-            // we do not update the rewards as coverage is not considered rewards
-            // we do not update the available amount as there are no more pulling actions to perform afterwards
-        }
-
-        // if our rewards are not null, we dispatch the fee to the collector
-        if (vars.trace.rewards > 0) {
-            _onEarnings(vars.trace.rewards);
-        }
-
-        _requestExitsBasedOnRedeemDemandAfterRebalancings(
-            _report.validatorsExitingBalance,
-            _report.stoppedValidatorCountPerOperator,
-            _report.rebalanceDepositToRedeemMode,
-            _report.slashingContainmentMode
-        );
-
-        // we use the updated balanceToRedeem value to report a withdraw event on the redeem manager
-        _reportWithdrawToRedeemManager();
-
-        // if funds are left in the balance to redeem, we move them to the deposit balance
-        _skimExcessBalanceToRedeem();
-
-        // we update the committable amount based on daily maximum allowed
-        _commitBalanceToDeposit(vars.timeElapsedSinceLastReport);
-
-        // we emit a summary event with all the reporting details
-        emit ProcessedConsensusLayerReport(_report, vars.trace);
-    }
-
-    /// @notice Retrieve the current epoch based on the current timestamp
-    /// @param _cls The consensus layer spec struct
-    /// @return The current epoch
-    function _currentEpoch(CLSpec.CLSpecStruct memory _cls) internal view returns (uint256) {
-        return ((block.timestamp - _cls.genesisTime) / _cls.secondsPerSlot) / _cls.slotsPerEpoch;
-    }
-
-    /// @notice Verifies if the given epoch is valid
-    /// @param _cls The consensus layer spec struct
-    /// @param _epoch The epoch to verify
-    /// @return True if valid
-    function _isValidEpoch(CLSpec.CLSpecStruct memory _cls, uint256 _epoch) internal view returns (bool) {
-        return (
-            _currentEpoch(_cls) >= _epoch + _cls.epochsToAssumedFinality
-                && _epoch > LastConsensusLayerReport.get().epoch && _epoch % _cls.epochsPerFrame == 0
-        );
-    }
-
-    /// @notice Retrieves the maximum increase in balance based on current total underlying supply and period since last report
-    /// @param _rb The report bounds struct
-    /// @param _prevTotalEth The total underlying supply during reporting
-    /// @param _timeElapsed The time since last report
-    /// @return The maximum allowed increase in balance
-    function _maxIncrease(ReportBounds.ReportBoundsStruct memory _rb, uint256 _prevTotalEth, uint256 _timeElapsed)
-        internal
-        pure
-        returns (uint256)
-    {
-        return (_prevTotalEth * _rb.annualAprUpperBound * _timeElapsed) / (LibBasisPoints.BASIS_POINTS_MAX * ONE_YEAR);
-    }
-
-    /// @notice Retrieves the maximum decrease in balance based on current total underlying supply
-    /// @param _rb The report bounds struct
-    /// @param _prevTotalEth The total underlying supply during reporting
-    /// @return The maximum allowed decrease in balance
-    function _maxDecrease(ReportBounds.ReportBoundsStruct memory _rb, uint256 _prevTotalEth)
-        internal
-        pure
-        returns (uint256)
-    {
-        return (_prevTotalEth * _rb.relativeLowerBound) / LibBasisPoints.BASIS_POINTS_MAX;
-    }
-
-    /// @notice Retrieve the number of seconds between two epochs
-    /// @param _cls The consensus layer spec struct
-    /// @param _epochPast The starting epoch
-    /// @param _epochNow The current epoch
-    /// @return The number of seconds between the two epochs
-    function _timeBetweenEpochs(CLSpec.CLSpecStruct memory _cls, uint256 _epochPast, uint256 _epochNow)
-        internal
-        pure
-        returns (uint256)
-    {
-        return (_epochNow - _epochPast) * (_cls.secondsPerSlot * _cls.slotsPerEpoch);
-    }
-}
diff -ruN src/components/SharesManager.1.sol components/SharesManager.1.sol
--- src/components/SharesManager.1.sol	2023-12-11 15:38:07
+++ components/SharesManager.1.sol	2024-01-16 15:06:39
@@ -1,269 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../interfaces/components/ISharesManager.1.sol";
-
-import "../libraries/LibSanitize.sol";
-
-import "../state/river/Shares.sol";
-import "../state/river/SharesPerOwner.sol";
-import "../state/shared/ApprovalsPerOwner.sol";
-
-/// @title Shares Manager (v1)
-/// @author Kiln
-/// @notice This contract handles the shares of the depositor and the ERC20 interface
-abstract contract SharesManagerV1 is ISharesManagerV1 {
-    /// @notice Internal hook triggered on the external transfer call
-    /// @dev Must be overridden
-    /// @param _from Address of the sender
-    /// @param _to Address of the recipient
-    function _onTransfer(address _from, address _to) internal view virtual;
-
-    /// @notice Internal method to override to provide the total underlying asset balance
-    /// @dev Must be overridden
-    /// @return The total asset balance of the system
-    function _assetBalance() internal view virtual returns (uint256);
-
-    /// @notice Modifier used to ensure that the transfer is allowed by using the internal hook to perform internal checks
-    /// @param _from Address of the sender
-    /// @param _to Address of the recipient
-    modifier transferAllowed(address _from, address _to) {
-        _onTransfer(_from, _to);
-        _;
-    }
-
-    /// @notice Modifier used to ensure the amount transferred is not 0
-    /// @param _value Amount to check
-    modifier isNotZero(uint256 _value) {
-        if (_value == 0) {
-            revert NullTransfer();
-        }
-        _;
-    }
-
-    /// @notice Modifier used to ensure that the sender has enough funds for the transfer
-    /// @param _owner Address of the sender
-    /// @param _value Value that is required to be sent
-    modifier hasFunds(address _owner, uint256 _value) {
-        if (_balanceOf(_owner) < _value) {
-            revert BalanceTooLow();
-        }
-        _;
-    }
-
-    /// @inheritdoc ISharesManagerV1
-    function name() external pure returns (string memory) {
-        return "Liquid Staked ETH";
-    }
-
-    /// @inheritdoc ISharesManagerV1
-    function symbol() external pure returns (string memory) {
-        return "LsETH";
-    }
-
-    /// @inheritdoc ISharesManagerV1
-    function decimals() external pure returns (uint8) {
-        return 18;
-    }
-
-    /// @inheritdoc ISharesManagerV1
-    function totalSupply() external view returns (uint256) {
-        return _totalSupply();
-    }
-
-    /// @inheritdoc ISharesManagerV1
-    function totalUnderlyingSupply() external view returns (uint256) {
-        return _assetBalance();
-    }
-
-    /// @inheritdoc ISharesManagerV1
-    function balanceOf(address _owner) external view returns (uint256) {
-        return _balanceOf(_owner);
-    }
-
-    /// @inheritdoc ISharesManagerV1
-    function balanceOfUnderlying(address _owner) public view returns (uint256) {
-        return _balanceFromShares(SharesPerOwner.get(_owner));
-    }
-
-    /// @inheritdoc ISharesManagerV1
-    function underlyingBalanceFromShares(uint256 _shares) external view returns (uint256) {
-        return _balanceFromShares(_shares);
-    }
-
-    /// @inheritdoc ISharesManagerV1
-    function sharesFromUnderlyingBalance(uint256 _underlyingAssetAmount) external view returns (uint256) {
-        return _sharesFromBalance(_underlyingAssetAmount);
-    }
-
-    /// @inheritdoc ISharesManagerV1
-    function allowance(address _owner, address _spender) external view returns (uint256) {
-        return ApprovalsPerOwner.get(_owner, _spender);
-    }
-
-    /// @inheritdoc ISharesManagerV1
-    function transfer(address _to, uint256 _value)
-        external
-        transferAllowed(msg.sender, _to)
-        isNotZero(_value)
-        hasFunds(msg.sender, _value)
-        returns (bool)
-    {
-        if (_to == address(0)) {
-            revert UnauthorizedTransfer(msg.sender, address(0));
-        }
-        return _transfer(msg.sender, _to, _value);
-    }
-
-    /// @inheritdoc ISharesManagerV1
-    function transferFrom(address _from, address _to, uint256 _value)
-        external
-        transferAllowed(_from, _to)
-        isNotZero(_value)
-        hasFunds(_from, _value)
-        returns (bool)
-    {
-        if (_to == address(0)) {
-            revert UnauthorizedTransfer(_from, address(0));
-        }
-        _spendAllowance(_from, _value);
-        return _transfer(_from, _to, _value);
-    }
-
-    /// @inheritdoc ISharesManagerV1
-    function approve(address _spender, uint256 _value) external returns (bool) {
-        _approve(msg.sender, _spender, _value);
-        return true;
-    }
-
-    /// @inheritdoc ISharesManagerV1
-    function increaseAllowance(address _spender, uint256 _additionalValue) external returns (bool) {
-        _approve(msg.sender, _spender, ApprovalsPerOwner.get(msg.sender, _spender) + _additionalValue);
-        return true;
-    }
-
-    /// @inheritdoc ISharesManagerV1
-    function decreaseAllowance(address _spender, uint256 _subtractableValue) external returns (bool) {
-        _approve(msg.sender, _spender, ApprovalsPerOwner.get(msg.sender, _spender) - _subtractableValue);
-        return true;
-    }
-
-    /// @notice Internal utility to spend the allowance of an account from the message sender
-    /// @param _from Address owning the allowance
-    /// @param _value Amount of allowance in shares to spend
-    function _spendAllowance(address _from, uint256 _value) internal {
-        uint256 currentAllowance = ApprovalsPerOwner.get(_from, msg.sender);
-        if (currentAllowance < _value) {
-            revert AllowanceTooLow(_from, msg.sender, currentAllowance, _value);
-        }
-        if (currentAllowance != type(uint256).max) {
-            _approve(_from, msg.sender, currentAllowance - _value);
-        }
-    }
-
-    /// @notice Internal utility to change the allowance of an owner to a spender
-    /// @param _owner The owner of the shares
-    /// @param _spender The allowed spender of the shares
-    /// @param _value The new allowance value
-    function _approve(address _owner, address _spender, uint256 _value) internal {
-        LibSanitize._notZeroAddress(_owner);
-        LibSanitize._notZeroAddress(_spender);
-        ApprovalsPerOwner.set(_owner, _spender, _value);
-        emit Approval(_owner, _spender, _value);
-    }
-
-    /// @notice Internal utility to retrieve the total supply of tokens
-    /// @return The total supply
-    function _totalSupply() internal view returns (uint256) {
-        return Shares.get();
-    }
-
-    /// @notice Internal utility to perform an unchecked transfer
-    /// @param _from Address sending the tokens
-    /// @param _to Address receiving the tokens
-    /// @param _value Amount of shares to be sent
-    /// @return True if success
-    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {
-        SharesPerOwner.set(_from, SharesPerOwner.get(_from) - _value);
-        SharesPerOwner.set(_to, SharesPerOwner.get(_to) + _value);
-
-        emit Transfer(_from, _to, _value);
-
-        return true;
-    }
-
-    /// @notice Internal utility to retrieve the underlying asset balance for the given shares
-    /// @param _shares Amount of shares to convert
-    /// @return The balance from the given shares
-    function _balanceFromShares(uint256 _shares) internal view returns (uint256) {
-        uint256 _totalSharesValue = Shares.get();
-
-        if (_totalSharesValue == 0) {
-            return 0;
-        }
-
-        return ((_shares * _assetBalance())) / _totalSharesValue;
-    }
-
-    /// @notice Internal utility to retrieve the shares count for a given underlying asset amount
-    /// @param _balance Amount of underlying asset balance to convert
-    /// @return The shares from the given balance
-    function _sharesFromBalance(uint256 _balance) internal view returns (uint256) {
-        uint256 _totalSharesValue = Shares.get();
-
-        if (_totalSharesValue == 0) {
-            return 0;
-        }
-
-        return (_balance * _totalSharesValue) / _assetBalance();
-    }
-
-    /// @notice Internal utility to mint shares for the specified user
-    /// @dev This method assumes that funds received are now part of the _assetBalance()
-    /// @param _owner Account that should receive the new shares
-    /// @param _underlyingAssetValue Value of underlying asset received, to convert into shares
-    /// @return sharesToMint The amnount of minted shares
-    function _mintShares(address _owner, uint256 _underlyingAssetValue) internal returns (uint256 sharesToMint) {
-        uint256 oldTotalAssetBalance = _assetBalance() - _underlyingAssetValue;
-
-        if (oldTotalAssetBalance == 0) {
-            sharesToMint = _underlyingAssetValue;
-            _mintRawShares(_owner, _underlyingAssetValue);
-        } else {
-            sharesToMint = (_underlyingAssetValue * _totalSupply()) / oldTotalAssetBalance;
-            _mintRawShares(_owner, sharesToMint);
-        }
-    }
-
-    /// @notice Internal utility to retrieve the amount of shares per owner
-    /// @param _owner Account to be checked
-    /// @return The balance of the account in shares
-    function _balanceOf(address _owner) internal view returns (uint256) {
-        return SharesPerOwner.get(_owner);
-    }
-
-    /// @notice Internal utility to mint shares without any conversion, and emits a mint Transfer event
-    /// @param _owner Account that should receive the new shares
-    /// @param _value Amount of shares to mint
-    function _mintRawShares(address _owner, uint256 _value) internal {
-        _setTotalSupply(Shares.get() + _value);
-        SharesPerOwner.set(_owner, SharesPerOwner.get(_owner) + _value);
-        emit Transfer(address(0), _owner, _value);
-    }
-
-    /// @notice Internal utility to burn shares without any conversion, and emits a burn Transfer event
-    /// @param _owner Account that should burn its shares
-    /// @param _value Amount of shares to burn
-    function _burnRawShares(address _owner, uint256 _value) internal {
-        _setTotalSupply(Shares.get() - _value);
-        SharesPerOwner.set(_owner, SharesPerOwner.get(_owner) - _value);
-        emit Transfer(_owner, address(0), _value);
-    }
-
-    /// @notice Internal utility to set the total supply and emit an event
-    /// @param newTotalSupply The new total supply value
-    function _setTotalSupply(uint256 newTotalSupply) internal {
-        Shares.set(newTotalSupply);
-        emit SetTotalSupply(newTotalSupply);
-    }
-}
diff -ruN src/components/UserDepositManager.1.sol components/UserDepositManager.1.sol
--- src/components/UserDepositManager.1.sol	2023-12-13 16:26:45
+++ components/UserDepositManager.1.sol	2024-01-16 15:06:39
@@ -1,56 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../interfaces/components/IUserDepositManager.1.sol";
-
-import "../libraries/LibSanitize.sol";
-
-import "../state/river/BalanceToDeposit.sol";
-
-/// @title User Deposit Manager (v1)
-/// @author Kiln
-/// @notice This contract handles the inbound transfers cases or the explicit submissions
-abstract contract UserDepositManagerV1 is IUserDepositManagerV1 {
-    /// @notice Handler called whenever a user has sent funds to the contract
-    /// @dev Must be overridden
-    /// @param _depositor Address that made the deposit
-    /// @param _recipient Address that receives the minted shares
-    /// @param _amount Amount deposited
-    function _onDeposit(address _depositor, address _recipient, uint256 _amount) internal virtual;
-    function _setBalanceToDeposit(uint256 newBalanceToDeposit) internal virtual;
-
-    /// @inheritdoc IUserDepositManagerV1
-    function deposit() external payable {
-        _deposit(msg.sender);
-    }
-
-    /// @inheritdoc IUserDepositManagerV1
-    function depositAndTransfer(address _recipient) external payable {
-        LibSanitize._notZeroAddress(_recipient);
-        _deposit(_recipient);
-    }
-
-    /// @inheritdoc IUserDepositManagerV1
-    receive() external payable {
-        _deposit(msg.sender);
-    }
-
-    /// @inheritdoc IUserDepositManagerV1
-    fallback() external payable {
-        revert LibErrors.InvalidCall();
-    }
-
-    /// @notice Internal utility calling the deposit handler and emitting the deposit details
-    /// @param _recipient The account receiving the minted shares
-    function _deposit(address _recipient) internal {
-        if (msg.value == 0) {
-            revert EmptyDeposit();
-        }
-
-        _setBalanceToDeposit(BalanceToDeposit.get() + msg.value);
-
-        _onDeposit(msg.sender, _recipient, msg.value);
-
-        emit UserDeposit(msg.sender, _recipient, msg.value);
-    }
-}
diff -ruN src/contracts/src/Administrable.sol contracts/src/Administrable.sol
--- src/contracts/src/Administrable.sol	1970-01-01 01:00:00
+++ contracts/src/Administrable.sol	2024-01-16 15:06:39
@@ -0,0 +1,70 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "./interfaces/IAdministrable.sol";
+
+import "./libraries/LibAdministrable.sol";
+import "./libraries/LibSanitize.sol";
+
+/// @title Administrable
+/// @author Kiln
+/// @notice This contract handles the administration of the contracts
+abstract contract Administrable is IAdministrable {
+    /// @notice Prevents unauthorized calls
+    modifier onlyAdmin() {
+        if (msg.sender != LibAdministrable._getAdmin()) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+        _;
+    }
+
+    /// @notice Prevents unauthorized calls
+    modifier onlyPendingAdmin() {
+        if (msg.sender != LibAdministrable._getPendingAdmin()) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+        _;
+    }
+
+    /// @inheritdoc IAdministrable
+    function getAdmin() external view returns (address) {
+        return LibAdministrable._getAdmin();
+    }
+
+    /// @inheritdoc IAdministrable
+    function getPendingAdmin() external view returns (address) {
+        return LibAdministrable._getPendingAdmin();
+    }
+
+    /// @inheritdoc IAdministrable
+    function proposeAdmin(address _newAdmin) external onlyAdmin {
+        _setPendingAdmin(_newAdmin);
+    }
+
+    /// @inheritdoc IAdministrable
+    function acceptAdmin() external onlyPendingAdmin {
+        _setAdmin(LibAdministrable._getPendingAdmin());
+        _setPendingAdmin(address(0));
+    }
+
+    /// @notice Internal utility to set the admin address
+    /// @param _admin Address to set as admin
+    function _setAdmin(address _admin) internal {
+        LibSanitize._notZeroAddress(_admin);
+        LibAdministrable._setAdmin(_admin);
+        emit SetAdmin(_admin);
+    }
+
+    /// @notice Internal utility to set the pending admin address
+    /// @param _pendingAdmin Address to set as pending admin
+    function _setPendingAdmin(address _pendingAdmin) internal {
+        LibAdministrable._setPendingAdmin(_pendingAdmin);
+        emit SetPendingAdmin(_pendingAdmin);
+    }
+
+    /// @notice Internal utility to retrieve the address of the current admin
+    /// @return The address of admin
+    function _getAdmin() internal view returns (address) {
+        return LibAdministrable._getAdmin();
+    }
+}
diff -ruN src/contracts/src/Allowlist.1.sol contracts/src/Allowlist.1.sol
--- src/contracts/src/Allowlist.1.sol	1970-01-01 01:00:00
+++ contracts/src/Allowlist.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,157 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "./interfaces/IAllowlist.1.sol";
+
+import "./libraries/LibAllowlistMasks.sol";
+import "./Initializable.sol";
+import "./Administrable.sol";
+
+import "./state/allowlist/AllowerAddress.sol";
+import "./state/allowlist/DenierAddress.sol";
+import "./state/allowlist/Allowlist.sol";
+
+/// @title Allowlist (v1)
+/// @author Kiln
+/// @notice This contract handles the list of allowed recipients.
+/// @notice All accounts have an uint256 value associated with their addresses where
+/// @notice each bit represents a right in the system. The DENY_MASK defined the mask
+/// @notice used to identify if the denied bit is on, preventing users from interacting
+/// @notice with the system
+contract AllowlistV1 is IAllowlistV1, Initializable, Administrable {
+    /// @inheritdoc IAllowlistV1
+    function initAllowlistV1(address _admin, address _allower) external init(0) {
+        _setAdmin(_admin);
+        AllowerAddress.set(_allower);
+        emit SetAllower(_allower);
+    }
+
+    function initAllowlistV1_1(address _denier) external init(1) {
+        DenierAddress.set(_denier);
+        emit SetDenier(_denier);
+    }
+
+    /// @inheritdoc IAllowlistV1
+    function getAllower() external view returns (address) {
+        return AllowerAddress.get();
+    }
+
+    /// @inheritdoc IAllowlistV1
+    function getDenier() external view returns (address) {
+        return DenierAddress.get();
+    }
+
+    /// @inheritdoc IAllowlistV1
+    function isAllowed(address _account, uint256 _mask) external view returns (bool) {
+        uint256 userPermissions = Allowlist.get(_account);
+        if (userPermissions & LibAllowlistMasks.DENY_MASK == LibAllowlistMasks.DENY_MASK) {
+            return false;
+        }
+        return userPermissions & _mask == _mask;
+    }
+
+    /// @inheritdoc IAllowlistV1
+    function isDenied(address _account) external view returns (bool) {
+        return Allowlist.get(_account) & LibAllowlistMasks.DENY_MASK == LibAllowlistMasks.DENY_MASK;
+    }
+
+    /// @inheritdoc IAllowlistV1
+    function hasPermission(address _account, uint256 _mask) external view returns (bool) {
+        return Allowlist.get(_account) & _mask == _mask;
+    }
+
+    /// @inheritdoc IAllowlistV1
+    function getPermissions(address _account) external view returns (uint256) {
+        return Allowlist.get(_account);
+    }
+
+    /// @inheritdoc IAllowlistV1
+    function onlyAllowed(address _account, uint256 _mask) external view {
+        uint256 userPermissions = Allowlist.get(_account);
+        if (userPermissions & LibAllowlistMasks.DENY_MASK == LibAllowlistMasks.DENY_MASK) {
+            revert Denied(_account);
+        }
+        if (userPermissions & _mask != _mask) {
+            revert LibErrors.Unauthorized(_account);
+        }
+    }
+
+    /// @inheritdoc IAllowlistV1
+    function setAllower(address _newAllowerAddress) external onlyAdmin {
+        AllowerAddress.set(_newAllowerAddress);
+        emit SetAllower(_newAllowerAddress);
+    }
+
+    /// @inheritdoc IAllowlistV1
+    function setDenier(address _newDenierAddress) external onlyAdmin {
+        DenierAddress.set(_newDenierAddress);
+        emit SetDenier(_newDenierAddress);
+    }
+
+    /// @inheritdoc IAllowlistV1
+    function setAllowPermissions(address[] calldata _accounts, uint256[] calldata _permissions) external {
+        if (msg.sender != AllowerAddress.get()) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+
+        if (_accounts.length == 0) {
+            revert InvalidCount();
+        }
+
+        if (_accounts.length != _permissions.length) {
+            revert MismatchedArrayLengths();
+        }
+
+        for (uint256 i = 0; i < _accounts.length;) {
+            LibSanitize._notZeroAddress(_accounts[i]);
+
+            // Check if account is already denied
+            if (Allowlist.get(_accounts[i]) & LibAllowlistMasks.DENY_MASK == LibAllowlistMasks.DENY_MASK) {
+                revert AttemptToRemoveDenyPermission();
+            }
+
+            // Check if DENY permission is present in new permission
+            if (_permissions[i] & LibAllowlistMasks.DENY_MASK == LibAllowlistMasks.DENY_MASK) {
+                revert AttemptToSetDenyPermission();
+            }
+
+            Allowlist.set(_accounts[i], _permissions[i]);
+            unchecked {
+                ++i;
+            }
+        }
+
+        emit SetAllowlistPermissions(_accounts, _permissions);
+    }
+
+    /// @inheritdoc IAllowlistV1
+    function setDenyPermissions(address[] calldata _accounts, uint256[] calldata _permissions) external {
+        if (msg.sender != DenierAddress.get()) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+
+        if (_accounts.length == 0) {
+            revert InvalidCount();
+        }
+
+        if (_accounts.length != _permissions.length) {
+            revert MismatchedArrayLengths();
+        }
+
+        for (uint256 i = 0; i < _accounts.length;) {
+            LibSanitize._notZeroAddress(_accounts[i]);
+            if (_permissions[i] & LibAllowlistMasks.DENY_MASK == LibAllowlistMasks.DENY_MASK) {
+                // Apply deny mask
+                Allowlist.set(_accounts[i], LibAllowlistMasks.DENY_MASK);
+            } else {
+                // Remove deny mask
+                Allowlist.set(_accounts[i], 0);
+            }
+            unchecked {
+                ++i;
+            }
+        }
+
+        emit SetAllowlistPermissions(_accounts, _permissions);
+    }
+}
diff -ruN src/contracts/src/CoverageFund.1.sol contracts/src/CoverageFund.1.sol
--- src/contracts/src/CoverageFund.1.sol	1970-01-01 01:00:00
+++ contracts/src/CoverageFund.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,74 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "./interfaces/IRiver.1.sol";
+import "./interfaces/IAllowlist.1.sol";
+import "./interfaces/ICoverageFund.1.sol";
+
+import "./libraries/LibUint256.sol";
+import "./libraries/LibAllowlistMasks.sol";
+
+import "./Initializable.sol";
+
+import "./state/shared/RiverAddress.sol";
+import "./state/slashingCoverage/BalanceForCoverage.sol";
+
+/// @title Coverage Fund (v1)
+/// @author Kiln
+/// @notice This contract receive donations for the slashing coverage fund and pull the funds into river
+/// @notice This contract acts as a temporary buffer for funds that should be pulled in case of a loss of money on the consensus layer due to slashing events.
+/// @notice There is no fee taken on these funds, they are entirely distributed to the LsETH holders, and no shares will get minted.
+/// @notice Funds will be distributed by increasing the underlying value of every LsETH share.
+/// @notice The fund will be called on every report and if eth is available in the contract, River will attempt to pull as much
+/// @notice ETH as possible. This maximum is defined by the upper bound allowed by the Oracle. This means that it might take multiple
+/// @notice reports for funds to be pulled entirely into the system due to this upper bound, ensuring a lower secondary market impact.
+/// @notice The value provided to this contract is computed off-chain and provided manually by Alluvial or any authorized insurance entity.
+/// @notice The Coverage funds are pulled upon an oracle report, after the ELFees have been pulled in the system, if there is a margin left
+/// @notice before crossing the upper bound. The reason behind this is to favor the revenue stream, that depends on market and network usage, while
+/// @notice the coverage fund will be pulled after the revenue stream, and there won't be any commission on the eth pulled.
+/// @notice Once a Slashing event occurs, the team will do its best to inject the recovery funds in at maximum 365 days
+/// @notice The entities allowed to donate are selected by the team. It will mainly be treasury entities or insurance protocols able to fill this coverage fund properly.
+contract CoverageFundV1 is Initializable, ICoverageFundV1 {
+    /// @inheritdoc ICoverageFundV1
+    function initCoverageFundV1(address _riverAddress) external init(0) {
+        RiverAddress.set(_riverAddress);
+        emit SetRiver(_riverAddress);
+    }
+
+    /// @inheritdoc ICoverageFundV1
+    function pullCoverageFunds(uint256 _maxAmount) external {
+        address river = RiverAddress.get();
+        if (msg.sender != river) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+        uint256 amount = LibUint256.min(_maxAmount, BalanceForCoverage.get());
+
+        if (amount > 0) {
+            BalanceForCoverage.set(BalanceForCoverage.get() - amount);
+            IRiverV1(payable(river)).sendCoverageFunds{value: amount}();
+        }
+    }
+
+    /// @inheritdoc ICoverageFundV1
+    function donate() external payable {
+        if (msg.value == 0) {
+            revert EmptyDonation();
+        }
+        BalanceForCoverage.set(BalanceForCoverage.get() + msg.value);
+
+        IAllowlistV1 allowlist = IAllowlistV1(IRiverV1(payable(RiverAddress.get())).getAllowlist());
+        allowlist.onlyAllowed(msg.sender, LibAllowlistMasks.DONATE_MASK);
+
+        emit Donate(msg.sender, msg.value);
+    }
+
+    /// @inheritdoc ICoverageFundV1
+    receive() external payable {
+        revert InvalidCall();
+    }
+
+    /// @inheritdoc ICoverageFundV1
+    fallback() external payable {
+        revert InvalidCall();
+    }
+}
diff -ruN src/contracts/src/ELFeeRecipient.1.sol contracts/src/ELFeeRecipient.1.sol
--- src/contracts/src/ELFeeRecipient.1.sol	1970-01-01 01:00:00
+++ contracts/src/ELFeeRecipient.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,45 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "./interfaces/IRiver.1.sol";
+import "./interfaces/IELFeeRecipient.1.sol";
+
+import "./libraries/LibUint256.sol";
+
+import "./Initializable.sol";
+
+import "./state/shared/RiverAddress.sol";
+
+/// @title Execution Layer Fee Recipient (v1)
+/// @author Kiln
+/// @notice This contract receives all the execution layer fees from the proposed blocks + bribes
+contract ELFeeRecipientV1 is Initializable, IELFeeRecipientV1 {
+    /// @inheritdoc IELFeeRecipientV1
+    function initELFeeRecipientV1(address _riverAddress) external init(0) {
+        RiverAddress.set(_riverAddress);
+        emit SetRiver(_riverAddress);
+    }
+
+    /// @inheritdoc IELFeeRecipientV1
+    function pullELFees(uint256 _maxAmount) external {
+        address river = RiverAddress.get();
+        if (msg.sender != river) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+        uint256 amount = LibUint256.min(_maxAmount, address(this).balance);
+
+        if (amount > 0) {
+            IRiverV1(payable(river)).sendELFees{value: amount}();
+        }
+    }
+
+    /// @inheritdoc IELFeeRecipientV1
+    receive() external payable {
+        this;
+    }
+
+    /// @inheritdoc IELFeeRecipientV1
+    fallback() external payable {
+        revert InvalidCall();
+    }
+}
diff -ruN src/contracts/src/Firewall.sol contracts/src/Firewall.sol
--- src/contracts/src/Firewall.sol	1970-01-01 01:00:00
+++ contracts/src/Firewall.sol	2024-01-16 15:06:39
@@ -0,0 +1,118 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "./interfaces/IFirewall.sol";
+
+import "./Administrable.sol";
+
+/// @title Firewall
+/// @author Figment
+/// @notice This contract accepts calls to admin-level functions of an underlying contract, and
+///         ensures the caller holds an appropriate role for calling that function. There are two roles:
+///          - An Admin can call anything
+///          - An Executor can call specific functions. The list of function is customisable.
+///         Random callers cannot call anything through this contract, even if the underlying function
+///         is unpermissioned in the underlying contract.
+///         Calls to non-admin functions should be called at the underlying contract directly.
+contract Firewall is IFirewall, Administrable {
+    /// @inheritdoc IFirewall
+    address public executor;
+
+    /// @inheritdoc IFirewall
+    address public destination;
+
+    /// @inheritdoc IFirewall
+    mapping(bytes4 => bool) public executorCanCall;
+
+    /// @param _admin Address of the administrator, that is able to perform all calls via the Firewall
+    /// @param _executor Address of the executor, that is able to perform only a subset of calls via the Firewall
+    /// @param _executorCallableSelectors Initial list of allowed selectors for the executor
+    constructor(address _admin, address _executor, address _destination, bytes4[] memory _executorCallableSelectors) {
+        LibSanitize._notZeroAddress(_executor);
+        LibSanitize._notZeroAddress(_destination);
+        _setAdmin(_admin);
+        executor = _executor;
+        destination = _destination;
+
+        emit SetExecutor(_executor);
+        emit SetDestination(_destination);
+
+        for (uint256 i; i < _executorCallableSelectors.length;) {
+            executorCanCall[_executorCallableSelectors[i]] = true;
+            emit SetExecutorPermissions(_executorCallableSelectors[i], true);
+            unchecked {
+                ++i;
+            }
+        }
+    }
+
+    /// @notice Prevents unauthorized calls
+    modifier onlyAdminOrExecutor() {
+        if (_getAdmin() != msg.sender && msg.sender != executor) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+        _;
+    }
+
+    /// @inheritdoc IFirewall
+    function setExecutor(address _newExecutor) external onlyAdminOrExecutor {
+        LibSanitize._notZeroAddress(_newExecutor);
+        executor = _newExecutor;
+        emit SetExecutor(_newExecutor);
+    }
+
+    /// @inheritdoc IFirewall
+    function allowExecutor(bytes4 _functionSelector, bool _executorCanCall) external onlyAdmin {
+        executorCanCall[_functionSelector] = _executorCanCall;
+        emit SetExecutorPermissions(_functionSelector, _executorCanCall);
+    }
+
+    /// @inheritdoc IFirewall
+    fallback() external payable virtual {
+        _fallback();
+    }
+
+    /// @inheritdoc IFirewall
+    receive() external payable virtual {
+        _fallback();
+    }
+
+    /// @notice Performs call checks to verify that the caller is able to perform the call
+    function _checkCallerRole() internal view {
+        if (msg.sender == _getAdmin() || (executorCanCall[msg.sig] && msg.sender == executor)) {
+            return;
+        }
+        revert LibErrors.Unauthorized(msg.sender);
+    }
+
+    /// @notice Forwards the current call parameters to the destination address
+    /// @param _destination Address on which the forwarded call is performed
+    /// @param _value Message value to attach to the call
+    function _forward(address _destination, uint256 _value) internal {
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            // Copy msg.data. We take full control of memory in this inline assembly
+            // block because it will not return to Solidity code. We overwrite the
+            // Solidity scratch pad at memory position 0.
+            calldatacopy(0, 0, calldatasize())
+
+            // Call the destination.
+            // out and outsize are 0 because we don't know the size yet.
+            let result := call(gas(), _destination, _value, 0, calldatasize(), 0, 0)
+
+            // Copy the returned data.
+            returndatacopy(0, 0, returndatasize())
+
+            switch result
+            // call returns 0 on error.
+            case 0 { revert(0, returndatasize()) }
+            default { return(0, returndatasize()) }
+        }
+    }
+
+    /// @notice Internal utility to perform authorization checks and forward a call
+    function _fallback() internal virtual {
+        _checkCallerRole();
+        _forward(destination, msg.value);
+    }
+}
diff -ruN src/contracts/src/Initializable.sol contracts/src/Initializable.sol
--- src/contracts/src/Initializable.sol	1970-01-01 01:00:00
+++ contracts/src/Initializable.sol	2024-01-16 15:06:39
@@ -0,0 +1,36 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "./state/shared/Version.sol";
+
+/// @title Initializable
+/// @author Kiln
+/// @notice This contract ensures that initializers are called only once per version
+contract Initializable {
+    /// @notice Disable initialization on implementations
+    constructor() {
+        Version.set(type(uint256).max);
+        emit Initialize(type(uint256).max, msg.data);
+    }
+
+    /// @notice An error occured during the initialization
+    /// @param version The version that was attempting to be initialized
+    /// @param expectedVersion The version that was expected
+    error InvalidInitialization(uint256 version, uint256 expectedVersion);
+
+    /// @notice Emitted when the contract is properly initialized
+    /// @param version New version of the contracts
+    /// @param cdata Complete calldata that was used during the initialization
+    event Initialize(uint256 version, bytes cdata);
+
+    /// @notice Use this modifier on initializers along with a hard-coded version number
+    /// @param _version Version to initialize
+    modifier init(uint256 _version) {
+        if (_version != Version.get()) {
+            revert InvalidInitialization(_version, Version.get());
+        }
+        Version.set(_version + 1); // prevents reentrency on the called method
+        _;
+        emit Initialize(_version, msg.data);
+    }
+}
diff -ruN src/contracts/src/OperatorsRegistry.1.sol contracts/src/OperatorsRegistry.1.sol
--- src/contracts/src/OperatorsRegistry.1.sol	1970-01-01 01:00:00
+++ contracts/src/OperatorsRegistry.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,858 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "./interfaces/IOperatorRegistry.1.sol";
+import "./interfaces/IRiver.1.sol";
+
+import "./libraries/LibUint256.sol";
+
+import "./Initializable.sol";
+import "./Administrable.sol";
+
+import "./state/operatorsRegistry/Operators.1.sol";
+import "./state/operatorsRegistry/Operators.2.sol";
+import "./state/operatorsRegistry/ValidatorKeys.sol";
+import "./state/operatorsRegistry/TotalValidatorExitsRequested.sol";
+import "./state/operatorsRegistry/CurrentValidatorExitsDemand.sol";
+import "./state/shared/RiverAddress.sol";
+
+import "./state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_KeyIndex.sol";
+import "./state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex.sol";
+
+/// @title Operators Registry (v1)
+/// @author Kiln
+/// @notice This contract handles the list of operators and their keys
+contract OperatorsRegistryV1 is IOperatorsRegistryV1, Initializable, Administrable {
+    /// @notice Maximum validators given to an operator per selection loop round
+    uint256 internal constant MAX_VALIDATOR_ATTRIBUTION_PER_ROUND = 5;
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function initOperatorsRegistryV1(address _admin, address _river) external init(0) {
+        _setAdmin(_admin);
+        RiverAddress.set(_river);
+        emit SetRiver(_river);
+    }
+
+    /// @notice Internal migration utility to migrate all operators to OperatorsV2 format
+    function _migrateOperators_V1_1() internal {
+        uint256 opCount = OperatorsV1.getCount();
+
+        for (uint256 idx = 0; idx < opCount;) {
+            OperatorsV1.Operator memory oldOperatorValue = OperatorsV1.get(idx);
+
+            OperatorsV2.push(
+                OperatorsV2.Operator({
+                    limit: uint32(oldOperatorValue.limit),
+                    funded: uint32(oldOperatorValue.funded),
+                    requestedExits: 0,
+                    keys: uint32(oldOperatorValue.keys),
+                    latestKeysEditBlockNumber: uint64(oldOperatorValue.latestKeysEditBlockNumber),
+                    active: oldOperatorValue.active,
+                    name: oldOperatorValue.name,
+                    operator: oldOperatorValue.operator
+                })
+            );
+
+            unchecked {
+                ++idx;
+            }
+        }
+    }
+
+    /// MIGRATION: FUNDED VALIDATOR KEY EVENT REBROADCASTING
+    /// As the event for funded keys was moved from River to this contract because we needed to be able to bind
+    /// operator indexes to public keys, we need to rebroadcast the past funded validator keys with the new event
+    /// to keep retro-compatibility
+
+    /// Emitted when the event rebroadcasting is done and we attempt to broadcast new events
+    error FundedKeyEventMigrationComplete();
+
+    /// Utility to force the broadcasting of events. Will keep its progress in storage to prevent being DoSed by the number of keys
+    /// @param _amountToEmit The amount of events to emit at maximum in this call
+    function forceFundedValidatorKeysEventEmission(uint256 _amountToEmit) external {
+        uint256 operatorIndex = OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex.get();
+        if (operatorIndex == type(uint256).max) {
+            revert FundedKeyEventMigrationComplete();
+        }
+        if (OperatorsV2.getCount() == 0) {
+            OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex.set(type(uint256).max);
+            return;
+        }
+        uint256 keyIndex = OperatorsRegistry_FundedKeyEventRebroadcasting_KeyIndex.get();
+        while (_amountToEmit > 0 && operatorIndex != type(uint256).max) {
+            OperatorsV2.Operator memory operator = OperatorsV2.get(operatorIndex);
+
+            (bytes[] memory publicKeys,) = ValidatorKeys.getKeys(
+                operatorIndex, keyIndex, LibUint256.min(_amountToEmit, operator.funded - keyIndex)
+            );
+            emit FundedValidatorKeys(operatorIndex, publicKeys, true);
+            if (keyIndex + publicKeys.length == operator.funded) {
+                keyIndex = 0;
+                if (operatorIndex == OperatorsV2.getCount() - 1) {
+                    operatorIndex = type(uint256).max;
+                } else {
+                    ++operatorIndex;
+                }
+            } else {
+                keyIndex += publicKeys.length;
+            }
+            _amountToEmit -= publicKeys.length;
+        }
+        OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex.set(operatorIndex);
+        OperatorsRegistry_FundedKeyEventRebroadcasting_KeyIndex.set(keyIndex);
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function initOperatorsRegistryV1_1() external init(1) {
+        _migrateOperators_V1_1();
+    }
+
+    /// @notice Prevent unauthorized calls
+    modifier onlyRiver() virtual {
+        if (msg.sender != RiverAddress.get()) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+        _;
+    }
+
+    /// @notice Prevents anyone except the admin or the given operator to make the call. Also checks if operator is active
+    /// @notice The admin is able to call this method on behalf of any operator, even if inactive
+    /// @param _index The index identifying the operator
+    modifier onlyOperatorOrAdmin(uint256 _index) {
+        if (msg.sender == _getAdmin()) {
+            _;
+            return;
+        }
+        OperatorsV2.Operator storage operator = OperatorsV2.get(_index);
+        if (!operator.active) {
+            revert InactiveOperator(_index);
+        }
+        if (msg.sender != operator.operator) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+        _;
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function getRiver() external view returns (address) {
+        return RiverAddress.get();
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function getOperator(uint256 _index) external view returns (OperatorsV2.Operator memory) {
+        return OperatorsV2.get(_index);
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function getOperatorStoppedValidatorCount(uint256 _idx) external view returns (uint32) {
+        return _getStoppedValidatorsCount(_idx);
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function getTotalStoppedValidatorCount() external view returns (uint32) {
+        return _getTotalStoppedValidatorCount();
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function getTotalValidatorExitsRequested() external view returns (uint256) {
+        return TotalValidatorExitsRequested.get();
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function getCurrentValidatorExitsDemand() external view returns (uint256) {
+        return CurrentValidatorExitsDemand.get();
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function getStoppedAndRequestedExitCounts() external view returns (uint32, uint256) {
+        return
+            (_getTotalStoppedValidatorCount(), TotalValidatorExitsRequested.get() + CurrentValidatorExitsDemand.get());
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function getOperatorCount() external view returns (uint256) {
+        return OperatorsV2.getCount();
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function getStoppedValidatorCountPerOperator() external view returns (uint32[] memory) {
+        uint32[] memory completeList = OperatorsV2.getStoppedValidators();
+        uint256 listLength = completeList.length;
+
+        if (listLength > 0) {
+            assembly {
+                // no need to use free memory pointer as we reuse the same memory range
+
+                // erase previous word storing length
+                mstore(completeList, 0)
+
+                // move memory pointer up by a word
+                completeList := add(completeList, 0x20)
+
+                // store updated length at new memory pointer location
+                mstore(completeList, sub(listLength, 1))
+            }
+        }
+
+        return completeList;
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function getValidator(uint256 _operatorIndex, uint256 _validatorIndex)
+        external
+        view
+        returns (bytes memory publicKey, bytes memory signature, bool funded)
+    {
+        (publicKey, signature) = ValidatorKeys.get(_operatorIndex, _validatorIndex);
+        funded = _validatorIndex < OperatorsV2.get(_operatorIndex).funded;
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function listActiveOperators() external view returns (OperatorsV2.Operator[] memory) {
+        return OperatorsV2.getAllActive();
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function reportStoppedValidatorCounts(uint32[] calldata _stoppedValidatorCounts, uint256 _depositedValidatorCount)
+        external
+        onlyRiver
+    {
+        _setStoppedValidatorCounts(_stoppedValidatorCounts, _depositedValidatorCount);
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function addOperator(string calldata _name, address _operator) external onlyAdmin returns (uint256) {
+        OperatorsV2.Operator memory newOperator = OperatorsV2.Operator({
+            active: true,
+            operator: _operator,
+            name: _name,
+            limit: 0,
+            funded: 0,
+            keys: 0,
+            requestedExits: 0,
+            latestKeysEditBlockNumber: uint64(block.number)
+        });
+
+        uint256 operatorIndex = OperatorsV2.push(newOperator) - 1;
+
+        emit AddedOperator(operatorIndex, _name, _operator);
+        return operatorIndex;
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function setOperatorAddress(uint256 _index, address _newOperatorAddress) external onlyOperatorOrAdmin(_index) {
+        LibSanitize._notZeroAddress(_newOperatorAddress);
+        OperatorsV2.Operator storage operator = OperatorsV2.get(_index);
+
+        operator.operator = _newOperatorAddress;
+
+        emit SetOperatorAddress(_index, _newOperatorAddress);
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function setOperatorName(uint256 _index, string calldata _newName) external onlyOperatorOrAdmin(_index) {
+        LibSanitize._notEmptyString(_newName);
+        OperatorsV2.Operator storage operator = OperatorsV2.get(_index);
+        operator.name = _newName;
+
+        emit SetOperatorName(_index, _newName);
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function setOperatorStatus(uint256 _index, bool _newStatus) external onlyAdmin {
+        OperatorsV2.Operator storage operator = OperatorsV2.get(_index);
+        operator.active = _newStatus;
+
+        emit SetOperatorStatus(_index, _newStatus);
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function setOperatorLimits(
+        uint256[] calldata _operatorIndexes,
+        uint32[] calldata _newLimits,
+        uint256 _snapshotBlock
+    ) external onlyAdmin {
+        if (_operatorIndexes.length != _newLimits.length) {
+            revert InvalidArrayLengths();
+        }
+        if (_operatorIndexes.length == 0) {
+            revert InvalidEmptyArray();
+        }
+        for (uint256 idx = 0; idx < _operatorIndexes.length;) {
+            uint256 operatorIndex = _operatorIndexes[idx];
+            uint32 newLimit = _newLimits[idx];
+
+            // prevents duplicates
+            if (idx > 0 && !(operatorIndex > _operatorIndexes[idx - 1])) {
+                revert UnorderedOperatorList();
+            }
+
+            OperatorsV2.Operator storage operator = OperatorsV2.get(operatorIndex);
+
+            uint32 currentLimit = operator.limit;
+            if (newLimit == currentLimit) {
+                emit OperatorLimitUnchanged(operatorIndex, newLimit);
+                unchecked {
+                    ++idx;
+                }
+                continue;
+            }
+
+            // we enter this condition if the operator edited its keys after the off-chain key audit was made
+            // we will skip any limit update on that operator unless it was a decrease in the initial limit
+            if (_snapshotBlock < operator.latestKeysEditBlockNumber && newLimit > currentLimit) {
+                emit OperatorEditsAfterSnapshot(
+                    operatorIndex, currentLimit, newLimit, operator.latestKeysEditBlockNumber, _snapshotBlock
+                );
+                unchecked {
+                    ++idx;
+                }
+                continue;
+            }
+
+            // otherwise, we check for limit invariants that shouldn't happen if the off-chain key audit
+            // was made properly, and if everything is respected, we update the limit
+
+            if (newLimit > operator.keys) {
+                revert OperatorLimitTooHigh(operatorIndex, newLimit, operator.keys);
+            }
+
+            if (newLimit < operator.funded) {
+                revert OperatorLimitTooLow(operatorIndex, newLimit, operator.funded);
+            }
+
+            operator.limit = newLimit;
+            emit SetOperatorLimit(operatorIndex, newLimit);
+
+            unchecked {
+                ++idx;
+            }
+        }
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function addValidators(uint256 _index, uint32 _keyCount, bytes calldata _publicKeysAndSignatures)
+        external
+        onlyOperatorOrAdmin(_index)
+    {
+        if (_keyCount == 0) {
+            revert InvalidKeyCount();
+        }
+
+        if (
+            _publicKeysAndSignatures.length
+                != _keyCount * (ValidatorKeys.PUBLIC_KEY_LENGTH + ValidatorKeys.SIGNATURE_LENGTH)
+        ) {
+            revert InvalidKeysLength();
+        }
+
+        OperatorsV2.Operator storage operator = OperatorsV2.get(_index);
+
+        for (uint256 idx = 0; idx < _keyCount;) {
+            bytes memory publicKeyAndSignature = LibBytes.slice(
+                _publicKeysAndSignatures,
+                idx * (ValidatorKeys.PUBLIC_KEY_LENGTH + ValidatorKeys.SIGNATURE_LENGTH),
+                ValidatorKeys.PUBLIC_KEY_LENGTH + ValidatorKeys.SIGNATURE_LENGTH
+            );
+            ValidatorKeys.set(_index, operator.keys + idx, publicKeyAndSignature);
+            unchecked {
+                ++idx;
+            }
+        }
+        OperatorsV2.setKeys(_index, operator.keys + _keyCount);
+
+        emit AddedValidatorKeys(_index, _publicKeysAndSignatures);
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function removeValidators(uint256 _index, uint256[] calldata _indexes) external onlyOperatorOrAdmin(_index) {
+        uint256 indexesLength = _indexes.length;
+        if (indexesLength == 0) {
+            revert InvalidKeyCount();
+        }
+
+        OperatorsV2.Operator storage operator = OperatorsV2.get(_index);
+
+        uint32 totalKeys = operator.keys;
+
+        if (!(_indexes[0] < totalKeys)) {
+            revert InvalidIndexOutOfBounds();
+        }
+
+        uint256 lastIndex = _indexes[indexesLength - 1];
+
+        if (lastIndex < operator.funded) {
+            revert InvalidFundedKeyDeletionAttempt();
+        }
+
+        bool limitEqualsKeyCount = operator.keys == operator.limit;
+        OperatorsV2.setKeys(_index, totalKeys - uint32(indexesLength));
+
+        uint256 idx;
+        for (; idx < indexesLength;) {
+            uint256 keyIndex = _indexes[idx];
+
+            if (idx > 0 && !(keyIndex < _indexes[idx - 1])) {
+                revert InvalidUnsortedIndexes();
+            }
+
+            unchecked {
+                ++idx;
+            }
+
+            uint256 lastKeyIndex = totalKeys - idx;
+
+            (bytes memory removedPublicKey,) = ValidatorKeys.get(_index, keyIndex);
+            (bytes memory lastPublicKeyAndSignature) = ValidatorKeys.getRaw(_index, lastKeyIndex);
+            ValidatorKeys.set(_index, keyIndex, lastPublicKeyAndSignature);
+            ValidatorKeys.set(_index, lastKeyIndex, new bytes(0));
+
+            emit RemovedValidatorKey(_index, removedPublicKey);
+        }
+
+        if (limitEqualsKeyCount) {
+            operator.limit = operator.keys;
+        } else if (lastIndex < operator.limit) {
+            operator.limit = uint32(lastIndex);
+        }
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function pickNextValidatorsToDeposit(uint256 _count)
+        external
+        onlyRiver
+        returns (bytes[] memory publicKeys, bytes[] memory signatures)
+    {
+        return _pickNextValidatorsToDepositFromActiveOperators(_count);
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function requestValidatorExits(uint256 _count) external {
+        uint256 currentValidatorExitsDemand = CurrentValidatorExitsDemand.get();
+        uint256 exitRequestsToPerform = LibUint256.min(currentValidatorExitsDemand, _count);
+        if (exitRequestsToPerform == 0) {
+            revert NoExitRequestsToPerform();
+        }
+        uint256 savedCurrentValidatorExitsDemand = currentValidatorExitsDemand;
+        currentValidatorExitsDemand -= _pickNextValidatorsToExitFromActiveOperators(exitRequestsToPerform);
+
+        _setCurrentValidatorExitsDemand(savedCurrentValidatorExitsDemand, currentValidatorExitsDemand);
+    }
+
+    /// @inheritdoc IOperatorsRegistryV1
+    function demandValidatorExits(uint256 _count, uint256 _depositedValidatorCount) external onlyRiver {
+        uint256 currentValidatorExitsDemand = CurrentValidatorExitsDemand.get();
+        uint256 totalValidatorExitsRequested = TotalValidatorExitsRequested.get();
+        _count = LibUint256.min(
+            _count, _depositedValidatorCount - (totalValidatorExitsRequested + currentValidatorExitsDemand)
+        );
+        if (_count > 0) {
+            _setCurrentValidatorExitsDemand(currentValidatorExitsDemand, currentValidatorExitsDemand + _count);
+        }
+    }
+
+    /// @notice Internal utility to retrieve the total stopped validator count
+    /// @return The total stopped validator count
+    function _getTotalStoppedValidatorCount() internal view returns (uint32) {
+        uint32[] storage stoppedValidatorCounts = OperatorsV2.getStoppedValidators();
+        if (stoppedValidatorCounts.length == 0) {
+            return 0;
+        }
+        return stoppedValidatorCounts[0];
+    }
+
+    /// @notice Internal utility to set the current validator exits demand
+    /// @param _currentValue The current value
+    /// @param _newValue The new value
+    function _setCurrentValidatorExitsDemand(uint256 _currentValue, uint256 _newValue) internal {
+        CurrentValidatorExitsDemand.set(_newValue);
+        emit SetCurrentValidatorExitsDemand(_currentValue, _newValue);
+    }
+
+    /// @notice Internal structure to hold variables for the _setStoppedValidatorCounts method
+    struct SetStoppedValidatorCountInternalVars {
+        uint256 stoppedValidatorCountsLength;
+        uint32[] currentStoppedValidatorCounts;
+        uint256 currentStoppedValidatorCountsLength;
+        uint32 totalStoppedValidatorCount;
+        uint32 count;
+        uint256 currentValidatorExitsDemand;
+        uint256 cachedCurrentValidatorExitsDemand;
+        uint256 totalRequestedExits;
+        uint256 cachedTotalRequestedExits;
+    }
+
+    /// @notice Internal utiltiy to set the stopped validator array after sanity checks
+    /// @param _stoppedValidatorCounts The stopped validators counts for every operator + the total count in index 0
+    /// @param _depositedValidatorCount The current deposited validator count
+    function _setStoppedValidatorCounts(uint32[] calldata _stoppedValidatorCounts, uint256 _depositedValidatorCount)
+        internal
+    {
+        SetStoppedValidatorCountInternalVars memory vars;
+        // we check that the array is not empty
+        vars.stoppedValidatorCountsLength = _stoppedValidatorCounts.length;
+        if (vars.stoppedValidatorCountsLength == 0) {
+            revert InvalidEmptyStoppedValidatorCountsArray();
+        }
+
+        OperatorsV2.Operator[] storage operators = OperatorsV2.getAll();
+
+        // we check that the cells containing operator stopped values are no more than the current operator count
+        if (vars.stoppedValidatorCountsLength - 1 > operators.length) {
+            revert StoppedValidatorCountsTooHigh();
+        }
+
+        vars.currentStoppedValidatorCounts = OperatorsV2.getStoppedValidators();
+        vars.currentStoppedValidatorCountsLength = vars.currentStoppedValidatorCounts.length;
+
+        // we check that the number of stopped values is not decreasing
+        if (vars.stoppedValidatorCountsLength < vars.currentStoppedValidatorCountsLength) {
+            revert StoppedValidatorCountArrayShrinking();
+        }
+
+        vars.totalStoppedValidatorCount = _stoppedValidatorCounts[0];
+        vars.count = 0;
+
+        // create value to track unsollicited validator exits (e.g. to cover cases when Node Operator exit a validator without being requested to)
+        vars.currentValidatorExitsDemand = CurrentValidatorExitsDemand.get();
+        vars.cachedCurrentValidatorExitsDemand = vars.currentValidatorExitsDemand;
+        vars.totalRequestedExits = TotalValidatorExitsRequested.get();
+        vars.cachedTotalRequestedExits = vars.totalRequestedExits;
+
+        uint256 idx = 1;
+        uint256 unsollicitedExitsSum;
+        for (; idx < vars.currentStoppedValidatorCountsLength;) {
+            // if the previous array was long enough, we check that the values are not decreasing
+            if (_stoppedValidatorCounts[idx] < vars.currentStoppedValidatorCounts[idx]) {
+                revert StoppedValidatorCountsDecreased();
+            }
+
+            // we check that the count of stopped validators is not above the funded validator count of an operator
+            if (_stoppedValidatorCounts[idx] > operators[idx - 1].funded) {
+                revert StoppedValidatorCountAboveFundedCount(
+                    idx - 1, _stoppedValidatorCounts[idx], operators[idx - 1].funded
+                );
+            }
+
+            // if the stopped validator count is greater than its requested exit count, we update the requested exit count
+            if (_stoppedValidatorCounts[idx] > operators[idx - 1].requestedExits) {
+                emit UpdatedRequestedValidatorExitsUponStopped(
+                    idx - 1, operators[idx - 1].requestedExits, _stoppedValidatorCounts[idx]
+                );
+                unsollicitedExitsSum += _stoppedValidatorCounts[idx] - operators[idx - 1].requestedExits;
+                operators[idx - 1].requestedExits = _stoppedValidatorCounts[idx];
+            }
+            emit SetOperatorStoppedValidatorCount(idx - 1, _stoppedValidatorCounts[idx]);
+
+            // we recompute the total to ensure it's not an invalid sum
+            vars.count += _stoppedValidatorCounts[idx];
+            unchecked {
+                ++idx;
+            }
+        }
+
+        // In case of a new operator we do not check against the current stopped validator count (would revert OOB)
+        for (; idx < vars.stoppedValidatorCountsLength;) {
+            // we check that the count of stopped validators is not above the funded validator count of an operator
+            if (_stoppedValidatorCounts[idx] > operators[idx - 1].funded) {
+                revert StoppedValidatorCountAboveFundedCount(
+                    idx - 1, _stoppedValidatorCounts[idx], operators[idx - 1].funded
+                );
+            }
+
+            // if the stopped validator count is greater than its requested exit count, we update the requested exit count
+            if (_stoppedValidatorCounts[idx] > operators[idx - 1].requestedExits) {
+                emit UpdatedRequestedValidatorExitsUponStopped(
+                    idx - 1, operators[idx - 1].requestedExits, _stoppedValidatorCounts[idx]
+                );
+                unsollicitedExitsSum += _stoppedValidatorCounts[idx] - operators[idx - 1].requestedExits;
+                operators[idx - 1].requestedExits = _stoppedValidatorCounts[idx];
+            }
+            emit SetOperatorStoppedValidatorCount(idx - 1, _stoppedValidatorCounts[idx]);
+
+            // we recompute the total to ensure it's not an invalid sum
+            vars.count += _stoppedValidatorCounts[idx];
+            unchecked {
+                ++idx;
+            }
+        }
+
+        vars.totalRequestedExits += unsollicitedExitsSum;
+        // we decrease the demand, considering unsollicited exits as if they were answering the demand
+        vars.currentValidatorExitsDemand -= LibUint256.min(unsollicitedExitsSum, vars.currentValidatorExitsDemand);
+
+        if (vars.totalRequestedExits != vars.cachedTotalRequestedExits) {
+            _setTotalValidatorExitsRequested(vars.cachedTotalRequestedExits, vars.totalRequestedExits);
+        }
+
+        if (vars.currentValidatorExitsDemand != vars.cachedCurrentValidatorExitsDemand) {
+            _setCurrentValidatorExitsDemand(vars.cachedCurrentValidatorExitsDemand, vars.currentValidatorExitsDemand);
+        }
+
+        // we check that the total is matching the sum of the individual values
+        if (vars.totalStoppedValidatorCount != vars.count) {
+            revert InvalidStoppedValidatorCountsSum();
+        }
+        // we check that the total is not higher than the current deposited validator count
+        if (vars.totalStoppedValidatorCount > _depositedValidatorCount) {
+            revert StoppedValidatorCountsTooHigh();
+        }
+        // we set the new stopped validators counts
+        OperatorsV2.setRawStoppedValidators(_stoppedValidatorCounts);
+        emit UpdatedStoppedValidators(_stoppedValidatorCounts);
+    }
+
+    /// @notice Internal utility to concatenate bytes arrays together
+    /// @param _arr1 First array
+    /// @param _arr2 Second array
+    /// @return The result of the concatenation of _arr1 + _arr2
+    function _concatenateByteArrays(bytes[] memory _arr1, bytes[] memory _arr2)
+        internal
+        pure
+        returns (bytes[] memory)
+    {
+        bytes[] memory res = new bytes[](_arr1.length + _arr2.length);
+        for (uint256 idx = 0; idx < _arr1.length;) {
+            res[idx] = _arr1[idx];
+            unchecked {
+                ++idx;
+            }
+        }
+        for (uint256 idx = 0; idx < _arr2.length;) {
+            res[idx + _arr1.length] = _arr2[idx];
+            unchecked {
+                ++idx;
+            }
+        }
+        return res;
+    }
+
+    /// @notice Internal utility to verify if an operator has fundable keys during the selection process
+    /// @param _operator The Operator structure in memory
+    /// @return True if at least one fundable key is available
+    function _hasFundableKeys(OperatorsV2.CachedOperator memory _operator) internal pure returns (bool) {
+        return (_operator.funded + _operator.picked) < _operator.limit;
+    }
+
+    /// @notice Internal utility to retrieve the actual stopped validator count of an operator from the reported array
+    /// @param _operatorIndex The operator index
+    /// @return The count of stopped validators
+    function _getStoppedValidatorsCount(uint256 _operatorIndex) internal view returns (uint32) {
+        return OperatorsV2._getStoppedValidatorCountAtIndex(OperatorsV2.getStoppedValidators(), _operatorIndex);
+    }
+
+    /// @notice Internal utility to get the count of active validators during the deposit selection process
+    /// @param _operator The Operator structure in memory
+    /// @return The count of active validators for the operator
+    function _getActiveValidatorCountForDeposits(OperatorsV2.CachedOperator memory _operator)
+        internal
+        view
+        returns (uint256)
+    {
+        return (_operator.funded + _operator.picked) - _getStoppedValidatorsCount(_operator.index);
+    }
+
+    /// @notice Internal utility to retrieve _count or lower fundable keys
+    /// @dev The selection process starts by retrieving the full list of active operators with at least one fundable key.
+    /// @dev
+    /// @dev An operator is considered to have at least one fundable key when their staking limit is higher than their funded key count.
+    /// @dev
+    /// @dev    isFundable = operator.active && operator.limit > operator.funded
+    /// @dev
+    /// @dev The internal utility will loop on all operators and select the operator with the lowest active validator count.
+    /// @dev The active validator count is computed by subtracting the stopped validator count to the funded validator count.
+    /// @dev
+    /// @dev    activeValidatorCount = operator.funded - operator.stopped
+    /// @dev
+    /// @dev During the selection process, we keep in memory all previously selected operators and the number of given validators inside a field
+    /// @dev called picked that only exists on the CachedOperator structure in memory.
+    /// @dev
+    /// @dev    isFundable = operator.active && operator.limit > (operator.funded + operator.picked)
+    /// @dev    activeValidatorCount = (operator.funded + operator.picked) - operator.stopped
+    /// @dev
+    /// @dev When we reach the requested key count or when all available keys are used, we perform a final loop on all the operators and extract keys
+    /// @dev if any operator has a positive picked count. We then update the storage counters and return the arrays with the public keys and signatures.
+    /// @param _count Amount of keys required. Contract is expected to send _count or lower.
+    /// @return publicKeys An array of fundable public keys
+    /// @return signatures An array of signatures linked to the public keys
+    function _pickNextValidatorsToDepositFromActiveOperators(uint256 _count)
+        internal
+        returns (bytes[] memory publicKeys, bytes[] memory signatures)
+    {
+        (OperatorsV2.CachedOperator[] memory operators, uint256 fundableOperatorCount) = OperatorsV2.getAllFundable();
+
+        if (fundableOperatorCount == 0) {
+            return (new bytes[](0), new bytes[](0));
+        }
+
+        while (_count > 0) {
+            // loop on operators to find the first that has fundable keys, taking into account previous loop round attributions
+            uint256 selectedOperatorIndex = 0;
+            for (; selectedOperatorIndex < fundableOperatorCount;) {
+                if (_hasFundableKeys(operators[selectedOperatorIndex])) {
+                    break;
+                }
+                unchecked {
+                    ++selectedOperatorIndex;
+                }
+            }
+
+            // if we reach the end, we have allocated all keys
+            if (selectedOperatorIndex == fundableOperatorCount) {
+                break;
+            }
+
+            // we start from the next operator and we try to find one that has fundable keys but a lower (funded + picked) - stopped value
+            for (uint256 idx = selectedOperatorIndex + 1; idx < fundableOperatorCount;) {
+                if (
+                    _getActiveValidatorCountForDeposits(operators[idx])
+                        < _getActiveValidatorCountForDeposits(operators[selectedOperatorIndex])
+                        && _hasFundableKeys(operators[idx])
+                ) {
+                    selectedOperatorIndex = idx;
+                }
+                unchecked {
+                    ++idx;
+                }
+            }
+
+            // we take the smallest value between limit - (funded + picked), _requestedAmount and MAX_VALIDATOR_ATTRIBUTION_PER_ROUND
+            uint256 pickedKeyCount = LibUint256.min(
+                LibUint256.min(
+                    operators[selectedOperatorIndex].limit
+                        - (operators[selectedOperatorIndex].funded + operators[selectedOperatorIndex].picked),
+                    MAX_VALIDATOR_ATTRIBUTION_PER_ROUND
+                ),
+                _count
+            );
+
+            // we update the cached picked amount
+            operators[selectedOperatorIndex].picked += uint32(pickedKeyCount);
+
+            // we update the requested amount count
+            _count -= pickedKeyCount;
+        }
+
+        // we loop on all operators
+        for (uint256 idx = 0; idx < fundableOperatorCount; ++idx) {
+            // if we picked keys on any operator, we extract the keys from storage and concatenate them in the result
+            // we then update the funded value
+            if (operators[idx].picked > 0) {
+                (bytes[] memory _publicKeys, bytes[] memory _signatures) =
+                    ValidatorKeys.getKeys(operators[idx].index, operators[idx].funded, operators[idx].picked);
+                emit FundedValidatorKeys(operators[idx].index, _publicKeys, false);
+                publicKeys = _concatenateByteArrays(publicKeys, _publicKeys);
+                signatures = _concatenateByteArrays(signatures, _signatures);
+                (OperatorsV2.get(operators[idx].index)).funded += operators[idx].picked;
+            }
+        }
+    }
+
+    /// @notice Internal utility to get the count of active validators during the exit selection process
+    /// @param _operator The Operator structure in memory
+    /// @return The count of active validators for the operator
+    function _getActiveValidatorCountForExitRequests(OperatorsV2.CachedExitableOperator memory _operator)
+        internal
+        pure
+        returns (uint32)
+    {
+        return _operator.funded - (_operator.requestedExits + _operator.picked);
+    }
+
+    /// @notice Internal utility to pick the next validator counts to exit for every operator
+    /// @param _count The count of validators to request exits for
+    function _pickNextValidatorsToExitFromActiveOperators(uint256 _count) internal returns (uint256) {
+        (OperatorsV2.CachedExitableOperator[] memory operators, uint256 exitableOperatorCount) =
+            OperatorsV2.getAllExitable();
+
+        if (exitableOperatorCount == 0) {
+            return 0;
+        }
+
+        uint256 initialExitRequestDemand = _count;
+        uint256 totalRequestedExitsValue = TotalValidatorExitsRequested.get();
+        uint256 totalRequestedExitsCopy = totalRequestedExitsValue;
+
+        // we loop to find the highest count of active validators, the number of operators that have this amount and the second highest amount
+        while (_count > 0) {
+            uint32 highestActiveCount = 0;
+            uint32 secondHighestActiveCount = 0;
+            uint32 siblings = 0;
+
+            for (uint256 idx = 0; idx < exitableOperatorCount;) {
+                uint32 activeCount = _getActiveValidatorCountForExitRequests(operators[idx]);
+
+                if (activeCount == highestActiveCount) {
+                    ++siblings;
+                } else if (activeCount > highestActiveCount) {
+                    secondHighestActiveCount = highestActiveCount;
+                    highestActiveCount = activeCount;
+                    siblings = 1;
+                } else if (activeCount > secondHighestActiveCount) {
+                    secondHighestActiveCount = activeCount;
+                }
+
+                unchecked {
+                    ++idx;
+                }
+            }
+
+            // we exited all exitable validators
+            if (highestActiveCount == 0) {
+                break;
+            }
+            // The optimal amount is how much we should dispatch to all the operators with the highest count for them to get the same amount
+            // of active validators as the second highest count. We then take the minimum between this value and the total we need to exit
+            uint32 optimalTotalDispatchCount =
+                uint32(LibUint256.min((highestActiveCount - secondHighestActiveCount) * siblings, _count));
+
+            // We lookup the operators again to assign the exit requests
+            uint256 rest = optimalTotalDispatchCount % siblings;
+            uint32 baseExitRequestAmount = optimalTotalDispatchCount / siblings;
+            for (uint256 idx = 0; idx < exitableOperatorCount;) {
+                if (_getActiveValidatorCountForExitRequests(operators[idx]) == highestActiveCount) {
+                    uint32 additionalRequestedExits = baseExitRequestAmount + (rest > 0 ? 1 : 0);
+                    operators[idx].picked += additionalRequestedExits;
+                    if (rest > 0) {
+                        --rest;
+                    }
+                }
+                unchecked {
+                    ++idx;
+                }
+            }
+
+            totalRequestedExitsValue += optimalTotalDispatchCount;
+            _count -= optimalTotalDispatchCount;
+        }
+
+        // We loop over the operators and apply the change, also emit the exit request event
+        for (uint256 idx = 0; idx < exitableOperatorCount;) {
+            if (operators[idx].picked > 0) {
+                uint256 opIndex = operators[idx].index;
+                uint32 newRequestedExits = operators[idx].requestedExits + operators[idx].picked;
+
+                OperatorsV2.get(opIndex).requestedExits = newRequestedExits;
+                emit RequestedValidatorExits(opIndex, newRequestedExits);
+            }
+
+            unchecked {
+                ++idx;
+            }
+        }
+
+        if (totalRequestedExitsValue != totalRequestedExitsCopy) {
+            _setTotalValidatorExitsRequested(totalRequestedExitsCopy, totalRequestedExitsValue);
+        }
+
+        return initialExitRequestDemand - _count;
+    }
+
+    /// @notice Internal utility to set the total validator exits requested by the system
+    /// @param _currentValue The current value of the total validator exits requested
+    /// @param _newValue The new value of the total validator exits requested
+    function _setTotalValidatorExitsRequested(uint256 _currentValue, uint256 _newValue) internal {
+        TotalValidatorExitsRequested.set(_newValue);
+        emit SetTotalValidatorExitsRequested(_currentValue, _newValue);
+    }
+}
diff -ruN src/contracts/src/Oracle.1.sol contracts/src/Oracle.1.sol
--- src/contracts/src/Oracle.1.sol	1970-01-01 01:00:00
+++ contracts/src/Oracle.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,283 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "./interfaces/IRiver.1.sol";
+import "./interfaces/IOracle.1.sol";
+
+import "./Administrable.sol";
+import "./Initializable.sol";
+
+import "./state/shared/RiverAddress.sol";
+
+import "./state/oracle/LastEpochId.sol";
+import "./state/oracle/OracleMembers.sol";
+import "./state/oracle/Quorum.sol";
+import "./state/oracle/ReportsPositions.sol";
+
+/// @title Oracle (v1)
+/// @author Kiln
+/// @notice This contract handles the input from the allowed oracle members. Highly inspired by Lido's implementation.
+contract OracleV1 is IOracleV1, Initializable, Administrable {
+    modifier onlyAdminOrMember(address _oracleMember) {
+        if (msg.sender != _getAdmin() && msg.sender != _oracleMember) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+        _;
+    }
+
+    /// @inheritdoc IOracleV1
+    function initOracleV1(
+        address _riverAddress,
+        address _administratorAddress,
+        uint64 _epochsPerFrame,
+        uint64 _slotsPerEpoch,
+        uint64 _secondsPerSlot,
+        uint64 _genesisTime,
+        uint256 _annualAprUpperBound,
+        uint256 _relativeLowerBound
+    ) external init(0) {
+        _setAdmin(_administratorAddress);
+        RiverAddress.set(_riverAddress);
+        emit SetRiver(_riverAddress);
+        CLSpec.set(
+            CLSpec.CLSpecStruct({
+                epochsPerFrame: _epochsPerFrame,
+                slotsPerEpoch: _slotsPerEpoch,
+                secondsPerSlot: _secondsPerSlot,
+                genesisTime: _genesisTime,
+                epochsToAssumedFinality: 0
+            })
+        );
+        emit SetSpec(_epochsPerFrame, _slotsPerEpoch, _secondsPerSlot, _genesisTime);
+        ReportBounds.set(
+            ReportBounds.ReportBoundsStruct({
+                annualAprUpperBound: _annualAprUpperBound,
+                relativeLowerBound: _relativeLowerBound
+            })
+        );
+        emit SetBounds(_annualAprUpperBound, _relativeLowerBound);
+        Quorum.set(0);
+        emit SetQuorum(0);
+    }
+
+    /// @inheritdoc IOracleV1
+    function initOracleV1_1() external init(1) {
+        _clearReports();
+    }
+
+    /// @inheritdoc IOracleV1
+    function getRiver() external view returns (address) {
+        return RiverAddress.get();
+    }
+
+    /// @inheritdoc IOracleV1
+    function getMemberReportStatus(address _oracleMember) external view returns (bool) {
+        int256 memberIndex = OracleMembers.indexOf(_oracleMember);
+        return memberIndex != -1 && ReportsPositions.get(uint256(memberIndex));
+    }
+
+    /// @inheritdoc IOracleV1
+    function getGlobalReportStatus() external view returns (uint256) {
+        return ReportsPositions.getRaw();
+    }
+
+    /// @inheritdoc IOracleV1
+    function getReportVariantsCount() external view returns (uint256) {
+        return ReportsVariants.get().length;
+    }
+
+    /// @inheritdoc IOracleV1
+    function getReportVariantDetails(uint256 _idx)
+        external
+        view
+        returns (ReportsVariants.ReportVariantDetails memory)
+    {
+        if (ReportsVariants.get().length <= _idx) {
+            revert ReportIndexOutOfBounds(_idx, ReportsVariants.get().length);
+        }
+        return ReportsVariants.get()[_idx];
+    }
+
+    /// @inheritdoc IOracleV1
+    function getQuorum() external view returns (uint256) {
+        return Quorum.get();
+    }
+
+    /// @inheritdoc IOracleV1
+    function getOracleMembers() external view returns (address[] memory) {
+        return OracleMembers.get();
+    }
+
+    /// @inheritdoc IOracleV1
+    function isMember(address _memberAddress) external view returns (bool) {
+        return OracleMembers.indexOf(_memberAddress) >= 0;
+    }
+
+    /// @inheritdoc IOracleV1
+    function getLastReportedEpochId() external view returns (uint256) {
+        return LastEpochId.get();
+    }
+
+    /// @inheritdoc IOracleV1
+    function addMember(address _newOracleMember, uint256 _newQuorum) external onlyAdmin {
+        int256 memberIdx = OracleMembers.indexOf(_newOracleMember);
+        if (memberIdx >= 0) {
+            revert AddressAlreadyInUse(_newOracleMember);
+        }
+        OracleMembers.push(_newOracleMember);
+        uint256 previousQuorum = Quorum.get();
+        _clearReportsAndSetQuorum(_newQuorum, previousQuorum);
+        emit AddMember(_newOracleMember);
+    }
+
+    /// @inheritdoc IOracleV1
+    function removeMember(address _oracleMember, uint256 _newQuorum) external onlyAdmin {
+        int256 memberIdx = OracleMembers.indexOf(_oracleMember);
+        if (memberIdx < 0) {
+            revert LibErrors.InvalidCall();
+        }
+        OracleMembers.deleteItem(uint256(memberIdx));
+        uint256 previousQuorum = Quorum.get();
+        _clearReportsAndSetQuorum(_newQuorum, previousQuorum);
+        emit RemoveMember(_oracleMember);
+    }
+
+    /// @inheritdoc IOracleV1
+    function setMember(address _oracleMember, address _newAddress) external onlyAdminOrMember(_oracleMember) {
+        LibSanitize._notZeroAddress(_newAddress);
+        if (OracleMembers.indexOf(_newAddress) >= 0) {
+            revert AddressAlreadyInUse(_newAddress);
+        }
+        int256 memberIdx = OracleMembers.indexOf(_oracleMember);
+        if (memberIdx < 0) {
+            revert LibErrors.InvalidCall();
+        }
+        OracleMembers.set(uint256(memberIdx), _newAddress);
+        emit SetMember(_oracleMember, _newAddress);
+    }
+
+    /// @inheritdoc IOracleV1
+    function setQuorum(uint256 _newQuorum) external onlyAdmin {
+        uint256 previousQuorum = Quorum.get();
+        if (previousQuorum == _newQuorum) {
+            revert LibErrors.InvalidArgument();
+        }
+        _clearReportsAndSetQuorum(_newQuorum, previousQuorum);
+    }
+
+    /// @inheritdoc IOracleV1
+    function reportConsensusLayerData(IRiverV1.ConsensusLayerReport calldata _report) external {
+        // retrieve member index and revert if not oracle member
+        int256 memberIndex = OracleMembers.indexOf(msg.sender);
+        if (memberIndex == -1) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+
+        // store last reported epoch to stack
+        uint256 lastReportedEpochValue = LastEpochId.get();
+
+        // checks that the report epoch is not too old
+        if (_report.epoch < lastReportedEpochValue) {
+            revert EpochTooOld(_report.epoch, LastEpochId.get());
+        }
+        IRiverV1 river = IRiverV1(payable(RiverAddress.get()));
+        // checks that the report epoch is not invalid
+        if (!river.isValidEpoch(_report.epoch)) {
+            revert InvalidEpoch(_report.epoch);
+        }
+        // if valid and greater than the lastReportedEpoch, we clear the reporting data
+        if (_report.epoch > lastReportedEpochValue) {
+            _clearReports();
+            LastEpochId.set(_report.epoch);
+            emit SetLastReportedEpoch(_report.epoch);
+        }
+        // we retrieve the voting status of the caller, and revert if already voted
+        if (ReportsPositions.get(uint256(memberIndex))) {
+            revert AlreadyReported(_report.epoch, msg.sender);
+        }
+        // we register the caller
+        ReportsPositions.register(uint256(memberIndex));
+
+        // we compute the variant by hashing the report
+        bytes32 variant = _reportChecksum(_report);
+        // we retrieve the details for the given variant
+        (int256 variantIndex, uint256 variantVotes) = _getReportVariantIndexAndVotes(variant);
+        // we retrieve the quorum to stack
+        uint256 quorum = Quorum.get();
+
+        emit ReportedConsensusLayerData(msg.sender, variant, _report, variantVotes + 1, quorum);
+
+        // if adding this vote reaches quorum
+        if (variantVotes + 1 >= quorum) {
+            // we clear the reporting data
+            _clearReports();
+            // we increment the lastReportedEpoch to force reports to be on the last frame
+            LastEpochId.set(_report.epoch + 1);
+            // we push the report to river
+            river.setConsensusLayerData(_report);
+            emit SetLastReportedEpoch(_report.epoch + 1);
+        } else if (variantVotes == 0) {
+            // if we have no votes for the variant, we create the variant details
+            ReportsVariants.push(ReportsVariants.ReportVariantDetails({variant: variant, votes: 1}));
+        } else {
+            // otherwise we increment the vote
+            ReportsVariants.get()[uint256(variantIndex)].votes += 1;
+        }
+    }
+
+    /// @notice Internal utility to clear all the reports and edit the quorum if a new value is provided
+    /// @dev Ensures that the quorum respects invariants
+    /// @dev The admin is in charge of providing a proper quorum based on the oracle member count
+    /// @dev The quorum value Q should respect the following invariant, where O is oracle member count
+    /// @dev (O / 2) + 1 <= Q <= O
+    /// @param _newQuorum New quorum value
+    /// @param _previousQuorum The old quorum value
+    function _clearReportsAndSetQuorum(uint256 _newQuorum, uint256 _previousQuorum) internal {
+        uint256 memberCount = OracleMembers.get().length;
+        if ((_newQuorum == 0 && memberCount > 0) || _newQuorum > memberCount) {
+            revert LibErrors.InvalidArgument();
+        }
+        _clearReports();
+        if (_newQuorum != _previousQuorum) {
+            Quorum.set(_newQuorum);
+            emit SetQuorum(_newQuorum);
+        }
+    }
+
+    /// @notice Internal utility to hash and retrieve the variant id of a report
+    /// @param _report The reported data structure
+    /// @return The report variant
+    function _reportChecksum(IRiverV1.ConsensusLayerReport calldata _report) internal pure returns (bytes32) {
+        return keccak256(abi.encode(_report));
+    }
+
+    /// @notice Internal utility to clear all reporting details
+    function _clearReports() internal {
+        ReportsVariants.clear();
+        ReportsPositions.clear();
+        emit ClearedReporting();
+    }
+
+    /// @notice Internal utility to retrieve index and vote count for a given variant
+    /// @param _variant The variant to lookup
+    /// @return The index of the variant, -1 if not found
+    /// @return The vote count of the variant
+    function _getReportVariantIndexAndVotes(bytes32 _variant) internal view returns (int256, uint256) {
+        uint256 reportVariantsLength = ReportsVariants.get().length;
+        for (uint256 idx = 0; idx < reportVariantsLength;) {
+            if (ReportsVariants.get()[idx].variant == _variant) {
+                return (int256(idx), ReportsVariants.get()[idx].votes);
+            }
+            unchecked {
+                ++idx;
+            }
+        }
+        return (-1, 0);
+    }
+
+    /// @notice Internal utility to retrieve a casted River interface
+    /// @return The casted River interface
+    function _river() internal view returns (IRiverV1) {
+        return IRiverV1(payable(RiverAddress.get()));
+    }
+}
diff -ruN src/contracts/src/RedeemManager.1.sol contracts/src/RedeemManager.1.sol
--- src/contracts/src/RedeemManager.1.sol	1970-01-01 01:00:00
+++ contracts/src/RedeemManager.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,537 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "./interfaces/IAllowlist.1.sol";
+import "./interfaces/IRiver.1.sol";
+import "./interfaces/IRedeemManager.1.sol";
+import "./libraries/LibAllowlistMasks.sol";
+import "./libraries/LibUint256.sol";
+import "./Initializable.sol";
+
+import "./state/shared/RiverAddress.sol";
+import "./state/redeemManager/RedeemQueue.sol";
+import "./state/redeemManager/WithdrawalStack.sol";
+import "./state/redeemManager/BufferedExceedingEth.sol";
+import "./state/redeemManager/RedeemDemand.sol";
+
+/// @title Redeem Manager (v1)
+/// @author Kiln
+/// @notice This contract handles the redeem requests of all users
+contract RedeemManagerV1 is Initializable, IRedeemManagerV1 {
+    /// @notice Value returned when resolving a redeem request that is unsatisfied
+    int64 internal constant RESOLVE_UNSATISFIED = -1;
+    /// @notice Value returned when resolving a redeem request that is out of bounds
+    int64 internal constant RESOLVE_OUT_OF_BOUNDS = -2;
+    /// @notice Value returned when resolving a redeem request that is already claimed
+    int64 internal constant RESOLVE_FULLY_CLAIMED = -3;
+
+    /// @notice Status value returned when fully claiming a redeem request
+    uint8 internal constant CLAIM_FULLY_CLAIMED = 0;
+    /// @notice Status value returned when partially claiming a redeem request
+    uint8 internal constant CLAIM_PARTIALLY_CLAIMED = 1;
+    /// @notice Status value returned when a redeem request is already claimed and skipped during a claim
+    uint8 internal constant CLAIM_SKIPPED = 2;
+
+    modifier onlyRiver() {
+        if (msg.sender != RiverAddress.get()) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+        _;
+    }
+
+    modifier onlyRedeemerOrRiver() {
+        {
+            IRiverV1 river = _castedRiver();
+            if (msg.sender != address(river)) {
+                IAllowlistV1(river.getAllowlist()).onlyAllowed(msg.sender, LibAllowlistMasks.REDEEM_MASK);
+            }
+        }
+        _;
+    }
+
+    modifier onlyRedeemer() {
+        {
+            IRiverV1 river = _castedRiver();
+            IAllowlistV1(river.getAllowlist()).onlyAllowed(msg.sender, LibAllowlistMasks.REDEEM_MASK);
+        }
+        _;
+    }
+
+    /// @inheritdoc IRedeemManagerV1
+    function initializeRedeemManagerV1(address _river) external init(0) {
+        RiverAddress.set(_river);
+        emit SetRiver(_river);
+    }
+
+    /// @inheritdoc IRedeemManagerV1
+    function getRiver() external view returns (address) {
+        return RiverAddress.get();
+    }
+
+    /// @inheritdoc IRedeemManagerV1
+    function getRedeemRequestCount() external view returns (uint256) {
+        return RedeemQueue.get().length;
+    }
+
+    /// @inheritdoc IRedeemManagerV1
+    function getRedeemRequestDetails(uint32 _redeemRequestId)
+        external
+        view
+        returns (RedeemQueue.RedeemRequest memory)
+    {
+        return RedeemQueue.get()[_redeemRequestId];
+    }
+
+    /// @inheritdoc IRedeemManagerV1
+    function getWithdrawalEventCount() external view returns (uint256) {
+        return WithdrawalStack.get().length;
+    }
+
+    /// @inheritdoc IRedeemManagerV1
+    function getWithdrawalEventDetails(uint32 _withdrawalEventId)
+        external
+        view
+        returns (WithdrawalStack.WithdrawalEvent memory)
+    {
+        return WithdrawalStack.get()[_withdrawalEventId];
+    }
+
+    /// @inheritdoc IRedeemManagerV1
+    function getBufferedExceedingEth() external view returns (uint256) {
+        return BufferedExceedingEth.get();
+    }
+
+    /// @inheritdoc IRedeemManagerV1
+    function getRedeemDemand() external view returns (uint256) {
+        return RedeemDemand.get();
+    }
+
+    /// @inheritdoc IRedeemManagerV1
+    function resolveRedeemRequests(uint32[] calldata _redeemRequestIds)
+        external
+        view
+        returns (int64[] memory withdrawalEventIds)
+    {
+        withdrawalEventIds = new int64[](_redeemRequestIds.length);
+        WithdrawalStack.WithdrawalEvent memory lastWithdrawalEvent;
+        WithdrawalStack.WithdrawalEvent[] storage withdrawalEvents = WithdrawalStack.get();
+        uint256 withdrawalEventsLength = withdrawalEvents.length;
+        if (withdrawalEventsLength > 0) {
+            lastWithdrawalEvent = withdrawalEvents[withdrawalEventsLength - 1];
+        }
+        for (uint256 idx = 0; idx < _redeemRequestIds.length; ++idx) {
+            withdrawalEventIds[idx] = _resolveRedeemRequestId(_redeemRequestIds[idx], lastWithdrawalEvent);
+        }
+    }
+
+    /// @inheritdoc IRedeemManagerV1
+    function requestRedeem(uint256 _lsETHAmount, address _recipient)
+        external
+        onlyRedeemerOrRiver
+        returns (uint32 redeemRequestId)
+    {
+        return _requestRedeem(_lsETHAmount, _recipient);
+    }
+
+    /// @inheritdoc IRedeemManagerV1
+    function requestRedeem(uint256 _lsETHAmount) external onlyRedeemer returns (uint32 redeemRequestId) {
+        return _requestRedeem(_lsETHAmount, msg.sender);
+    }
+
+    /// @inheritdoc IRedeemManagerV1
+    function claimRedeemRequests(
+        uint32[] calldata redeemRequestIds,
+        uint32[] calldata withdrawalEventIds,
+        bool skipAlreadyClaimed,
+        uint16 _depth
+    ) external returns (uint8[] memory claimStatuses) {
+        return _claimRedeemRequests(redeemRequestIds, withdrawalEventIds, skipAlreadyClaimed, _depth);
+    }
+
+    /// @inheritdoc IRedeemManagerV1
+    function claimRedeemRequests(uint32[] calldata _redeemRequestIds, uint32[] calldata _withdrawalEventIds)
+        external
+        returns (uint8[] memory claimStatuses)
+    {
+        return _claimRedeemRequests(_redeemRequestIds, _withdrawalEventIds, true, type(uint16).max);
+    }
+
+    /// @inheritdoc IRedeemManagerV1
+    function reportWithdraw(uint256 _lsETHWithdrawable) external payable onlyRiver {
+        uint256 redeemDemand = RedeemDemand.get();
+        if (_lsETHWithdrawable > redeemDemand) {
+            revert WithdrawalExceedsRedeemDemand(_lsETHWithdrawable, redeemDemand);
+        }
+        WithdrawalStack.WithdrawalEvent[] storage withdrawalEvents = WithdrawalStack.get();
+        uint32 withdrawalEventId = uint32(withdrawalEvents.length);
+        uint256 height = 0;
+        uint256 msgValue = msg.value;
+        if (withdrawalEventId != 0) {
+            WithdrawalStack.WithdrawalEvent memory previousWithdrawalEvent = withdrawalEvents[withdrawalEventId - 1];
+            height = previousWithdrawalEvent.height + previousWithdrawalEvent.amount;
+        }
+        withdrawalEvents.push(
+            WithdrawalStack.WithdrawalEvent({height: height, amount: _lsETHWithdrawable, withdrawnEth: msgValue})
+        );
+        _setRedeemDemand(redeemDemand - _lsETHWithdrawable);
+        emit ReportedWithdrawal(height, _lsETHWithdrawable, msgValue, withdrawalEventId);
+    }
+
+    /// @inheritdoc IRedeemManagerV1
+    function pullExceedingEth(uint256 _max) external onlyRiver {
+        uint256 amountToSend = LibUint256.min(BufferedExceedingEth.get(), _max);
+        if (amountToSend > 0) {
+            BufferedExceedingEth.set(BufferedExceedingEth.get() - amountToSend);
+            _castedRiver().sendRedeemManagerExceedingFunds{value: amountToSend}();
+        }
+    }
+
+    /// @notice Internal utility to load and cast the River address
+    /// @return The casted river address
+    function _castedRiver() internal view returns (IRiverV1) {
+        return IRiverV1(payable(RiverAddress.get()));
+    }
+
+    /// @notice Internal utility to verify if a redeem request and a withdrawal event are matching
+    /// @param _redeemRequest The loaded redeem request
+    /// @param _withdrawalEvent The load withdrawal event
+    /// @return True if matching
+    function _isMatch(
+        RedeemQueue.RedeemRequest memory _redeemRequest,
+        WithdrawalStack.WithdrawalEvent memory _withdrawalEvent
+    ) internal pure returns (bool) {
+        return (
+            _redeemRequest.height < _withdrawalEvent.height + _withdrawalEvent.amount
+                && _redeemRequest.height >= _withdrawalEvent.height
+        );
+    }
+
+    /// @notice Internal utility to perform a dichotomic search of the withdrawal event to use to claim the redeem request
+    /// @param _redeemRequest The redeem request to resolve
+    /// @return The matching withdrawal event
+    function _performDichotomicResolution(RedeemQueue.RedeemRequest memory _redeemRequest)
+        internal
+        view
+        returns (int64)
+    {
+        WithdrawalStack.WithdrawalEvent[] storage withdrawalEvents = WithdrawalStack.get();
+
+        int64 max = int64(int256(WithdrawalStack.get().length - 1));
+
+        if (_isMatch(_redeemRequest, withdrawalEvents[uint64(max)])) {
+            return max;
+        }
+
+        int64 min = 0;
+
+        if (_isMatch(_redeemRequest, withdrawalEvents[uint64(min)])) {
+            return min;
+        }
+
+        // we start a dichotomic search between min and max
+        while (min != max) {
+            int64 mid = (min + max) / 2;
+
+            // we identify and verify that the middle element is not matching
+            WithdrawalStack.WithdrawalEvent memory midWithdrawalEvent = withdrawalEvents[uint64(mid)];
+            if (_isMatch(_redeemRequest, midWithdrawalEvent)) {
+                return mid;
+            }
+
+            // depending on the position of the middle element, we update max or min to get our min max range
+            // closer to our redeem request position
+            if (_redeemRequest.height < midWithdrawalEvent.height) {
+                max = mid;
+            } else {
+                min = mid;
+            }
+        }
+        return min;
+    }
+
+    /// @notice Internal utility to resolve a redeem request and retrieve its satisfying withdrawal event id, or identify possible errors
+    /// @param _redeemRequestId The redeem request id
+    /// @param _lastWithdrawalEvent The last withdrawal event loaded in memory
+    /// @return withdrawalEventId The id of the withdrawal event matching the redeem request or error code
+    function _resolveRedeemRequestId(
+        uint32 _redeemRequestId,
+        WithdrawalStack.WithdrawalEvent memory _lastWithdrawalEvent
+    ) internal view returns (int64 withdrawalEventId) {
+        RedeemQueue.RedeemRequest[] storage redeemRequests = RedeemQueue.get();
+        // if the redeem request id is >= than the size of requests, we know it's out of bounds and doesn't exist
+        if (_redeemRequestId >= redeemRequests.length) {
+            return RESOLVE_OUT_OF_BOUNDS;
+        }
+        RedeemQueue.RedeemRequest memory redeemRequest = redeemRequests[_redeemRequestId];
+        // if the redeem request remaining amount is 0, we know that the request has been entirely claimed
+        if (redeemRequest.amount == 0) {
+            return RESOLVE_FULLY_CLAIMED;
+        }
+        // if there are no existing withdrawal events or if the height of the redeem request is higher than the height and
+        // amount of the last withdrawal element, we know that the redeem request is not yet satisfied
+        if (
+            WithdrawalStack.get().length == 0
+                || (_lastWithdrawalEvent.height + _lastWithdrawalEvent.amount) <= redeemRequest.height
+        ) {
+            return RESOLVE_UNSATISFIED;
+        }
+        // we know for sure that the redeem request has funds yet to be claimed and there is a withdrawal event we need to identify
+        // that would allow the user to claim the redeem request
+        return _performDichotomicResolution(redeemRequest);
+    }
+
+    /// @notice Perform a new redeem request for the specified recipient
+    /// @param _lsETHAmount The amount of LsETH to redeem
+    /// @param _recipient The recipient owning the request
+    /// @return redeemRequestId The id of the newly created redeem request
+    function _requestRedeem(uint256 _lsETHAmount, address _recipient) internal returns (uint32 redeemRequestId) {
+        LibSanitize._notZeroAddress(_recipient);
+        if (_lsETHAmount == 0) {
+            revert InvalidZeroAmount();
+        }
+        if (!_castedRiver().transferFrom(msg.sender, address(this), _lsETHAmount)) {
+            revert TransferError();
+        }
+        RedeemQueue.RedeemRequest[] storage redeemRequests = RedeemQueue.get();
+        redeemRequestId = uint32(redeemRequests.length);
+        uint256 height = 0;
+        if (redeemRequestId != 0) {
+            RedeemQueue.RedeemRequest memory previousRedeemRequest = redeemRequests[redeemRequestId - 1];
+            height = previousRedeemRequest.height + previousRedeemRequest.amount;
+        }
+
+        uint256 maxRedeemableEth = _castedRiver().underlyingBalanceFromShares(_lsETHAmount);
+
+        redeemRequests.push(
+            RedeemQueue.RedeemRequest({
+                height: height,
+                amount: _lsETHAmount,
+                owner: _recipient,
+                maxRedeemableEth: maxRedeemableEth
+            })
+        );
+
+        _setRedeemDemand(RedeemDemand.get() + _lsETHAmount);
+
+        emit RequestedRedeem(_recipient, height, _lsETHAmount, maxRedeemableEth, redeemRequestId);
+    }
+
+    /// @notice Internal structure used to optimize stack usage in _claimRedeemRequest
+    struct ClaimRedeemRequestParameters {
+        /// @custom:attribute The id of the redeem request to claim
+        uint32 redeemRequestId;
+        /// @custom:attribute The structure of the redeem request to claim
+        RedeemQueue.RedeemRequest redeemRequest;
+        /// @custom:attribute The id of the withdrawal event to use to claim the redeem request
+        uint32 withdrawalEventId;
+        /// @custom:attribute The structure of the withdrawal event to use to claim the redeem request
+        WithdrawalStack.WithdrawalEvent withdrawalEvent;
+        /// @custom:attribute The count of withdrawal events
+        uint32 withdrawalEventCount;
+        /// @custom:attribute The current depth of the recursive call
+        uint16 depth;
+        /// @custom:attribute The amount of LsETH redeemed/matched, needs to be reset to 0 for each call/before calling the recursive function
+        uint256 lsETHAmount;
+        /// @custom:attribute The amount of eth redeemed/matched, needs to be rest to 0 for each call/before calling the recursive function
+        uint256 ethAmount;
+    }
+
+    /// @notice Internal structure used to optimize stack usage in _claimRedeemRequest
+    struct ClaimRedeemRequestInternalVariables {
+        /// @custom:attribute The eth amount claimed by the user
+        uint256 ethAmount;
+        /// @custom:attribute The amount of LsETH matched during this step
+        uint256 matchingAmount;
+        /// @custom:attribute The amount of eth redirected to the exceeding eth buffer
+        uint256 exceedingEthAmount;
+    }
+
+    /// @notice Internal utility to save a redeem request to storage
+    /// @param _params The parameters of the claim redeem request call
+    function _saveRedeemRequest(ClaimRedeemRequestParameters memory _params) internal {
+        RedeemQueue.RedeemRequest[] storage redeemRequests = RedeemQueue.get();
+        redeemRequests[_params.redeemRequestId].height = _params.redeemRequest.height;
+        redeemRequests[_params.redeemRequestId].amount = _params.redeemRequest.amount;
+        redeemRequests[_params.redeemRequestId].maxRedeemableEth = _params.redeemRequest.maxRedeemableEth;
+    }
+
+    /// @notice Internal utility to claim a redeem request if possible
+    /// @dev Will call itself recursively if the redeem requests overflows its matching withdrawal event
+    /// @param _params The parameters of the claim redeem request call
+    function _claimRedeemRequest(ClaimRedeemRequestParameters memory _params) internal {
+        ClaimRedeemRequestInternalVariables memory vars;
+        {
+            uint256 withdrawalEventEndPosition = _params.withdrawalEvent.height + _params.withdrawalEvent.amount;
+
+            // it can occur that the redeem request is overlapping the provided withdrawal event
+            // the amount that is matched in the withdrawal event is adapted depending on this
+            vars.matchingAmount =
+                LibUint256.min(_params.redeemRequest.amount, withdrawalEventEndPosition - _params.redeemRequest.height);
+            // we can now compute the equivalent eth amount based on the withdrawal event details
+            vars.ethAmount =
+                mulDivDown(vars.matchingAmount, _params.withdrawalEvent.withdrawnEth, _params.withdrawalEvent.amount);
+                // (vars.matchingAmount * _params.withdrawalEvent.withdrawnEth) / _params.withdrawalEvent.amount; // Munged by Certora
+
+            // as each request has a maximum withdrawable amount, we verify that the eth amount is not exceeding this amount, pro rata
+            // the amount that is matched
+            uint256 maxRedeemableEthAmount =
+                mulDivDown(vars.matchingAmount, _params.redeemRequest.maxRedeemableEth, _params.redeemRequest.amount);
+                // (vars.matchingAmount * _params.redeemRequest.maxRedeemableEth) / _params.redeemRequest.amount; // Munged by Certora
+
+            if (maxRedeemableEthAmount < vars.ethAmount) {
+                vars.exceedingEthAmount = vars.ethAmount - maxRedeemableEthAmount;
+                BufferedExceedingEth.set(BufferedExceedingEth.get() + vars.exceedingEthAmount);
+                vars.ethAmount = maxRedeemableEthAmount;
+            }
+
+            // height and amount are updated to reflect the amount that was matched.
+            // we will always keep this invariant true oldRequest.height + oldRequest.amount == newRequest.height + newRequest.amount
+            // this also means that if the request wasn't entirely matched, it will now be automatically be assigned to the next
+            // withdrawal event in the queue, because height is updated based on the amount matched and is now equal to the height
+            // of the next withdrawal event
+            // the end position of a redeem request (height + amount) is an invariant that never changes throughout the lifetime of a request
+            // this end position is used to define the starting position of the next redeem request
+            _params.redeemRequest.height += vars.matchingAmount;
+            _params.redeemRequest.amount -= vars.matchingAmount;
+            _params.redeemRequest.maxRedeemableEth -= vars.ethAmount;
+
+            _params.lsETHAmount += vars.matchingAmount;
+            _params.ethAmount += vars.ethAmount;
+
+            // this event signals that an amount has been matched from a redeem request on a withdrawal event
+            // this event can be triggered several times for the same redeem request, depending on its size and
+            // how many withdrawal events it overlaps.
+            emit SatisfiedRedeemRequest(
+                _params.redeemRequestId,
+                _params.withdrawalEventId,
+                vars.matchingAmount,
+                vars.ethAmount,
+                _params.redeemRequest.amount,
+                vars.exceedingEthAmount
+            );
+        }
+
+        // in the case where we haven't claimed all the redeem request AND that there are other withdrawal events
+        // available next in the stack, we load the next withdrawal event and call this method recursively
+        // also we stop the claim process if the claim depth is about to be 0
+        if (
+            _params.redeemRequest.amount > 0 && _params.withdrawalEventId + 1 < _params.withdrawalEventCount
+                && _params.depth > 0
+        ) {
+            WithdrawalStack.WithdrawalEvent[] storage withdrawalEvents = WithdrawalStack.get();
+
+            ++_params.withdrawalEventId;
+            _params.withdrawalEvent = withdrawalEvents[_params.withdrawalEventId];
+            --_params.depth;
+
+            _claimRedeemRequest(_params);
+        } else {
+            // if we end up here, we either claimed everything or we reached the end of the withdrawal event stack
+            // in this case we save the current redeem request state to storage and return the status according to the
+            // remaining claimable amount on the redeem request
+            _saveRedeemRequest(_params);
+        }
+    }
+
+    /// @notice Internal utility to claim several redeem requests at once
+    /// @param _redeemRequestIds The list of redeem requests to claim
+    /// @param _withdrawalEventIds The list of withdrawal events to use for each redeem request. Should have the same length.
+    /// @param _skipAlreadyClaimed True if the system should skip redeem requests already claimed, otherwise will revert
+    /// @param _depth The depth of the recursion to use when claiming a redeem request
+    /// @return claimStatuses The claim statuses for each redeem request
+    function _claimRedeemRequests(
+        uint32[] calldata _redeemRequestIds,
+        uint32[] calldata _withdrawalEventIds,
+        bool _skipAlreadyClaimed,
+        uint16 _depth
+    ) internal returns (uint8[] memory claimStatuses) {
+        uint256 redeemRequestIdsLength = _redeemRequestIds.length;
+        if (redeemRequestIdsLength != _withdrawalEventIds.length) {
+            revert IncompatibleArrayLengths();
+        }
+        claimStatuses = new uint8[](redeemRequestIdsLength);
+
+        RedeemQueue.RedeemRequest[] storage redeemRequests = RedeemQueue.get();
+        WithdrawalStack.WithdrawalEvent[] storage withdrawalEvents = WithdrawalStack.get();
+
+        ClaimRedeemRequestParameters memory params;
+        params.withdrawalEventCount = uint32(withdrawalEvents.length);
+        uint32 redeemRequestCount = uint32(redeemRequests.length);
+
+        for (uint256 idx = 0; idx < redeemRequestIdsLength;) {
+            // both ids are loaded into params
+            params.redeemRequestId = _redeemRequestIds[idx];
+            params.withdrawalEventId = _withdrawalEventIds[idx];
+
+            // we start by checking that the id is not out of bounds for the redeem requests
+            if (params.redeemRequestId >= redeemRequestCount) {
+                revert RedeemRequestOutOfBounds(params.redeemRequestId);
+            }
+
+            // we check that the withdrawal event id is not out of bounds
+            if (params.withdrawalEventId >= params.withdrawalEventCount) {
+                revert WithdrawalEventOutOfBounds(params.withdrawalEventId);
+            }
+
+            // we load the redeem request in memory
+            params.redeemRequest = redeemRequests[_redeemRequestIds[idx]];
+
+            // we check that the redeem request is not already claimed
+            if (params.redeemRequest.amount == 0) {
+                if (_skipAlreadyClaimed) {
+                    claimStatuses[idx] = CLAIM_SKIPPED;
+                    unchecked {
+                        ++idx;
+                    }
+                    continue;
+                }
+                revert RedeemRequestAlreadyClaimed(params.redeemRequestId);
+            }
+
+            // we load the withdrawal event in memory
+            params.withdrawalEvent = withdrawalEvents[_withdrawalEventIds[idx]];
+
+            // now that both entities are loaded in memory, we verify that they indeed match, otherwise we revert
+            if (!_isMatch(params.redeemRequest, params.withdrawalEvent)) {
+                revert DoesNotMatch(params.redeemRequestId, params.withdrawalEventId);
+            }
+
+            params.depth = _depth;
+            params.ethAmount = 0;
+            params.lsETHAmount = 0;
+
+            _claimRedeemRequest(params);
+
+            claimStatuses[idx] = params.redeemRequest.amount == 0 ? CLAIM_FULLY_CLAIMED : CLAIM_PARTIALLY_CLAIMED;
+
+            {
+                (bool success, bytes memory rdata) = params.redeemRequest.owner.call{value: params.ethAmount}("");
+                if (!success) {
+                    revert ClaimRedeemFailed(params.redeemRequest.owner, rdata);
+                }
+            }
+            emit ClaimedRedeemRequest(
+                _redeemRequestIds[idx],
+                params.redeemRequest.owner,
+                params.ethAmount,
+                params.lsETHAmount,
+                params.redeemRequest.amount
+            );
+
+            unchecked {
+                ++idx;
+            }
+        }
+    }
+
+    /// @notice Internal utility to set the redeem demand
+    /// @param _newValue The new value to set
+    function _setRedeemDemand(uint256 _newValue) internal {
+        emit SetRedeemDemand(RedeemDemand.get(), _newValue);
+        RedeemDemand.set(_newValue);
+    }
+
+    function mulDivDown(uint256 a, uint256 b, uint256 c) internal pure returns (uint256 res) {
+            res = a * b / c;
+    }
+}
diff -ruN src/contracts/src/River.1.sol contracts/src/River.1.sol
--- src/contracts/src/River.1.sol	1970-01-01 01:00:00
+++ contracts/src/River.1.sol	2024-01-16 15:19:47
@@ -0,0 +1,616 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "./interfaces/IAllowlist.1.sol";
+import "./interfaces/IOperatorRegistry.1.sol";
+import "./interfaces/IRiver.1.sol";
+import "./interfaces/IWithdraw.1.sol";
+import "./interfaces/IELFeeRecipient.1.sol";
+import "./interfaces/ICoverageFund.1.sol";
+
+import "./components/ConsensusLayerDepositManager.1.sol";
+import "./components/UserDepositManager.1.sol";
+import "./components/SharesManager.1.sol";
+import "./components/OracleManager.1.sol";
+import "./Initializable.sol";
+import "./Administrable.sol";
+
+import "./libraries/LibAllowlistMasks.sol";
+
+import "./state/river/AllowlistAddress.sol";
+import "./state/river/RedeemManagerAddress.sol";
+import "./state/river/OperatorsRegistryAddress.sol";
+import "./state/river/CollectorAddress.sol";
+import "./state/river/ELFeeRecipientAddress.sol";
+import "./state/river/CoverageFundAddress.sol";
+import "./state/river/BalanceToRedeem.sol";
+import "./state/river/GlobalFee.sol";
+import "./state/river/MetadataURI.sol";
+import "./state/river/LastConsensusLayerReport.sol";
+
+// munged by certora
+// interface ICVL {
+//     function increment_onDepositCounter() external view returns(bool);
+// }
+
+/// @title River (v1)
+/// @author Kiln
+/// @notice This contract merges all the manager contracts and implements all the virtual methods stitching all components together
+contract RiverV1 is
+    ConsensusLayerDepositManagerV1,
+    UserDepositManagerV1,
+    SharesManagerV1,
+    OracleManagerV1,
+    Initializable,
+    Administrable,
+    IRiverV1
+{
+    /// @inheritdoc IRiverV1
+    function initRiverV1(
+        address _depositContractAddress,
+        address _elFeeRecipientAddress,
+        bytes32 _withdrawalCredentials,
+        address _oracleAddress,
+        address _systemAdministratorAddress,
+        address _allowlistAddress,
+        address _operatorRegistryAddress,
+        address _collectorAddress,
+        uint256 _globalFee
+    ) external init(0) {
+        _setAdmin(_systemAdministratorAddress);
+
+        CollectorAddress.set(_collectorAddress);
+        emit SetCollector(_collectorAddress);
+
+        GlobalFee.set(_globalFee);
+        emit SetGlobalFee(_globalFee);
+
+        ELFeeRecipientAddress.set(_elFeeRecipientAddress);
+        emit SetELFeeRecipient(_elFeeRecipientAddress);
+
+        AllowlistAddress.set(_allowlistAddress);
+        emit SetAllowlist(_allowlistAddress);
+
+        OperatorsRegistryAddress.set(_operatorRegistryAddress);
+        emit SetOperatorsRegistry(_operatorRegistryAddress);
+
+        ConsensusLayerDepositManagerV1.initConsensusLayerDepositManagerV1(
+            _depositContractAddress, _withdrawalCredentials
+        );
+
+        OracleManagerV1.initOracleManagerV1(_oracleAddress);
+    }
+
+    /// @inheritdoc IRiverV1
+    function initRiverV1_1(
+        address _redeemManager,
+        uint64 _epochsPerFrame,
+        uint64 _slotsPerEpoch,
+        uint64 _secondsPerSlot,
+        uint64 _genesisTime,
+        uint64 _epochsToAssumedFinality,
+        uint256 _annualAprUpperBound,
+        uint256 _relativeLowerBound,
+        uint128 _minDailyNetCommittableAmount_,
+        uint128 _maxDailyRelativeCommittableAmount_
+    ) external init(1) {
+        RedeemManagerAddress.set(_redeemManager);
+        emit SetRedeemManager(_redeemManager);
+
+        _setDailyCommittableLimits(
+            DailyCommittableLimits.DailyCommittableLimitsStruct({
+                minDailyNetCommittableAmount: _minDailyNetCommittableAmount_,
+                maxDailyRelativeCommittableAmount: _maxDailyRelativeCommittableAmount_
+            })
+        );
+
+        initOracleManagerV1_1(
+            _epochsPerFrame,
+            _slotsPerEpoch,
+            _secondsPerSlot,
+            _genesisTime,
+            _epochsToAssumedFinality,
+            _annualAprUpperBound,
+            _relativeLowerBound
+        );
+
+        _approve(address(this), _redeemManager, type(uint256).max);
+    }
+
+    /// @inheritdoc IRiverV1
+    function initRiverV1_2() external init(2) {
+        // force committed balance to a multiple of 32 ETH and
+        // move extra funds back to the deposit buffer
+        uint256 dustToUncommit = CommittedBalance.get() % DEPOSIT_SIZE;
+        _setCommittedBalance(CommittedBalance.get() - dustToUncommit);
+        _setBalanceToDeposit(BalanceToDeposit.get() + dustToUncommit);
+    }
+
+    /// @inheritdoc IRiverV1
+    function getGlobalFee() external view returns (uint256) {
+        return GlobalFee.get();
+    }
+
+    /// @inheritdoc IRiverV1
+    function getAllowlist() external view returns (address) {
+        return AllowlistAddress.get();
+    }
+
+    /// @inheritdoc IRiverV1
+    function getCollector() external view returns (address) {
+        return CollectorAddress.get();
+    }
+
+    /// @inheritdoc IRiverV1
+    function getELFeeRecipient() external view returns (address) {
+        return ELFeeRecipientAddress.get();
+    }
+
+    /// @inheritdoc IRiverV1
+    function getCoverageFund() external view returns (address) {
+        return CoverageFundAddress.get();
+    }
+
+    /// @inheritdoc IRiverV1
+    function getRedeemManager() external view returns (address) {
+        return RedeemManagerAddress.get();
+    }
+
+    /// @inheritdoc IRiverV1
+    function getMetadataURI() external view returns (string memory) {
+        return MetadataURI.get();
+    }
+
+    /// @inheritdoc IRiverV1
+    function getDailyCommittableLimits()
+        external
+        view
+        returns (DailyCommittableLimits.DailyCommittableLimitsStruct memory)
+    {
+        return DailyCommittableLimits.get();
+    }
+
+    /// @inheritdoc IRiverV1
+    function setDailyCommittableLimits(DailyCommittableLimits.DailyCommittableLimitsStruct memory _dcl)
+        external
+        onlyAdmin
+    {
+        _setDailyCommittableLimits(_dcl);
+    }
+
+    /// @inheritdoc IRiverV1
+    function getBalanceToRedeem() external view returns (uint256) {
+        return BalanceToRedeem.get();
+    }
+
+    /// @inheritdoc IRiverV1
+    function resolveRedeemRequests(uint32[] calldata _redeemRequestIds)
+        external
+        view
+        returns (int64[] memory withdrawalEventIds)
+    {
+        return IRedeemManagerV1(RedeemManagerAddress.get()).resolveRedeemRequests(_redeemRequestIds);
+    }
+
+    /// @inheritdoc IRiverV1
+    function requestRedeem(uint256 _lsETHAmount, address _recipient) external returns (uint32 _redeemRequestId) {
+        IAllowlistV1(AllowlistAddress.get()).onlyAllowed(msg.sender, LibAllowlistMasks.REDEEM_MASK);
+        _transfer(msg.sender, address(this), _lsETHAmount);
+        return IRedeemManagerV1(RedeemManagerAddress.get()).requestRedeem(_lsETHAmount, _recipient);
+    }
+
+    /// @inheritdoc IRiverV1
+    function claimRedeemRequests(uint32[] calldata _redeemRequestIds, uint32[] calldata _withdrawalEventIds)
+        external
+        returns (uint8[] memory claimStatuses)
+    {
+        return IRedeemManagerV1(RedeemManagerAddress.get()).claimRedeemRequests(
+            _redeemRequestIds, _withdrawalEventIds, true, type(uint16).max
+        );
+    }
+
+    /// @inheritdoc IRiverV1
+    function setGlobalFee(uint256 _newFee) external onlyAdmin {
+        GlobalFee.set(_newFee);
+        emit SetGlobalFee(_newFee);
+    }
+
+    /// @inheritdoc IRiverV1
+    function setAllowlist(address _newAllowlist) external onlyAdmin {
+        AllowlistAddress.set(_newAllowlist);
+        emit SetAllowlist(_newAllowlist);
+    }
+
+    /// @inheritdoc IRiverV1
+    function setCollector(address _newCollector) external onlyAdmin {
+        CollectorAddress.set(_newCollector);
+        emit SetCollector(_newCollector);
+    }
+
+    /// @inheritdoc IRiverV1
+    function setELFeeRecipient(address _newELFeeRecipient) external onlyAdmin {
+        ELFeeRecipientAddress.set(_newELFeeRecipient);
+        emit SetELFeeRecipient(_newELFeeRecipient);
+    }
+
+    /// @inheritdoc IRiverV1
+    function setCoverageFund(address _newCoverageFund) external onlyAdmin {
+        CoverageFundAddress.set(_newCoverageFund);
+        emit SetCoverageFund(_newCoverageFund);
+    }
+
+    /// @inheritdoc IRiverV1
+    function setMetadataURI(string memory _metadataURI) external onlyAdmin {
+        LibSanitize._notEmptyString(_metadataURI);
+        MetadataURI.set(_metadataURI);
+        emit SetMetadataURI(_metadataURI);
+    }
+
+    /// @inheritdoc IRiverV1
+    function getOperatorsRegistry() external view returns (address) {
+        return OperatorsRegistryAddress.get();
+    }
+
+    /// @inheritdoc IRiverV1
+    function sendELFees() external payable {
+        if (msg.sender != ELFeeRecipientAddress.get()) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+    }
+
+    /// @inheritdoc IRiverV1
+    function sendCLFunds() external payable {
+        if (msg.sender != WithdrawalCredentials.getAddress()) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+    }
+
+    /// @inheritdoc IRiverV1
+    function sendCoverageFunds() external payable {
+        if (msg.sender != CoverageFundAddress.get()) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+    }
+
+    /// @inheritdoc IRiverV1
+    function sendRedeemManagerExceedingFunds() external payable {
+        if (msg.sender != RedeemManagerAddress.get()) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+    }
+
+    /// @notice Overridden handler to pass the system admin inside components
+    /// @return The address of the admin
+    function _getRiverAdmin()
+        internal
+        view
+        override(OracleManagerV1, ConsensusLayerDepositManagerV1)
+        returns (address)
+    {
+        return Administrable._getAdmin();
+    }
+
+    /// @notice Overridden handler called whenever a token transfer is triggered
+    /// @param _from Token sender
+    /// @param _to Token receiver
+    function _onTransfer(address _from, address _to) internal view override {
+        IAllowlistV1 allowlist = IAllowlistV1(AllowlistAddress.get());
+        if (allowlist.isDenied(_from)) {
+            revert Denied(_from);
+        }
+        if (allowlist.isDenied(_to)) {
+            revert Denied(_to);
+        }
+    }
+
+    function _onDepositCalledMunged(address _depositor, address _recipient, uint256 _amount) internal {} // munged by certora, this can be fixed once finished with CERT-4706
+    /// @notice Overridden handler called whenever a user deposits ETH to the system. Mints the adequate amount of shares.
+    /// @param _depositor User address that made the deposit
+    /// @param _amount Amount of ETH deposited
+    function _onDeposit(address _depositor, address _recipient, uint256 _amount) internal override {
+        // ICVL(address(0xdeadc0de)).increment_onDepositCounter();
+        _onDepositCalledMunged(_depositor, _recipient, _amount); // munged by Certora
+        uint256 mintedShares = SharesManagerV1._mintShares(_depositor, _amount);
+        IAllowlistV1 allowlist = IAllowlistV1(AllowlistAddress.get());
+        if (_depositor == _recipient) {
+            allowlist.onlyAllowed(_depositor, LibAllowlistMasks.DEPOSIT_MASK); // this call reverts if unauthorized or denied
+        } else {
+            allowlist.onlyAllowed(_depositor, LibAllowlistMasks.DEPOSIT_MASK); // this call reverts if unauthorized or denied
+            if (allowlist.isDenied(_recipient)) {
+                revert Denied(_recipient);
+            }
+            _transfer(_depositor, _recipient, mintedShares);
+        }
+    }
+
+    /// @notice Overridden handler called whenever a deposit to the consensus layer is made. Should retrieve _requestedAmount or lower keys
+    /// @param _requestedAmount Amount of keys required. Contract is expected to send _requestedAmount or lower.
+    /// @return publicKeys Array of fundable public keys
+    /// @return signatures Array of signatures linked to the public keys
+    function _getNextValidators(uint256 _requestedAmount)
+        internal
+        override
+        returns (bytes[] memory publicKeys, bytes[] memory signatures)
+    {
+        return IOperatorsRegistryV1(OperatorsRegistryAddress.get()).pickNextValidatorsToDeposit(_requestedAmount);
+    }
+
+    /// @notice Overridden handler to pull funds from the execution layer fee recipient to River and return the delta in the balance
+    /// @param _max The maximum amount to pull from the execution layer fee recipient
+    /// @return The amount pulled from the execution layer fee recipient
+    function _pullELFees(uint256 _max) internal override returns (uint256) {
+        address elFeeRecipient = ELFeeRecipientAddress.get();
+        uint256 initialBalance = address(this).balance;
+        IELFeeRecipientV1(payable(elFeeRecipient)).pullELFees(_max);
+        uint256 collectedELFees = address(this).balance - initialBalance;
+        if (collectedELFees > 0) {
+            _setBalanceToDeposit(BalanceToDeposit.get() + collectedELFees);
+        }
+        emit PulledELFees(collectedELFees);
+        return collectedELFees;
+    }
+
+    /// @notice Overridden handler to pull funds from the coverage fund to River and return the delta in the balance
+    /// @param _max The maximum amount to pull from the coverage fund
+    /// @return The amount pulled from the coverage fund
+    function _pullCoverageFunds(uint256 _max) internal override returns (uint256) {
+        address coverageFund = CoverageFundAddress.get();
+        if (coverageFund == address(0)) {
+            return 0;
+        }
+        uint256 initialBalance = address(this).balance;
+        ICoverageFundV1(payable(coverageFund)).pullCoverageFunds(_max);
+        uint256 collectedCoverageFunds = address(this).balance - initialBalance;
+        if (collectedCoverageFunds > 0) {
+            _setBalanceToDeposit(BalanceToDeposit.get() + collectedCoverageFunds);
+        }
+        emit PulledCoverageFunds(collectedCoverageFunds);
+        return collectedCoverageFunds;
+    }
+
+    function _onEarningsCalledMunged(uint256 _profits) internal {} // munged by Certora, this can be fixed once finished with CERT-4706
+    /// @notice Overridden handler called whenever the balance of ETH handled by the system increases. Computes the fees paid to the collector
+    /// @param _amount Additional ETH received
+    function _onEarnings(uint256 _amount) internal override {
+        _onEarningsCalledMunged(_amount); // munged by Certora
+        uint256 oldTotalSupply = _totalSupply();
+        if (oldTotalSupply == 0) {
+            revert ZeroMintedShares();
+        }
+        uint256 newTotalBalance = _assetBalance();
+        uint256 globalFee = GlobalFee.get();
+        uint256 numerator = _amount * oldTotalSupply * globalFee;
+        uint256 denominator = (newTotalBalance * LibBasisPoints.BASIS_POINTS_MAX) - (_amount * globalFee);
+        uint256 sharesToMint = denominator == 0 ? 0 : (numerator / denominator);
+
+        if (sharesToMint > 0) {
+            address collector = CollectorAddress.get();
+            _mintRawShares(collector, sharesToMint);
+            uint256 newTotalSupply = _totalSupply();
+            uint256 oldTotalBalance = newTotalBalance - _amount;
+            emit RewardsEarned(collector, oldTotalBalance, oldTotalSupply, newTotalBalance, newTotalSupply);
+        }
+    }
+
+    /// @notice Overridden handler called whenever the total balance of ETH is requested
+    /// @return The current total asset balance managed by River
+    function _assetBalance() internal view override(SharesManagerV1, OracleManagerV1) returns (uint256) {
+        IOracleManagerV1.StoredConsensusLayerReport storage storedReport = LastConsensusLayerReport.get();
+        uint256 clValidatorCount = storedReport.validatorsCount;
+        uint256 depositedValidatorCount = DepositedValidatorCount.get();
+        if (clValidatorCount < depositedValidatorCount) {
+            return storedReport.validatorsBalance + BalanceToDeposit.get() + CommittedBalance.get()
+                + BalanceToRedeem.get()
+                + (depositedValidatorCount - clValidatorCount) * ConsensusLayerDepositManagerV1.DEPOSIT_SIZE;
+        } else {
+            return
+                storedReport.validatorsBalance + BalanceToDeposit.get() + CommittedBalance.get() + BalanceToRedeem.get();
+        }
+    }
+
+    /// @notice Internal utility to set the daily committable limits
+    /// @param _dcl The new daily committable limits
+    function _setDailyCommittableLimits(DailyCommittableLimits.DailyCommittableLimitsStruct memory _dcl) internal {
+        DailyCommittableLimits.set(_dcl);
+        emit SetMaxDailyCommittableAmounts(_dcl.minDailyNetCommittableAmount, _dcl.maxDailyRelativeCommittableAmount);
+    }
+
+    /// @notice Sets the balance to deposit, but not yet committed
+    /// @param _newBalanceToDeposit The new balance to deposit value
+    function _setBalanceToDeposit(uint256 _newBalanceToDeposit) internal override(UserDepositManagerV1) {
+        emit SetBalanceToDeposit(BalanceToDeposit.get(), _newBalanceToDeposit);
+        BalanceToDeposit.set(_newBalanceToDeposit);
+    }
+
+    /// @notice Sets the balance to redeem, to be used to satisfy redeem requests on the redeem manager
+    /// @param _newBalanceToRedeem The new balance to redeem value
+    function _setBalanceToRedeem(uint256 _newBalanceToRedeem) internal {
+        emit SetBalanceToRedeem(BalanceToRedeem.get(), _newBalanceToRedeem);
+        BalanceToRedeem.set(_newBalanceToRedeem);
+    }
+
+    /// @notice Sets the committed balance, ready to be deposited to the consensus layer
+    /// @param _newCommittedBalance The new committed balance value
+    function _setCommittedBalance(uint256 _newCommittedBalance) internal override(ConsensusLayerDepositManagerV1) {
+        emit SetBalanceCommittedToDeposit(CommittedBalance.get(), _newCommittedBalance);
+        CommittedBalance.set(_newCommittedBalance);
+    }
+
+    /// @notice Pulls funds from the Withdraw contract, and adds funds to deposit and redeem balances
+    /// @param _skimmedEthAmount The new amount of skimmed eth to pull
+    /// @param _exitedEthAmount The new amount of exited eth to pull
+    function _pullCLFunds(uint256 _skimmedEthAmount, uint256 _exitedEthAmount) internal override {
+        uint256 currentBalance = address(this).balance;
+        uint256 totalAmountToPull = _skimmedEthAmount + _exitedEthAmount;
+        IWithdrawV1(WithdrawalCredentials.getAddress()).pullEth(totalAmountToPull);
+        uint256 collectedCLFunds = address(this).balance - currentBalance;
+        if (collectedCLFunds != _skimmedEthAmount + _exitedEthAmount) {
+            revert InvalidPulledClFundsAmount(_skimmedEthAmount + _exitedEthAmount, collectedCLFunds);
+        }
+        if (_skimmedEthAmount > 0) {
+            _setBalanceToDeposit(BalanceToDeposit.get() + _skimmedEthAmount);
+        }
+        if (_exitedEthAmount > 0) {
+            _setBalanceToRedeem(BalanceToRedeem.get() + _exitedEthAmount);
+        }
+        emit PulledCLFunds(_skimmedEthAmount, _exitedEthAmount);
+    }
+
+    /// @notice Pulls funds from the redeem manager exceeding eth buffer
+    /// @param _max The maximum amount to pull
+    function _pullRedeemManagerExceedingEth(uint256 _max) internal override returns (uint256) {
+        uint256 currentBalance = address(this).balance;
+        IRedeemManagerV1(RedeemManagerAddress.get()).pullExceedingEth(_max);
+        uint256 collectedExceedingEth = address(this).balance - currentBalance;
+        if (collectedExceedingEth > 0) {
+            _setBalanceToDeposit(BalanceToDeposit.get() + collectedExceedingEth);
+        }
+        emit PulledRedeemManagerExceedingEth(collectedExceedingEth);
+        return collectedExceedingEth;
+    }
+
+    /// @notice Use the balance to redeem to report a withdrawal event on the redeem manager
+    function _reportWithdrawToRedeemManager() internal override {
+        IRedeemManagerV1 redeemManager_ = IRedeemManagerV1(RedeemManagerAddress.get());
+        uint256 underlyingAssetBalance = _assetBalance();
+        uint256 totalSupply = _totalSupply();
+
+        if (underlyingAssetBalance > 0 && totalSupply > 0) {
+            // we compute the redeem manager demands in eth and lsEth based on current conversion rate
+            uint256 redeemManagerDemand = redeemManager_.getRedeemDemand();
+            uint256 suppliedRedeemManagerDemand = redeemManagerDemand;
+            uint256 suppliedRedeemManagerDemandInEth = _balanceFromShares(suppliedRedeemManagerDemand);
+            uint256 availableBalanceToRedeem = BalanceToRedeem.get();
+
+            // if demand is higher than available eth, we update demand values to use the available eth
+            if (suppliedRedeemManagerDemandInEth > availableBalanceToRedeem) {
+                suppliedRedeemManagerDemandInEth = availableBalanceToRedeem;
+                suppliedRedeemManagerDemand = _sharesFromBalance(suppliedRedeemManagerDemandInEth);
+            }
+
+            emit ReportedRedeemManager(
+                redeemManagerDemand, suppliedRedeemManagerDemand, suppliedRedeemManagerDemandInEth
+            );
+
+            if (suppliedRedeemManagerDemandInEth > 0) {
+                // the available balance to redeem is updated
+                _setBalanceToRedeem(availableBalanceToRedeem - suppliedRedeemManagerDemandInEth);
+
+                // we burn the shares of the redeem manager associated with the amount of eth provided
+                _burnRawShares(address(redeemManager_), suppliedRedeemManagerDemand);
+
+                // perform a report withdraw call to the redeem manager
+                redeemManager_.reportWithdraw{value: suppliedRedeemManagerDemandInEth}(suppliedRedeemManagerDemand);
+            }
+        }
+    }
+
+    /// @notice Requests exits of validators after possibly rebalancing deposit and redeem balances
+    /// @param _exitingBalance The currently exiting funds, soon to be received on the execution layer
+    /// @param _depositToRedeemRebalancingAllowed True if rebalancing from deposit to redeem is allowed
+    function _requestExitsBasedOnRedeemDemandAfterRebalancings(
+        uint256 _exitingBalance,
+        uint32[] memory _stoppedValidatorCounts,
+        bool _depositToRedeemRebalancingAllowed,
+        bool _slashingContainmentModeEnabled
+    ) internal override {
+        IOperatorsRegistryV1(OperatorsRegistryAddress.get()).reportStoppedValidatorCounts(
+            _stoppedValidatorCounts, DepositedValidatorCount.get()
+        );
+
+        if (_slashingContainmentModeEnabled) {
+            return;
+        }
+
+        uint256 totalSupply = _totalSupply();
+        if (totalSupply > 0) {
+            uint256 availableBalanceToRedeem = BalanceToRedeem.get();
+            uint256 availableBalanceToDeposit = BalanceToDeposit.get();
+            uint256 redeemManagerDemandInEth =
+                _balanceFromShares(IRedeemManagerV1(RedeemManagerAddress.get()).getRedeemDemand());
+
+            // if after all rebalancings, the redeem manager demand is still higher than the balance to redeem and exiting eth, we compute
+            // the amount of validators to exit in order to cover the remaining demand
+            if (availableBalanceToRedeem + _exitingBalance < redeemManagerDemandInEth) {
+                // if reblancing is enabled and the redeem manager demand is higher than exiting eth, we add eth for deposit buffer to redeem buffer
+                if (_depositToRedeemRebalancingAllowed && availableBalanceToDeposit > 0) {
+                    uint256 rebalancingAmount = LibUint256.min(
+                        availableBalanceToDeposit, redeemManagerDemandInEth - _exitingBalance - availableBalanceToRedeem
+                    );
+                    if (rebalancingAmount > 0) {
+                        availableBalanceToRedeem += rebalancingAmount;
+                        _setBalanceToRedeem(availableBalanceToRedeem);
+                        _setBalanceToDeposit(availableBalanceToDeposit - rebalancingAmount);
+                    }
+                }
+
+                IOperatorsRegistryV1 or = IOperatorsRegistryV1(OperatorsRegistryAddress.get());
+
+                (uint256 totalStoppedValidatorCount, uint256 totalRequestedExitsCount) =
+                    or.getStoppedAndRequestedExitCounts();
+
+                // what we are calling pre-exiting balance is the amount of eth that should soon enter the exiting balance
+                // because exit requests have been made and operators might have a lag to process them
+                // we take them into account to not exit too many validators
+                uint256 preExitingBalance = (
+                    totalRequestedExitsCount > totalStoppedValidatorCount
+                        ? (totalRequestedExitsCount - totalStoppedValidatorCount)
+                        : 0
+                ) * DEPOSIT_SIZE;
+
+                if (availableBalanceToRedeem + _exitingBalance + preExitingBalance < redeemManagerDemandInEth) {
+                    uint256 validatorCountToExit = LibUint256.ceil(
+                        redeemManagerDemandInEth - (availableBalanceToRedeem + _exitingBalance + preExitingBalance),
+                        DEPOSIT_SIZE
+                    );
+
+                    or.demandValidatorExits(validatorCountToExit, DepositedValidatorCount.get());
+                }
+            }
+        }
+    }
+
+    /// @notice Skims the redeem balance and sends remaining funds to the deposit balance
+    function _skimExcessBalanceToRedeem() internal override {
+        uint256 availableBalanceToRedeem = BalanceToRedeem.get();
+
+        // if the available balance to redeem is not 0, it means that all the redeem requests are fulfilled, we should redirect funds for deposits
+        if (availableBalanceToRedeem > 0) {
+            _setBalanceToDeposit(BalanceToDeposit.get() + availableBalanceToRedeem);
+            _setBalanceToRedeem(0);
+        }
+    }
+
+    /// @notice Commits the deposit balance up to the allowed daily limit in batches of 32 ETH.
+    /// @notice Committed funds are funds waiting to be deposited but that cannot be used to fund the redeem manager anymore
+    /// @notice This two step process is required to prevent possible out of gas issues we would have from actually funding the validators at this point
+    /// @param _period The period between current and last report
+    function _commitBalanceToDeposit(uint256 _period) internal override {
+        uint256 underlyingAssetBalance = _assetBalance();
+        uint256 currentBalanceToDeposit = BalanceToDeposit.get();
+        DailyCommittableLimits.DailyCommittableLimitsStruct memory dcl = DailyCommittableLimits.get();
+
+        // we compute the max daily committable amount by taking the asset balance without the balance to deposit into account
+        // this value is the daily maximum amount we can commit for deposits
+        // we take the maximum value between a net amount and an amount relative to the asset balance
+        // this ensures that the amount we can commit is not too low in the beginning and that it is not too high when volumes grow
+        // the relative amount is computed from the committed and activated funds (on the CL or committed to be on the CL soon) and not
+        // the deposit balance
+        // this value is computed by subtracting the current balance to deposit from the underlying asset balance
+        uint256 currentMaxDailyCommittableAmount = LibUint256.max(
+            dcl.minDailyNetCommittableAmount,
+            (uint256(dcl.maxDailyRelativeCommittableAmount) * (underlyingAssetBalance - currentBalanceToDeposit))
+                / LibBasisPoints.BASIS_POINTS_MAX
+        );
+        // we adapt the value for the reporting period by using the asset balance as upper bound
+        uint256 currentMaxCommittableAmount =
+            LibUint256.min((currentMaxDailyCommittableAmount * _period) / 1 days, currentBalanceToDeposit);
+        // we only commit multiples of 32 ETH
+        currentMaxCommittableAmount = (currentMaxCommittableAmount / DEPOSIT_SIZE) * DEPOSIT_SIZE;
+
+        if (currentMaxCommittableAmount > 0) {
+            _setCommittedBalance(CommittedBalance.get() + currentMaxCommittableAmount);
+            _setBalanceToDeposit(currentBalanceToDeposit - currentMaxCommittableAmount);
+        }
+    }
+}
diff -ruN src/contracts/src/TLC.1.sol contracts/src/TLC.1.sol
--- src/contracts/src/TLC.1.sol	1970-01-01 01:00:00
+++ contracts/src/TLC.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,38 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "./components/ERC20VestableVotesUpgradeable.1.sol";
+import "./interfaces/ITLC.1.sol";
+
+/// @title TLC (v1)
+/// @author Alluvial
+/// @notice The TLC token has a max supply of 1,000,000,000 and 18 decimal places.
+/// @notice Upon deployment, all minted tokens are send to account provided at construction, in charge of creating the vesting schedules
+/// @notice The contract is based on ERC20Votes by OpenZeppelin. Users need to delegate their voting power to someone or themselves to be able to vote.
+/// @notice The contract contains vesting logics allowing vested users to still be able to delegate their voting power while their tokens are held in an escrow
+contract TLCV1 is ITLCV1, ERC20VestableVotesUpgradeableV1 {
+    // Token information
+    string internal constant NAME = "Liquid Collective";
+    string internal constant SYMBOL = "TLC";
+
+    // Initial supply of token minted
+    uint256 internal constant INITIAL_SUPPLY = 1_000_000_000e18; // 1 billion TLC
+
+    /// @notice Disables implementation initialization
+    constructor() {
+        _disableInitializers();
+    }
+
+    /// @inheritdoc ITLCV1
+    function initTLCV1(address _account) external initializer {
+        LibSanitize._notZeroAddress(_account);
+        __ERC20Permit_init(NAME);
+        __ERC20_init(NAME, SYMBOL);
+        _mint(_account, INITIAL_SUPPLY);
+    }
+
+    /// @inheritdoc ITLCV1
+    function migrateVestingSchedules() external reinitializer(2) {
+        ERC20VestableVotesUpgradeableV1.migrateVestingSchedulesFromV1ToV2();
+    }
+}
diff -ruN src/contracts/src/TUPProxy.sol contracts/src/TUPProxy.sol
--- src/contracts/src/TUPProxy.sol	1970-01-01 01:00:00
+++ contracts/src/TUPProxy.sol	2024-01-16 15:06:39
@@ -0,0 +1,68 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "openzeppelin-contracts/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";
+
+/// @title TUPProxy (Transparent Upgradeable Pausable Proxy)
+/// @author Kiln
+/// @notice This contract extends the Transparent Upgradeable proxy and adds a system wide pause feature.
+///         When the system is paused, the fallback will fail no matter what calls are made.
+///         Address Zero is allowed to perform calls even if paused to allow view calls made
+///         from RPC providers to properly work.
+contract TUPProxy is TransparentUpgradeableProxy {
+    /// @notice Storage slot of the pause status value
+    bytes32 private constant _PAUSE_SLOT = bytes32(uint256(keccak256("river.tupproxy.pause")) - 1);
+
+    /// @notice A call happened while the system was paused
+    error CallWhenPaused();
+
+    /// @notice The system is now paused
+    /// @param admin The admin at the time of the pause event
+    event Paused(address admin);
+
+    /// @notice The system is now unpaused
+    /// @param admin The admin at the time of the unpause event
+    event Unpaused(address admin);
+
+    /// @dev The Admin of the proxy should not be the same as the
+    /// @dev admin on the implementation logics. The admin here is
+    /// @dev the only account allowed to perform calls on the proxy
+    /// @dev (the calls are never delegated to the implementation)
+    /// @param _logic Address of the implementation
+    /// @param __admin Address of the admin in charge of the proxy
+    /// @param _data Calldata for an atomic initialization
+    constructor(address _logic, address __admin, bytes memory _data)
+        payable
+        TransparentUpgradeableProxy(_logic, __admin, _data)
+    {}
+
+    /// @dev Retrieves Paused state
+    /// @return Paused state
+    function paused() external ifAdmin returns (bool) {
+        return StorageSlot.getBooleanSlot(_PAUSE_SLOT).value;
+    }
+
+    /// @dev Pauses system
+    function pause() external ifAdmin {
+        StorageSlot.getBooleanSlot(_PAUSE_SLOT).value = true;
+        emit Paused(msg.sender);
+    }
+
+    /// @dev Unpauses system
+    function unpause() external ifAdmin {
+        StorageSlot.getBooleanSlot(_PAUSE_SLOT).value = false;
+        emit Unpaused(msg.sender);
+    }
+
+    /// @dev Overrides the fallback method to check if system is not paused before
+    /// @dev Address Zero is allowed to perform calls even if system is paused. This allows
+    /// view functions to be called when the system is paused as rpc providers can easily
+    /// set the sender address to zero.
+    function _beforeFallback() internal override {
+        if (!StorageSlot.getBooleanSlot(_PAUSE_SLOT).value || msg.sender == address(0)) {
+            super._beforeFallback();
+        } else {
+            revert CallWhenPaused();
+        }
+    }
+}
diff -ruN src/contracts/src/WLSETH.1.sol contracts/src/WLSETH.1.sol
--- src/contracts/src/WLSETH.1.sol	1970-01-01 01:00:00
+++ contracts/src/WLSETH.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,196 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "openzeppelin-contracts/contracts/security/ReentrancyGuard.sol";
+
+import "./interfaces/IRiver.1.sol";
+import "./interfaces/IWLSETH.1.sol";
+
+import "./Initializable.sol";
+
+import "./state/shared/RiverAddress.sol";
+import "./state/shared/ApprovalsPerOwner.sol";
+import "./state/wlseth/BalanceOf.sol";
+
+/// @title Wrapped LsETH (v1)
+/// @author Kiln
+/// @notice This contract wraps the LsETH token into a rebase token, more suitable for some DeFi use-cases
+///         like stable swaps.
+contract WLSETHV1 is IWLSETHV1, Initializable, ReentrancyGuard {
+    /// @notice Ensures that the value is not 0
+    /// @param _value Value that must be > 0
+    modifier isNotNull(uint256 _value) {
+        if (_value == 0) {
+            revert NullTransfer();
+        }
+        _;
+    }
+
+    /// @notice Ensures that the owner has enough funds
+    /// @param _owner Owner of the balance to verify
+    /// @param _value Minimum required value
+    modifier hasFunds(address _owner, uint256 _value) {
+        if (_balanceOf(_owner) < _value) {
+            revert BalanceTooLow();
+        }
+        _;
+    }
+
+    /// @inheritdoc IWLSETHV1
+    function initWLSETHV1(address _river) external init(0) {
+        RiverAddress.set(_river);
+        emit SetRiver(_river);
+    }
+
+    /// @inheritdoc IWLSETHV1
+    function name() external pure returns (string memory) {
+        return "Wrapped Liquid Staked ETH";
+    }
+
+    /// @inheritdoc IWLSETHV1
+    function symbol() external pure returns (string memory) {
+        return "wLsETH";
+    }
+
+    /// @inheritdoc IWLSETHV1
+    function decimals() external pure returns (uint8) {
+        return 18;
+    }
+
+    /// @inheritdoc IWLSETHV1
+    function totalSupply() external view returns (uint256) {
+        return IRiverV1(payable(RiverAddress.get())).balanceOfUnderlying(address(this));
+    }
+
+    /// @inheritdoc IWLSETHV1
+    function balanceOf(address _owner) external view returns (uint256) {
+        return _balanceOf(_owner);
+    }
+
+    /// @inheritdoc IWLSETHV1
+    function sharesOf(address _owner) external view returns (uint256) {
+        return BalanceOf.get(_owner);
+    }
+
+    /// @inheritdoc IWLSETHV1
+    function allowance(address _owner, address _spender) external view returns (uint256) {
+        return ApprovalsPerOwner.get(_owner, _spender);
+    }
+
+    /// @inheritdoc IWLSETHV1
+    function transfer(address _to, uint256 _value)
+        external
+        isNotNull(_value)
+        hasFunds(msg.sender, _value)
+        returns (bool)
+    {
+        if (_to == address(0)) {
+            revert UnauthorizedTransfer(msg.sender, address(0));
+        }
+        return _transfer(msg.sender, _to, _value);
+    }
+
+    /// @inheritdoc IWLSETHV1
+    function transferFrom(address _from, address _to, uint256 _value)
+        external
+        isNotNull(_value)
+        hasFunds(_from, _value)
+        returns (bool)
+    {
+        if (_to == address(0)) {
+            revert UnauthorizedTransfer(_from, address(0));
+        }
+        _spendAllowance(_from, _value);
+        return _transfer(_from, _to, _value);
+    }
+
+    /// @inheritdoc IWLSETHV1
+    function approve(address _spender, uint256 _value) external returns (bool) {
+        _approve(msg.sender, _spender, _value);
+        return true;
+    }
+
+    /// @inheritdoc IWLSETHV1
+    function increaseAllowance(address _spender, uint256 _additionalValue) external returns (bool) {
+        _approve(msg.sender, _spender, ApprovalsPerOwner.get(msg.sender, _spender) + _additionalValue);
+        return true;
+    }
+
+    /// @inheritdoc IWLSETHV1
+    function decreaseAllowance(address _spender, uint256 _subtractableValue) external returns (bool) {
+        _approve(msg.sender, _spender, ApprovalsPerOwner.get(msg.sender, _spender) - _subtractableValue);
+        return true;
+    }
+
+    /// @inheritdoc IWLSETHV1
+    function mint(address _recipient, uint256 _shares) external nonReentrant {
+        BalanceOf.set(_recipient, BalanceOf.get(_recipient) + _shares);
+        IRiverV1 river = IRiverV1(payable(RiverAddress.get()));
+        if (!river.transferFrom(msg.sender, address(this), _shares)) {
+            revert TokenTransferError();
+        }
+        emit Mint(_recipient, _shares);
+        emit Transfer(address(0), _recipient, river.underlyingBalanceFromShares(_shares));
+    }
+
+    /// @inheritdoc IWLSETHV1
+    function burn(address _recipient, uint256 _shares) external nonReentrant {
+        uint256 shares = BalanceOf.get(msg.sender);
+        if (_shares > shares) {
+            revert BalanceTooLow();
+        }
+        BalanceOf.set(msg.sender, shares - _shares);
+        IRiverV1 river = IRiverV1(payable(RiverAddress.get()));
+        if (!river.transfer(_recipient, _shares)) {
+            revert TokenTransferError();
+        }
+        emit Transfer(msg.sender, address(0), river.underlyingBalanceFromShares(_shares));
+        emit Burn(_recipient, _shares);
+    }
+
+    /// @notice Internal utility to spend the allowance of an account from the message sender
+    /// @param _from Address owning the allowance
+    /// @param _value Amount of allowance to spend
+    function _spendAllowance(address _from, uint256 _value) internal {
+        uint256 currentAllowance = ApprovalsPerOwner.get(_from, msg.sender);
+        if (currentAllowance < _value) {
+            revert AllowanceTooLow(_from, msg.sender, currentAllowance, _value);
+        }
+        if (currentAllowance != type(uint256).max) {
+            _approve(_from, msg.sender, currentAllowance - _value);
+        }
+    }
+
+    /// @notice Internal utility to change the allowance of an owner to a spender
+    /// @param _owner The owner of the wrapped tokens
+    /// @param _spender The allowed spender of the wrapped tokens
+    /// @param _value The new allowance value
+    function _approve(address _owner, address _spender, uint256 _value) internal {
+        LibSanitize._notZeroAddress(_owner);
+        LibSanitize._notZeroAddress(_spender);
+        ApprovalsPerOwner.set(_owner, _spender, _value);
+        emit Approval(_owner, _spender, _value);
+    }
+
+    /// @notice Internal utility to retrieve the amount of token per owner
+    /// @param _owner Account to be checked
+    /// @return The balance of the account
+    function _balanceOf(address _owner) internal view returns (uint256) {
+        return IRiverV1(payable(RiverAddress.get())).underlyingBalanceFromShares(BalanceOf.get(_owner));
+    }
+
+    /// @notice Internal utility to perform an unchecked transfer
+    /// @param _from Address sending the tokens
+    /// @param _to Address receiving the tokens
+    /// @param _value Amount to be sent
+    /// @return True if success
+    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {
+        uint256 valueToShares = IRiverV1(payable(RiverAddress.get())).sharesFromUnderlyingBalance(_value);
+        BalanceOf.set(_from, BalanceOf.get(_from) - valueToShares);
+        BalanceOf.set(_to, BalanceOf.get(_to) + valueToShares);
+
+        emit Transfer(_from, _to, _value);
+
+        return true;
+    }
+}
diff -ruN src/contracts/src/Withdraw.1.sol contracts/src/Withdraw.1.sol
--- src/contracts/src/Withdraw.1.sol	1970-01-01 01:00:00
+++ contracts/src/Withdraw.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,54 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "./Initializable.sol";
+import "./interfaces/IRiver.1.sol";
+import "./interfaces/IWithdraw.1.sol";
+import "./libraries/LibErrors.sol";
+import "./libraries/LibUint256.sol";
+
+import "./state/shared/RiverAddress.sol";
+
+/// @title Withdraw (v1)
+/// @author Kiln
+/// @notice This contract is in charge of holding the exit and skimming funds and allow river to pull these funds
+contract WithdrawV1 is IWithdrawV1, Initializable {
+    modifier onlyRiver() {
+        if (msg.sender != RiverAddress.get()) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+        _;
+    }
+
+    /// @inheritdoc IWithdrawV1
+    function initializeWithdrawV1(address _river) external init(0) {
+        _setRiver(_river);
+    }
+
+    /// @inheritdoc IWithdrawV1
+    function getCredentials() external view returns (bytes32) {
+        return bytes32(
+            uint256(uint160(address(this))) + 0x0100000000000000000000000000000000000000000000000000000000000000
+        );
+    }
+
+    /// @inheritdoc IWithdrawV1
+    function getRiver() external view returns (address) {
+        return RiverAddress.get();
+    }
+
+    /// @inheritdoc IWithdrawV1
+    function pullEth(uint256 _max) external onlyRiver {
+        uint256 amountToPull = LibUint256.min(address(this).balance, _max);
+        if (amountToPull > 0) {
+            IRiverV1(payable(RiverAddress.get())).sendCLFunds{value: amountToPull}();
+        }
+    }
+
+    /// @notice Internal utility to set the river address
+    /// @param _river The new river address
+    function _setRiver(address _river) internal {
+        RiverAddress.set(_river);
+        emit SetRiver(_river);
+    }
+}
diff -ruN src/contracts/src/components/ConsensusLayerDepositManager.1.sol contracts/src/components/ConsensusLayerDepositManager.1.sol
--- src/contracts/src/components/ConsensusLayerDepositManager.1.sol	1970-01-01 01:00:00
+++ contracts/src/components/ConsensusLayerDepositManager.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,165 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../interfaces/components/IConsensusLayerDepositManager.1.sol";
+import "../interfaces/IDepositContract.sol";
+
+import "../libraries/LibBytes.sol";
+import "../libraries/LibUint256.sol";
+
+import "../state/river/DepositContractAddress.sol";
+import "../state/river/WithdrawalCredentials.sol";
+import "../state/river/DepositedValidatorCount.sol";
+import "../state/river/BalanceToDeposit.sol";
+import "../state/river/CommittedBalance.sol";
+
+/// @title Consensus Layer Deposit Manager (v1)
+/// @author Kiln
+/// @notice This contract handles the interactions with the official deposit contract, funding all validators
+/// @notice Whenever a deposit to the consensus layer is requested, this contract computed the amount of keys
+/// @notice that could be deposited depending on the amount available in the contract. It then tries to retrieve
+/// @notice validator keys by calling its internal virtual method _getNextValidators. This method should be
+/// @notice overridden by the implementing contract to provide [0; _keyCount] keys when invoked.
+abstract contract ConsensusLayerDepositManagerV1 is IConsensusLayerDepositManagerV1 {
+    /// @notice Size of a BLS Public key in bytes
+    uint256 public constant PUBLIC_KEY_LENGTH = 48;
+    /// @notice Size of a BLS Signature in bytes
+    uint256 public constant SIGNATURE_LENGTH = 96;
+    /// @notice Size of a deposit in ETH
+    uint256 public constant DEPOSIT_SIZE = 32 ether;
+
+    /// @notice Handler called to retrieve the internal River admin address
+    /// @dev Must be Overridden
+    function _getRiverAdmin() internal view virtual returns (address);
+
+    /// @notice Handler called to change the committed balance to deposit
+    /// @param newCommittedBalance The new committed balance value
+    function _setCommittedBalance(uint256 newCommittedBalance) internal virtual;
+
+    /// @notice Internal helper to retrieve validator keys ready to be funded
+    /// @dev Must be overridden
+    /// @param _keyCount The amount of keys (or less) to return.
+    function _getNextValidators(uint256 _keyCount)
+        internal
+        virtual
+        returns (bytes[] memory publicKeys, bytes[] memory signatures);
+
+    /// @notice Initializer to set the deposit contract address and the withdrawal credentials to use
+    /// @param _depositContractAddress The address of the deposit contract
+    /// @param _withdrawalCredentials The withdrawal credentials to apply to all deposits
+    function initConsensusLayerDepositManagerV1(address _depositContractAddress, bytes32 _withdrawalCredentials)
+        internal
+    {
+        DepositContractAddress.set(_depositContractAddress);
+        emit SetDepositContractAddress(_depositContractAddress);
+
+        WithdrawalCredentials.set(_withdrawalCredentials);
+        emit SetWithdrawalCredentials(_withdrawalCredentials);
+    }
+
+    /// @inheritdoc IConsensusLayerDepositManagerV1
+    function getCommittedBalance() external view returns (uint256) {
+        return CommittedBalance.get();
+    }
+
+    /// @inheritdoc IConsensusLayerDepositManagerV1
+    function getBalanceToDeposit() external view returns (uint256) {
+        return BalanceToDeposit.get();
+    }
+
+    /// @inheritdoc IConsensusLayerDepositManagerV1
+    function getWithdrawalCredentials() external view returns (bytes32) {
+        return WithdrawalCredentials.get();
+    }
+
+    /// @inheritdoc IConsensusLayerDepositManagerV1
+    function getDepositedValidatorCount() external view returns (uint256) {
+        return DepositedValidatorCount.get();
+    }
+
+    /// @inheritdoc IConsensusLayerDepositManagerV1
+    function depositToConsensusLayer(uint256 _maxCount) external {
+        uint256 committedBalance = CommittedBalance.get();
+        uint256 keyToDepositCount = LibUint256.min(committedBalance / DEPOSIT_SIZE, _maxCount);
+
+        if (keyToDepositCount == 0) {
+            revert NotEnoughFunds();
+        }
+
+        // it's up to the internal overriden _getNextValidators method to provide two array of the same
+        // size for the publicKeys and the signatures
+        (bytes[] memory publicKeys, bytes[] memory signatures) = _getNextValidators(keyToDepositCount);
+
+        uint256 receivedPublicKeyCount = publicKeys.length;
+
+        if (receivedPublicKeyCount == 0) {
+            revert NoAvailableValidatorKeys();
+        }
+
+        if (receivedPublicKeyCount > keyToDepositCount) {
+            revert InvalidPublicKeyCount();
+        }
+
+        bytes32 withdrawalCredentials = WithdrawalCredentials.get();
+
+        if (withdrawalCredentials == 0) {
+            revert InvalidWithdrawalCredentials();
+        }
+
+        for (uint256 idx = 0; idx < receivedPublicKeyCount;) {
+            _depositValidator(publicKeys[idx], signatures[idx], withdrawalCredentials);
+            unchecked {
+                ++idx;
+            }
+        }
+        _setCommittedBalance(committedBalance - DEPOSIT_SIZE * receivedPublicKeyCount);
+        uint256 currentDepositedValidatorCount = DepositedValidatorCount.get();
+        DepositedValidatorCount.set(currentDepositedValidatorCount + receivedPublicKeyCount);
+        emit SetDepositedValidatorCount(
+            currentDepositedValidatorCount, currentDepositedValidatorCount + receivedPublicKeyCount
+        );
+    }
+
+    /// @notice Deposits 32 ETH to the official Deposit contract
+    /// @param _publicKey The public key of the validator
+    /// @param _signature The signature provided by the operator
+    /// @param _withdrawalCredentials The withdrawal credentials provided by River
+    function _depositValidator(bytes memory _publicKey, bytes memory _signature, bytes32 _withdrawalCredentials)
+        internal
+    {
+        if (_publicKey.length != PUBLIC_KEY_LENGTH) {
+            revert InconsistentPublicKeys();
+        }
+
+        if (_signature.length != SIGNATURE_LENGTH) {
+            revert InconsistentSignatures();
+        }
+        uint256 value = DEPOSIT_SIZE;
+
+        uint256 depositAmount = value / 1 gwei;
+
+        bytes32 pubkeyRoot = sha256(bytes.concat(_publicKey, bytes16(0)));
+        bytes32 signatureRoot = sha256(
+            bytes.concat(
+                sha256(LibBytes.slice(_signature, 0, 64)),
+                sha256(bytes.concat(LibBytes.slice(_signature, 64, SIGNATURE_LENGTH - 64), bytes32(0)))
+            )
+        );
+
+        bytes32 depositDataRoot = sha256(
+            bytes.concat(
+                sha256(bytes.concat(pubkeyRoot, _withdrawalCredentials)),
+                sha256(bytes.concat(bytes32(LibUint256.toLittleEndian64(depositAmount)), signatureRoot))
+            )
+        );
+
+        uint256 targetBalance = address(this).balance - value;
+
+        IDepositContract(DepositContractAddress.get()).deposit{value: value}(
+            _publicKey, abi.encodePacked(_withdrawalCredentials), _signature, depositDataRoot
+        );
+        if (address(this).balance != targetBalance) {
+            revert ErrorOnDeposit();
+        }
+    }
+}
diff -ruN src/contracts/src/components/ERC20VestableVotesUpgradeable.1.sol contracts/src/components/ERC20VestableVotesUpgradeable.1.sol
--- src/contracts/src/components/ERC20VestableVotesUpgradeable.1.sol	1970-01-01 01:00:00
+++ contracts/src/components/ERC20VestableVotesUpgradeable.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,471 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol";
+import "openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol";
+
+import "../interfaces/components/IERC20VestableVotesUpgradeable.1.sol";
+
+import "../state/tlc/VestingSchedules.2.sol";
+import "../state/tlc/IgnoreGlobalUnlockSchedule.sol";
+
+import "../libraries/LibSanitize.sol";
+import "../libraries/LibUint256.sol";
+
+/// @title ERC20VestableVotesUpgradeableV1
+/// @author Alluvial
+/// @notice This is an ERC20 extension that
+/// @notice   - can be used as source of vote power (inherited from OpenZeppelin ERC20VotesUpgradeable)
+/// @notice   - can delegate vote power from an account to another account (inherited from OpenZeppelin ERC20VotesUpgradeable)
+/// @notice   - can manage token vestings: ownership is progressively transferred to a beneficiary according to a vesting schedule
+/// @notice   - keeps a history (checkpoints) of each account's vote power
+/// @notice
+/// @notice Notes from OpenZeppelin [ERC20VotesUpgradeable](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol)
+/// @notice   - vote power can be delegated either by calling the {delegate} function, or by providing a signature to be used with {delegateBySig}
+/// @notice   - keeps a history (checkpoints) of each account's vote power
+/// @notice   - power can be queried through the public accessors {getVotes} and {getPastVotes}.
+/// @notice   - by default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it
+/// @notice requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.
+/// @notice
+/// @notice Notes about token vesting
+/// @notice   - any token holder can call the method {createVestingSchedule} in order to transfer tokens to a beneficiary according to a vesting schedule. When
+/// @notice     creating a vesting schedule, tokens are transferred to an escrow that holds the token while the vesting progresses. Voting power of the escrowed token is delegated to the
+/// @notice     beneficiary or a delegatee account set by the vesting schedule creator
+/// @notice   - the schedule beneficiary call {releaseVestingSchedule} to get vested tokens transferred from escrow
+/// @notice   - the schedule creator can revoke a revocable schedule by calling {revokeVestingSchedule} in which case the non-vested tokens are transfered from the escrow back to the creator
+/// @notice   - the schedule beneficiary can delegate escrow voting power to any account by calling {delegateVestingEscrow}
+/// @notice
+/// @notice Vesting schedule attributes are
+/// @notice   - start : start time of the vesting period
+/// @notice   - cliff duration: duration before which first tokens gets ownable
+/// @notice   - total duration: duration of the entire vesting (sum of all vesting period durations)
+/// @notice   - period duration: duration of a single period of vesting
+/// @notice   - lock duration: duration before tokens gets unlocked. can exceed the duration of the vesting chedule
+/// @notice   - amount: amount of tokens granted by the vesting schedule
+/// @notice   - beneficiary: beneficiary of tokens after they are releaseVestingScheduled
+/// @notice   - revocable: whether the schedule can be revoked
+/// @notice   - ignoreGlobalUnlockSchedule: whether the schedule should ignore the global unlock schedule
+/// @notice
+/// @notice Vesting schedule
+/// @notice   - if currentTime < cliff: vestedToken = 0
+/// @notice   - if cliff <= currentTime < end: vestedToken = (vestedPeriodCount(currentTime) * periodDuration * amount) / totalDuration
+/// @notice   - if end < currentTime: vestedToken = amount
+/// @notice
+/// @notice Global unlock schedule
+/// @notice   - the global unlock schedule releases 1/24th of the total scheduled amount every month after the local lock end
+/// @notice   - the local lock end is the end of the lock period of the vesting schedule
+/// @notice   - the global unlock schedule is ignored if the vesting schedule has the ignoreGlobalUnlockSchedule flag set to true
+/// @notice   - the global unlock schedule is only a cap on the vested funds that can be withdrawn, it does not alter the vesting
+/// @notice
+/// @notice Remark: After cliff new tokens get vested at the end of each period
+/// @notice
+/// @notice Vested token & lock period
+/// @notice   - a vested token is a token that will be eventually releasable from the escrow to the beneficiary once the lock period is over
+/// @notice   - lock period prevents beneficiary from releasing vested tokens before the lock period ends. Vested tokens
+/// @notice will eventually be releasable once the lock period is over
+/// @notice
+/// @notice Example: Joe gets a vesting starting on Jan 1st 2022 with duration of 1 year and a lock period of 2 years.
+/// @notice On Jan 1st 2023, Joe will have all tokens vested but can not yet release it due to the lock period.
+/// @notice On Jan 1st 2024, lock period is over and Joe can release all tokens.
+abstract contract ERC20VestableVotesUpgradeableV1 is
+    Initializable,
+    ERC20VotesUpgradeable,
+    IERC20VestableVotesUpgradeableV1
+{
+    // internal used to compute the address of the escrow
+    bytes32 internal constant ESCROW = bytes32(uint256(keccak256("escrow")) - 1);
+
+    function __ERC20VestableVotes_init() internal onlyInitializing {}
+
+    function __ERC20VestableVotes_init_unchained() internal onlyInitializing {}
+
+    /// @notice This method migrates the state of the vesting schedules from V1 to V2
+    /// @dev This method should be used if deployment with the old version using V1 state models is upgraded
+    function migrateVestingSchedulesFromV1ToV2() internal {
+        if (VestingSchedulesV2.getCount() == 0) {
+            uint256 existingV1VestingSchedules = VestingSchedulesV1.getCount();
+            for (uint256 idx; idx < existingV1VestingSchedules;) {
+                uint256 scheduleAmount = VestingSchedulesV1.get(idx).amount;
+                uint256 releasedAmount =
+                    scheduleAmount - LibUint256.min(balanceOf(_deterministicVestingEscrow(idx)), scheduleAmount);
+                VestingSchedulesV2.migrateVestingScheduleFromV1(idx, releasedAmount);
+                unchecked {
+                    ++idx;
+                }
+            }
+        }
+    }
+
+    /// @inheritdoc IERC20VestableVotesUpgradeableV1
+    function getVestingSchedule(uint256 _index) external view returns (VestingSchedulesV2.VestingSchedule memory) {
+        return VestingSchedulesV2.get(_index);
+    }
+
+    /// @inheritdoc IERC20VestableVotesUpgradeableV1
+    function isGlobalUnlockedScheduleIgnored(uint256 _index) external view returns (bool) {
+        return IgnoreGlobalUnlockSchedule.get(_index);
+    }
+
+    /// @inheritdoc IERC20VestableVotesUpgradeableV1
+    function getVestingScheduleCount() external view returns (uint256) {
+        return VestingSchedulesV2.getCount();
+    }
+
+    /// @inheritdoc IERC20VestableVotesUpgradeableV1
+    function vestingEscrow(uint256 _index) external view returns (address) {
+        return _deterministicVestingEscrow(_index);
+    }
+
+    /// @inheritdoc IERC20VestableVotesUpgradeableV1
+    function computeVestingReleasableAmount(uint256 _index) external view returns (uint256) {
+        VestingSchedulesV2.VestingSchedule memory vestingSchedule = VestingSchedulesV2.get(_index);
+        return _computeVestingReleasableAmount(vestingSchedule, false, _index);
+    }
+
+    /// @inheritdoc IERC20VestableVotesUpgradeableV1
+    function computeVestingVestedAmount(uint256 _index) external view returns (uint256) {
+        VestingSchedulesV2.VestingSchedule memory vestingSchedule = VestingSchedulesV2.get(_index);
+        return _computeVestedAmount(vestingSchedule, LibUint256.min(_getCurrentTime(), vestingSchedule.end));
+    }
+
+    /// @inheritdoc IERC20VestableVotesUpgradeableV1
+    function createVestingSchedule(
+        uint64 _start,
+        uint32 _cliffDuration,
+        uint32 _duration,
+        uint32 _periodDuration,
+        uint32 _lockDuration,
+        bool _revocable,
+        uint256 _amount,
+        address _beneficiary,
+        address _delegatee,
+        bool _ignoreGlobalUnlockSchedule
+    ) external returns (uint256) {
+        return _createVestingSchedule(
+            msg.sender,
+            _beneficiary,
+            _delegatee,
+            _start,
+            _cliffDuration,
+            _duration,
+            _periodDuration,
+            _lockDuration,
+            _revocable,
+            _amount,
+            _ignoreGlobalUnlockSchedule
+        );
+    }
+
+    /// @inheritdoc IERC20VestableVotesUpgradeableV1
+    function revokeVestingSchedule(uint256 _index, uint64 _end) external returns (uint256) {
+        return _revokeVestingSchedule(_index, _end);
+    }
+
+    /// @inheritdoc IERC20VestableVotesUpgradeableV1
+    function releaseVestingSchedule(uint256 _index) external returns (uint256) {
+        return _releaseVestingSchedule(_index);
+    }
+
+    /// @inheritdoc IERC20VestableVotesUpgradeableV1
+    function delegateVestingEscrow(uint256 _index, address _delegatee) external returns (bool) {
+        return _delegateVestingEscrow(_index, _delegatee);
+    }
+
+    /// @notice Creates a new vesting schedule
+    /// @param _creator creator of the token vesting
+    /// @param _beneficiary beneficiary of tokens after they are releaseVestingScheduled
+    /// @param _delegatee address of the delegate escrowed tokens votes to (if address(0) then it defaults to the beneficiary)
+    /// @param _start start time of the vesting period
+    /// @param _cliffDuration duration before which first tokens gets ownable
+    /// @param _duration duration of the entire vesting (sum of all vesting period durations)
+    /// @param _periodDuration duration of a single period of vesting
+    /// @param _lockDuration duration before tokens gets unlocked. can exceed the duration of the vesting chedule
+    /// @param _revocable whether the schedule can be revoked
+    /// @param _amount amount of tokens granted by the vesting schedule
+    /// @param _ignoreGlobalUnlockSchedule whether the schedule should ignore the global unlock schedule
+    /// @return index of the created vesting schedule
+    function _createVestingSchedule(
+        address _creator,
+        address _beneficiary,
+        address _delegatee,
+        uint64 _start,
+        uint32 _cliffDuration,
+        uint32 _duration,
+        uint32 _periodDuration,
+        uint32 _lockDuration,
+        bool _revocable,
+        uint256 _amount,
+        bool _ignoreGlobalUnlockSchedule
+    ) internal returns (uint256) {
+        if (balanceOf(_creator) < _amount) {
+            revert UnsufficientVestingScheduleCreatorBalance();
+        }
+
+        // validate schedule parameters
+        if (_beneficiary == address(0)) {
+            revert InvalidVestingScheduleParameter("Vesting schedule beneficiary must be non zero address");
+        }
+
+        if (_duration == 0) {
+            revert InvalidVestingScheduleParameter("Vesting schedule duration must be > 0");
+        }
+
+        if (_amount == 0) {
+            revert InvalidVestingScheduleParameter("Vesting schedule amount must be > 0");
+        }
+
+        if (_periodDuration == 0) {
+            revert InvalidVestingScheduleParameter("Vesting schedule period must be > 0");
+        }
+
+        if (_duration % _periodDuration > 0) {
+            revert InvalidVestingScheduleParameter("Vesting schedule duration must split in exact periods");
+        }
+
+        if (_cliffDuration % _periodDuration > 0) {
+            revert InvalidVestingScheduleParameter("Vesting schedule cliff duration must split in exact periods");
+        }
+
+        if (_cliffDuration > _duration) {
+            revert InvalidVestingScheduleParameter(
+                "Vesting schedule duration must be greater than or equal to the cliff duration"
+            );
+        }
+
+        if ((_amount * _periodDuration) / _duration == 0) {
+            revert InvalidVestingScheduleParameter("Vesting schedule amount too low for duration and period");
+        }
+
+        // if input start time is 0 then default to the current block time
+        if (_start == 0) {
+            _start = uint64(block.timestamp);
+        }
+
+        // create new vesting schedule
+        VestingSchedulesV2.VestingSchedule memory vestingSchedule = VestingSchedulesV2.VestingSchedule({
+            start: _start,
+            end: _start + _duration,
+            lockDuration: _lockDuration,
+            cliffDuration: _cliffDuration,
+            duration: _duration,
+            periodDuration: _periodDuration,
+            amount: _amount,
+            creator: _creator,
+            beneficiary: _beneficiary,
+            revocable: _revocable,
+            releasedAmount: 0
+        });
+        uint256 index = VestingSchedulesV2.push(vestingSchedule) - 1;
+
+        IgnoreGlobalUnlockSchedule.set(index, _ignoreGlobalUnlockSchedule);
+
+        // compute escrow address that will hold the token during the vesting
+        address escrow = _deterministicVestingEscrow(index);
+
+        // transfer tokens to the escrow
+        _transfer(_creator, escrow, _amount);
+
+        // delegate escrow tokens
+        if (_delegatee == address(0)) {
+            // default delegatee to beneficiary address
+            _delegate(escrow, _beneficiary);
+        } else {
+            _delegate(escrow, _delegatee);
+        }
+
+        emit CreatedVestingSchedule(index, _creator, _beneficiary, _amount);
+
+        return index;
+    }
+
+    /// @notice Revoke vesting schedule
+    /// @param _index Index of the vesting schedule to revoke
+    /// @param _end End date for the schedule
+    /// @return returnedAmount amount returned to the vesting schedule creator
+    function _revokeVestingSchedule(uint256 _index, uint64 _end) internal returns (uint256) {
+        if (_end == 0) {
+            // if end time is 0 then default to current block time
+            _end = uint64(block.timestamp);
+        } else if (_end < block.timestamp) {
+            revert VestingScheduleNotRevocableInPast();
+        }
+
+        VestingSchedulesV2.VestingSchedule storage vestingSchedule = VestingSchedulesV2.get(_index);
+        if (!vestingSchedule.revocable) {
+            revert VestingScheduleNotRevocable();
+        }
+
+        // revoked end date MUST be after vesting schedule start and before current end
+        if ((_end < vestingSchedule.start) || (vestingSchedule.end < _end)) {
+            revert InvalidRevokedVestingScheduleEnd();
+        }
+
+        // only creator can revoke vesting schedule
+        if (vestingSchedule.creator != msg.sender) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+
+        // return tokens that will never be vested to creator
+        uint256 vestedAmountAtOldEnd = _computeVestedAmount(vestingSchedule, vestingSchedule.end);
+        uint256 vestedAmountAtNewEnd = _computeVestedAmount(vestingSchedule, _end);
+        uint256 returnedAmount = vestedAmountAtOldEnd - vestedAmountAtNewEnd;
+        if (returnedAmount > 0) {
+            address escrow = _deterministicVestingEscrow(_index);
+            _transfer(escrow, msg.sender, returnedAmount);
+        }
+
+        // set schedule end
+        vestingSchedule.end = uint64(_end);
+
+        emit RevokedVestingSchedule(_index, returnedAmount, _end);
+
+        return returnedAmount;
+    }
+
+    /// @notice Release vesting schedule
+    /// @param _index Index of the vesting schedule to release
+    /// @return released amount
+    function _releaseVestingSchedule(uint256 _index) internal returns (uint256) {
+        VestingSchedulesV2.VestingSchedule storage vestingSchedule = VestingSchedulesV2.get(_index);
+
+        // only beneficiary can release
+        if (msg.sender != vestingSchedule.beneficiary) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+
+        // compute releasable amount (taking into account local lock and global unlock schedule if it applies)
+        uint256 releasableAmount = _computeVestingReleasableAmount(vestingSchedule, true, _index);
+        if (releasableAmount == 0) {
+            revert ZeroReleasableAmount();
+        }
+
+        address escrow = _deterministicVestingEscrow(_index);
+
+        // transfer all releasable token to the beneficiary
+        _transfer(escrow, msg.sender, releasableAmount);
+
+        // increase released amount as per the release
+        vestingSchedule.releasedAmount += releasableAmount;
+
+        emit ReleasedVestingSchedule(_index, releasableAmount);
+
+        return releasableAmount;
+    }
+
+    /// @notice Delegate vesting escrowed tokens
+    /// @param _index index of the vesting schedule
+    /// @param _delegatee address to delegate the token to
+    /// @return True on success
+    function _delegateVestingEscrow(uint256 _index, address _delegatee) internal returns (bool) {
+        VestingSchedulesV2.VestingSchedule storage vestingSchedule = VestingSchedulesV2.get(_index);
+
+        // only beneficiary can delegate
+        if (msg.sender != vestingSchedule.beneficiary) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+
+        // update delegatee
+        address escrow = _deterministicVestingEscrow(_index);
+        address oldDelegatee = delegates(escrow);
+        _delegate(escrow, _delegatee);
+
+        emit DelegatedVestingEscrow(_index, oldDelegatee, _delegatee, msg.sender);
+
+        return true;
+    }
+
+    /// @notice Internal utility to compute the unique escrow deterministic address
+    /// @param _index index of the vesting schedule
+    /// @return escrow The deterministic escrow address for the vesting schedule index
+    function _deterministicVestingEscrow(uint256 _index) internal view returns (address escrow) {
+        bytes32 hash = keccak256(abi.encodePacked(address(this), ESCROW, _index));
+        return address(uint160(uint256(hash)));
+    }
+
+    /// @notice Computes the releasable amount of tokens for a vesting schedule.
+    /// @param _vestingSchedule vesting schedule to compute releasable tokens for
+    /// @param  _revertIfLocked if true will revert if the schedule is locked
+    /// @param _index index of the vesting schedule
+    /// @return amount of release tokens
+    function _computeVestingReleasableAmount(
+        VestingSchedulesV2.VestingSchedule memory _vestingSchedule,
+        bool _revertIfLocked,
+        uint256 _index
+    ) internal view returns (uint256) {
+        uint256 time = _getCurrentTime();
+        if (time < (_vestingSchedule.start + _vestingSchedule.lockDuration)) {
+            if (_revertIfLocked) {
+                revert VestingScheduleIsLocked();
+            } else {
+                return 0;
+            }
+        }
+        uint256 releasedAmount = _vestingSchedule.releasedAmount;
+        uint256 vestedAmount =
+            _computeVestedAmount(_vestingSchedule, time > _vestingSchedule.end ? _vestingSchedule.end : time);
+        if (vestedAmount > releasedAmount) {
+            if (!IgnoreGlobalUnlockSchedule.get(_index)) {
+                uint256 globalUnlocked = _computeGlobalUnlocked(
+                    _vestingSchedule.amount, time - (_vestingSchedule.start + _vestingSchedule.lockDuration)
+                );
+                if (releasedAmount > globalUnlocked) {
+                    revert GlobalUnlockUnderlfow();
+                }
+                return LibUint256.min(vestedAmount, globalUnlocked) - releasedAmount;
+            }
+            unchecked {
+                return vestedAmount - releasedAmount;
+            }
+        }
+
+        return 0;
+    }
+
+    /// @notice Computes the vested amount of tokens for a vesting schedule.
+    /// @param _vestingSchedule vesting schedule to compute vested tokens for
+    /// @param _time time to compute the vested amount at
+    /// @return amount of release tokens
+    function _computeVestedAmount(VestingSchedulesV2.VestingSchedule memory _vestingSchedule, uint256 _time)
+        internal
+        pure
+        returns (uint256)
+    {
+        if (_time < _vestingSchedule.start + _vestingSchedule.cliffDuration) {
+            // pre-cliff no tokens have been vested
+            return 0;
+        } else if (_time >= _vestingSchedule.start + _vestingSchedule.duration) {
+            // post vesting all tokens have been vested
+            return _vestingSchedule.amount;
+        } else {
+            uint256 timeFromStart = _time - _vestingSchedule.start;
+
+            // compute tokens vested for completely elapsed periods
+            uint256 vestedDuration = timeFromStart - timeFromStart % _vestingSchedule.periodDuration;
+
+            return (vestedDuration * _vestingSchedule.amount) / _vestingSchedule.duration;
+        }
+    }
+
+    /// @notice Computes the unlocked amount of tokens for a vesting schedule according to the global unlock schedule
+    /// @param scheduledAmount amount of tokens scheduled for the vesting schedule
+    /// @param timeSinceLocalLockEnd time since the local lock end
+    /// @return amount of unlocked tokens
+    function _computeGlobalUnlocked(uint256 scheduledAmount, uint256 timeSinceLocalLockEnd)
+        internal
+        pure
+        returns (uint256)
+    {
+        // 1/24 th of the amount per month
+        uint256 unlockedAmount = (scheduledAmount / 24) * (timeSinceLocalLockEnd / (365 days / 12));
+        if (unlockedAmount > scheduledAmount) {
+            return scheduledAmount;
+        }
+        return unlockedAmount;
+    }
+
+    /// @notice Returns current time
+    /// @return The current time
+    function _getCurrentTime() internal view virtual returns (uint256) {
+        return block.timestamp;
+    }
+}
diff -ruN src/contracts/src/components/OracleManager.1.sol contracts/src/components/OracleManager.1.sol
--- src/contracts/src/components/OracleManager.1.sol	1970-01-01 01:00:00
+++ contracts/src/components/OracleManager.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,497 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../interfaces/components/IOracleManager.1.sol";
+import "../interfaces/IRedeemManager.1.sol";
+
+import "../libraries/LibUint256.sol";
+
+import "../state/river/LastConsensusLayerReport.sol";
+import "../state/river/OracleAddress.sol";
+import "../state/river/CLValidatorTotalBalance.sol";
+import "../state/river/CLValidatorCount.sol";
+import "../state/river/DepositedValidatorCount.sol";
+import "../state/river/LastOracleRoundId.sol";
+
+/// @title Oracle Manager (v1)
+/// @author Kiln
+/// @notice This contract handles the inputs provided by the oracle
+/// @notice The Oracle contract is plugged to this contract and is in charge of pushing
+/// @notice data whenever a new report has been deemed valid. The report consists in two
+/// @notice values: the sum of all balances of all deposited validators and the count of
+/// @notice validators that have been activated on the consensus layer.
+abstract contract OracleManagerV1 is IOracleManagerV1 {
+    uint256 internal constant ONE_YEAR = 365 days;
+    /// @notice Size of a deposit in ETH
+    uint256 public constant _DEPOSIT_SIZE = 32 ether;
+
+    /// @notice Handler called if the delta between the last and new validator balance sum is positive
+    /// @dev Must be overridden
+    /// @param _profits The positive increase in the validator balance sum (staking rewards)
+    function _onEarnings(uint256 _profits) internal virtual;
+
+    /// @notice Handler called to pull the Execution layer fees from the recipient
+    /// @dev Must be overridden
+    /// @param _max The maximum amount to pull inside the system
+    /// @return The amount pulled inside the system
+    function _pullELFees(uint256 _max) internal virtual returns (uint256);
+
+    /// @notice Handler called to pull the coverage funds
+    /// @dev Must be overridden
+    /// @param _max The maximum amount to pull inside the system
+    /// @return The amount pulled inside the system
+    function _pullCoverageFunds(uint256 _max) internal virtual returns (uint256);
+
+    /// @notice Handler called to retrieve the system administrator address
+    /// @dev Must be overridden
+    /// @return The system administrator address
+    function _getRiverAdmin() internal view virtual returns (address);
+
+    /// @notice Overridden handler called whenever the total balance of ETH is requested
+    /// @return The current total asset balance managed by River
+    function _assetBalance() internal view virtual returns (uint256);
+
+    /// @notice Pulls funds from the Withdraw contract, and adds funds to deposit and redeem balances
+    /// @param _skimmedEthAmount The new amount of skimmed eth to pull
+    /// @param _exitedEthAmount The new amount of exited eth to pull
+    function _pullCLFunds(uint256 _skimmedEthAmount, uint256 _exitedEthAmount) internal virtual;
+
+    /// @notice Pulls funds from the redeem manager exceeding eth buffer
+    /// @param _max The maximum amount to pull
+    /// @return The amount pulled
+    function _pullRedeemManagerExceedingEth(uint256 _max) internal virtual returns (uint256);
+
+    /// @notice Use the balance to redeem to report a withdrawal event on the redeem manager
+    function _reportWithdrawToRedeemManager() internal virtual;
+
+    /// @notice Requests exits of validators after possibly rebalancing deposit and redeem balances
+    /// @param _exitingBalance The currently exiting funds, soon to be received on the execution layer
+    /// @param _depositToRedeemRebalancingAllowed True if rebalancing from deposit to redeem is allowed
+    function _requestExitsBasedOnRedeemDemandAfterRebalancings(
+        uint256 _exitingBalance,
+        uint32[] memory _stoppedValidatorCounts,
+        bool _depositToRedeemRebalancingAllowed,
+        bool _slashingContainmentModeEnabled
+    ) internal virtual;
+
+    /// @notice Skims the redeem balance and sends remaining funds to the deposit balance
+    function _skimExcessBalanceToRedeem() internal virtual;
+
+    /// @notice Commits the deposit balance up to the allowed daily limit
+    /// @param _period The period between current and last report
+    function _commitBalanceToDeposit(uint256 _period) internal virtual;
+
+    /// @notice Prevents unauthorized calls
+    modifier onlyAdmin_OMV1() {
+        if (msg.sender != _getRiverAdmin()) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+        _;
+    }
+
+    /// @notice Set the initial oracle address
+    /// @param _oracle Address of the oracle
+    function initOracleManagerV1(address _oracle) internal {
+        OracleAddress.set(_oracle);
+        emit SetOracle(_oracle);
+    }
+
+    /// @notice Initializes version 1.1 of the oracle manager
+    /// @param _epochsPerFrame The amounts of epochs in a frame
+    /// @param _slotsPerEpoch The slots inside an epoch
+    /// @param _secondsPerSlot The seconds inside a slot
+    /// @param _genesisTime The genesis timestamp
+    /// @param _epochsToAssumedFinality The number of epochs before an epoch is considered final on-chain
+    /// @param _annualAprUpperBound The reporting upper bound
+    /// @param _relativeLowerBound The reporting lower bound
+    function initOracleManagerV1_1(
+        uint64 _epochsPerFrame,
+        uint64 _slotsPerEpoch,
+        uint64 _secondsPerSlot,
+        uint64 _genesisTime,
+        uint64 _epochsToAssumedFinality,
+        uint256 _annualAprUpperBound,
+        uint256 _relativeLowerBound
+    ) internal {
+        CLSpec.set(
+            CLSpec.CLSpecStruct({
+                epochsPerFrame: _epochsPerFrame,
+                slotsPerEpoch: _slotsPerEpoch,
+                secondsPerSlot: _secondsPerSlot,
+                genesisTime: _genesisTime,
+                epochsToAssumedFinality: _epochsToAssumedFinality
+            })
+        );
+        emit SetSpec(_epochsPerFrame, _slotsPerEpoch, _secondsPerSlot, _genesisTime, _epochsToAssumedFinality);
+        ReportBounds.set(
+            ReportBounds.ReportBoundsStruct({
+                annualAprUpperBound: _annualAprUpperBound,
+                relativeLowerBound: _relativeLowerBound
+            })
+        );
+        emit SetBounds(_annualAprUpperBound, _relativeLowerBound);
+
+        IOracleManagerV1.StoredConsensusLayerReport memory storedReport;
+        storedReport.epoch = uint256(LastOracleRoundId.get());
+        storedReport.validatorsBalance = CLValidatorTotalBalance.get();
+        storedReport.validatorsSkimmedBalance = 0;
+        storedReport.validatorsExitedBalance = 0;
+        storedReport.validatorsExitingBalance = 0;
+        storedReport.validatorsCount = uint32(CLValidatorCount.get());
+        storedReport.rebalanceDepositToRedeemMode = false;
+        storedReport.slashingContainmentMode = false;
+        LastConsensusLayerReport.set(storedReport);
+    }
+
+    /// @inheritdoc IOracleManagerV1
+    function getOracle() external view returns (address) {
+        return OracleAddress.get();
+    }
+
+    /// @inheritdoc IOracleManagerV1
+    function getCLValidatorTotalBalance() external view returns (uint256) {
+        return LastConsensusLayerReport.get().validatorsBalance;
+    }
+
+    /// @inheritdoc IOracleManagerV1
+    function getCLValidatorCount() external view returns (uint256) {
+        return LastConsensusLayerReport.get().validatorsCount;
+    }
+
+    /// @inheritdoc IOracleManagerV1
+    function getExpectedEpochId() external view returns (uint256) {
+        CLSpec.CLSpecStruct memory cls = CLSpec.get();
+        uint256 currentEpoch = _currentEpoch(cls);
+        return LibUint256.max(
+            LastConsensusLayerReport.get().epoch + cls.epochsPerFrame,
+            currentEpoch - (currentEpoch % cls.epochsPerFrame)
+        );
+    }
+
+    /// @inheritdoc IOracleManagerV1
+    function isValidEpoch(uint256 _epoch) external view returns (bool) {
+        return _isValidEpoch(CLSpec.get(), _epoch);
+    }
+
+    /// @inheritdoc IOracleManagerV1
+    function getTime() external view returns (uint256) {
+        return block.timestamp;
+    }
+
+    /// @inheritdoc IOracleManagerV1
+    function getLastCompletedEpochId() external view returns (uint256) {
+        return LastConsensusLayerReport.get().epoch;
+    }
+
+    /// @inheritdoc IOracleManagerV1
+    function getCurrentEpochId() external view returns (uint256) {
+        return _currentEpoch(CLSpec.get());
+    }
+
+    /// @inheritdoc IOracleManagerV1
+    function getCLSpec() external view returns (CLSpec.CLSpecStruct memory) {
+        return CLSpec.get();
+    }
+
+    /// @inheritdoc IOracleManagerV1
+    function getCurrentFrame() external view returns (uint256 _startEpochId, uint256 _startTime, uint256 _endTime) {
+        CLSpec.CLSpecStruct memory cls = CLSpec.get();
+        uint256 currentEpoch = _currentEpoch(cls);
+        _startEpochId = currentEpoch - (currentEpoch % cls.epochsPerFrame);
+        _startTime = _startEpochId * cls.slotsPerEpoch * cls.secondsPerSlot;
+        _endTime = (_startEpochId + cls.epochsPerFrame) * cls.slotsPerEpoch * cls.secondsPerSlot - 1;
+    }
+
+    /// @inheritdoc IOracleManagerV1
+    function getFrameFirstEpochId(uint256 _epochId) external view returns (uint256) {
+        return _epochId - (_epochId % CLSpec.get().epochsPerFrame);
+    }
+
+    /// @inheritdoc IOracleManagerV1
+    function getReportBounds() external view returns (ReportBounds.ReportBoundsStruct memory) {
+        return ReportBounds.get();
+    }
+
+    /// @inheritdoc IOracleManagerV1
+    function getLastConsensusLayerReport() external view returns (IOracleManagerV1.StoredConsensusLayerReport memory) {
+        return LastConsensusLayerReport.get();
+    }
+
+    /// @inheritdoc IOracleManagerV1
+    function setOracle(address _oracleAddress) external onlyAdmin_OMV1 {
+        OracleAddress.set(_oracleAddress);
+        emit SetOracle(_oracleAddress);
+    }
+
+    /// @inheritdoc IOracleManagerV1
+    function setCLSpec(CLSpec.CLSpecStruct calldata _newValue) external onlyAdmin_OMV1 {
+        CLSpec.set(_newValue);
+        emit SetSpec(
+            _newValue.epochsPerFrame,
+            _newValue.slotsPerEpoch,
+            _newValue.secondsPerSlot,
+            _newValue.genesisTime,
+            _newValue.epochsToAssumedFinality
+        );
+    }
+
+    /// @inheritdoc IOracleManagerV1
+    function setReportBounds(ReportBounds.ReportBoundsStruct calldata _newValue) external onlyAdmin_OMV1 {
+        ReportBounds.set(_newValue);
+        emit SetBounds(_newValue.annualAprUpperBound, _newValue.relativeLowerBound);
+    }
+
+    /// @notice Structure holding internal variables used during reporting
+    struct ConsensusLayerDataReportingVariables {
+        uint256 preReportUnderlyingBalance;
+        uint256 postReportUnderlyingBalance;
+        uint256 lastReportExitedBalance;
+        uint256 lastReportSkimmedBalance;
+        uint256 exitedAmountIncrease;
+        uint256 skimmedAmountIncrease;
+        uint256 timeElapsedSinceLastReport;
+        uint256 availableAmountToUpperBound;
+        uint256 redeemManagerDemand;
+        ConsensusLayerDataReportingTrace trace;
+    }
+
+    /// @inheritdoc IOracleManagerV1
+    function setConsensusLayerData(IOracleManagerV1.ConsensusLayerReport calldata _report) external {
+        // only the oracle is allowed to call this endpoint
+        if (msg.sender != OracleAddress.get()) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+
+        CLSpec.CLSpecStruct memory cls = CLSpec.get();
+
+        // we start by verifying that the reported epoch is valid based on the consensus layer spec
+        if (!_isValidEpoch(cls, _report.epoch)) {
+            revert InvalidEpoch(_report.epoch);
+        }
+
+        ConsensusLayerDataReportingVariables memory vars;
+
+        {
+            IOracleManagerV1.StoredConsensusLayerReport storage lastStoredReport = LastConsensusLayerReport.get();
+
+            vars.lastReportExitedBalance = lastStoredReport.validatorsExitedBalance;
+
+            // we ensure that the reported total exited balance is not decreasing
+            if (_report.validatorsExitedBalance < vars.lastReportExitedBalance) {
+                revert InvalidDecreasingValidatorsExitedBalance(
+                    vars.lastReportExitedBalance, _report.validatorsExitedBalance
+                );
+            }
+
+            // we compute the exited amount increase by taking the delta between reports
+            vars.exitedAmountIncrease = _report.validatorsExitedBalance - vars.lastReportExitedBalance;
+
+            vars.lastReportSkimmedBalance = lastStoredReport.validatorsSkimmedBalance;
+
+            // we ensure that the reported total skimmed balance is not decreasing
+            if (_report.validatorsSkimmedBalance < vars.lastReportSkimmedBalance) {
+                revert InvalidDecreasingValidatorsSkimmedBalance(
+                    vars.lastReportSkimmedBalance, _report.validatorsSkimmedBalance
+                );
+            }
+
+            // we ensure that the reported validator count is not decreasing
+            if (
+                _report.validatorsCount > DepositedValidatorCount.get()
+                    || _report.validatorsCount < lastStoredReport.validatorsCount
+            ) {
+                revert InvalidValidatorCountReport(
+                    _report.validatorsCount, DepositedValidatorCount.get(), lastStoredReport.validatorsCount
+                );
+            }
+
+            // we compute the new skimmed amount by taking the delta between reports
+            vars.skimmedAmountIncrease = _report.validatorsSkimmedBalance - vars.lastReportSkimmedBalance;
+
+            vars.timeElapsedSinceLastReport = _timeBetweenEpochs(cls, lastStoredReport.epoch, _report.epoch);
+        }
+
+        // we retrieve the current total underlying balance before any reporting data is applied to the system
+        vars.preReportUnderlyingBalance = _assetBalance();
+
+        // if we have new exited / skimmed eth available, we pull funds from the consensus layer recipient
+        if (vars.exitedAmountIncrease + vars.skimmedAmountIncrease > 0) {
+            // this method pulls and updates ethToDeposit / ethToRedeem accordingly
+            _pullCLFunds(vars.skimmedAmountIncrease, vars.exitedAmountIncrease);
+        }
+
+        {
+            // we update the system parameters, this will have an impact on how the total underlying balance is computed
+            IOracleManagerV1.StoredConsensusLayerReport memory storedReport;
+
+            storedReport.epoch = _report.epoch;
+            storedReport.validatorsBalance = _report.validatorsBalance;
+            storedReport.validatorsSkimmedBalance = _report.validatorsSkimmedBalance;
+            storedReport.validatorsExitedBalance = _report.validatorsExitedBalance;
+            storedReport.validatorsExitingBalance = _report.validatorsExitingBalance;
+            storedReport.validatorsCount = _report.validatorsCount;
+            storedReport.rebalanceDepositToRedeemMode = _report.rebalanceDepositToRedeemMode;
+            storedReport.slashingContainmentMode = _report.slashingContainmentMode;
+            LastConsensusLayerReport.set(storedReport);
+        }
+
+        ReportBounds.ReportBoundsStruct memory rb = ReportBounds.get();
+
+        // we compute the maximum allowed increase in balance based on the pre report value
+        uint256 maxIncrease = _maxIncrease(rb, vars.preReportUnderlyingBalance, vars.timeElapsedSinceLastReport);
+
+        // we retrieve the new total underlying balance after system parameters are changed
+        vars.postReportUnderlyingBalance = _assetBalance();
+
+        // we can now compute the earned rewards from the consensus layer balances
+        // in order to properly account for the balance increase, we compare the sums of current balances, skimmed balance and exited balances
+        // we also synthetically increase the current balance by 32 eth per new activated validator, this way we have no discrepency due
+        // to currently activating funds that were not yet accounted in the consensus layer balances
+        if (vars.postReportUnderlyingBalance >= vars.preReportUnderlyingBalance) {
+            // if this happens, we revert and the reporting process is cancelled
+            if (vars.postReportUnderlyingBalance > vars.preReportUnderlyingBalance + maxIncrease) {
+                revert TotalValidatorBalanceIncreaseOutOfBound(
+                    vars.preReportUnderlyingBalance,
+                    vars.postReportUnderlyingBalance,
+                    vars.timeElapsedSinceLastReport,
+                    rb.annualAprUpperBound
+                );
+            }
+
+            // we update the rewards based on the balance delta
+            vars.trace.rewards = vars.postReportUnderlyingBalance - vars.preReportUnderlyingBalance;
+
+            // we update the available amount to upper bound (the amount of eth we can still pull and stay below the upper reporting bound)
+            vars.availableAmountToUpperBound = maxIncrease - vars.trace.rewards;
+        } else {
+            // otherwise if the balance has decreased, we verify that we are not exceeding the lower reporting bound
+
+            // we compute the maximum allowed decrease in balance
+            uint256 maxDecrease = _maxDecrease(rb, vars.preReportUnderlyingBalance);
+
+            // we verify that the bound is not crossed
+            if (
+                vars.postReportUnderlyingBalance
+                    < vars.preReportUnderlyingBalance - LibUint256.min(maxDecrease, vars.preReportUnderlyingBalance)
+            ) {
+                revert TotalValidatorBalanceDecreaseOutOfBound(
+                    vars.preReportUnderlyingBalance,
+                    vars.postReportUnderlyingBalance,
+                    vars.timeElapsedSinceLastReport,
+                    rb.relativeLowerBound
+                );
+            }
+
+            // we update the available amount to upper bound to be equal to the maximum allowed increase plus the negative delta due to the loss
+            vars.availableAmountToUpperBound =
+                maxIncrease + (vars.preReportUnderlyingBalance - vars.postReportUnderlyingBalance);
+        }
+
+        // if we have available amount to upper bound after the reporting values are applied
+        if (vars.availableAmountToUpperBound > 0) {
+            // we pull the funds from the execution layer fee recipient
+            vars.trace.pulledELFees = _pullELFees(vars.availableAmountToUpperBound);
+            // we update the rewards
+            vars.trace.rewards += vars.trace.pulledELFees;
+            // we update the available amount accordingly
+            vars.availableAmountToUpperBound -= vars.trace.pulledELFees;
+        }
+
+        // if we have available amount to upper bound after the execution layer fees are pulled
+        if (vars.availableAmountToUpperBound > 0) {
+            // we pull the funds from the exceeding eth buffer of the redeem manager
+            vars.trace.pulledRedeemManagerExceedingEthBuffer =
+                _pullRedeemManagerExceedingEth(vars.availableAmountToUpperBound);
+            // we update the available amount accordingly
+            vars.availableAmountToUpperBound -= vars.trace.pulledRedeemManagerExceedingEthBuffer;
+        }
+
+        // if we have available amount to upper bound after pulling the exceeding eth buffer, we attempt to pull coverage funds
+        if (vars.availableAmountToUpperBound > 0) {
+            // we pull the funds from the coverage recipient
+            vars.trace.pulledCoverageFunds = _pullCoverageFunds(vars.availableAmountToUpperBound);
+            // we do not update the rewards as coverage is not considered rewards
+            // we do not update the available amount as there are no more pulling actions to perform afterwards
+        }
+
+        // if our rewards are not null, we dispatch the fee to the collector
+        if (vars.trace.rewards > 0) {
+            _onEarnings(vars.trace.rewards);
+        }
+
+        _requestExitsBasedOnRedeemDemandAfterRebalancings(
+            _report.validatorsExitingBalance,
+            _report.stoppedValidatorCountPerOperator,
+            _report.rebalanceDepositToRedeemMode,
+            _report.slashingContainmentMode
+        );
+
+        // we use the updated balanceToRedeem value to report a withdraw event on the redeem manager
+        _reportWithdrawToRedeemManager();
+
+        // if funds are left in the balance to redeem, we move them to the deposit balance
+        _skimExcessBalanceToRedeem();
+
+        // we update the committable amount based on daily maximum allowed
+        _commitBalanceToDeposit(vars.timeElapsedSinceLastReport);
+
+        // we emit a summary event with all the reporting details
+        emit ProcessedConsensusLayerReport(_report, vars.trace);
+    }
+
+    /// @notice Retrieve the current epoch based on the current timestamp
+    /// @param _cls The consensus layer spec struct
+    /// @return The current epoch
+    function _currentEpoch(CLSpec.CLSpecStruct memory _cls) internal view returns (uint256) {
+        return ((block.timestamp - _cls.genesisTime) / _cls.secondsPerSlot) / _cls.slotsPerEpoch;
+    }
+
+    /// @notice Verifies if the given epoch is valid
+    /// @param _cls The consensus layer spec struct
+    /// @param _epoch The epoch to verify
+    /// @return True if valid
+    function _isValidEpoch(CLSpec.CLSpecStruct memory _cls, uint256 _epoch) internal view returns (bool) {
+        return (
+            _currentEpoch(_cls) >= _epoch + _cls.epochsToAssumedFinality
+                && _epoch > LastConsensusLayerReport.get().epoch && _epoch % _cls.epochsPerFrame == 0
+        );
+    }
+
+    /// @notice Retrieves the maximum increase in balance based on current total underlying supply and period since last report
+    /// @param _rb The report bounds struct
+    /// @param _prevTotalEth The total underlying supply during reporting
+    /// @param _timeElapsed The time since last report
+    /// @return The maximum allowed increase in balance
+    function _maxIncrease(ReportBounds.ReportBoundsStruct memory _rb, uint256 _prevTotalEth, uint256 _timeElapsed)
+        internal
+        pure
+        returns (uint256)
+    {
+        return (_prevTotalEth * _rb.annualAprUpperBound * _timeElapsed) / (LibBasisPoints.BASIS_POINTS_MAX * ONE_YEAR);
+    }
+
+    /// @notice Retrieves the maximum decrease in balance based on current total underlying supply
+    /// @param _rb The report bounds struct
+    /// @param _prevTotalEth The total underlying supply during reporting
+    /// @return The maximum allowed decrease in balance
+    function _maxDecrease(ReportBounds.ReportBoundsStruct memory _rb, uint256 _prevTotalEth)
+        internal
+        pure
+        returns (uint256)
+    {
+        return (_prevTotalEth * _rb.relativeLowerBound) / LibBasisPoints.BASIS_POINTS_MAX;
+    }
+
+    /// @notice Retrieve the number of seconds between two epochs
+    /// @param _cls The consensus layer spec struct
+    /// @param _epochPast The starting epoch
+    /// @param _epochNow The current epoch
+    /// @return The number of seconds between the two epochs
+    function _timeBetweenEpochs(CLSpec.CLSpecStruct memory _cls, uint256 _epochPast, uint256 _epochNow)
+        internal
+        pure
+        returns (uint256)
+    {
+        return (_epochNow - _epochPast) * (_cls.secondsPerSlot * _cls.slotsPerEpoch);
+    }
+}
diff -ruN src/contracts/src/components/SharesManager.1.sol contracts/src/components/SharesManager.1.sol
--- src/contracts/src/components/SharesManager.1.sol	1970-01-01 01:00:00
+++ contracts/src/components/SharesManager.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,277 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../interfaces/components/ISharesManager.1.sol";
+
+import "../libraries/LibSanitize.sol";
+
+import "../state/river/Shares.sol";
+import "../state/river/SharesPerOwner.sol";
+import "../state/shared/ApprovalsPerOwner.sol";
+
+/// @title Shares Manager (v1)
+/// @author Kiln
+/// @notice This contract handles the shares of the depositor and the ERC20 interface
+abstract contract SharesManagerV1 is ISharesManagerV1 {
+    /// @notice Internal hook triggered on the external transfer call
+    /// @dev Must be overridden
+    /// @param _from Address of the sender
+    /// @param _to Address of the recipient
+    function _onTransfer(address _from, address _to) internal view virtual;
+
+    /// @notice Internal method to override to provide the total underlying asset balance
+    /// @dev Must be overridden
+    /// @return The total asset balance of the system
+    function _assetBalance() internal view virtual returns (uint256);
+
+    /// @notice Modifier used to ensure that the transfer is allowed by using the internal hook to perform internal checks
+    /// @param _from Address of the sender
+    /// @param _to Address of the recipient
+    modifier transferAllowed(address _from, address _to) {
+        _onTransfer(_from, _to);
+        _;
+    }
+
+    /// @notice Modifier used to ensure the amount transferred is not 0
+    /// @param _value Amount to check
+    modifier isNotZero(uint256 _value) {
+        if (_value == 0) {
+            revert NullTransfer();
+        }
+        _;
+    }
+
+    /// @notice Modifier used to ensure that the sender has enough funds for the transfer
+    /// @param _owner Address of the sender
+    /// @param _value Value that is required to be sent
+    modifier hasFunds(address _owner, uint256 _value) {
+        if (_balanceOf(_owner) < _value) {
+            revert BalanceTooLow();
+        }
+        _;
+    }
+
+    /// @inheritdoc ISharesManagerV1
+    function name() external pure returns (string memory) {
+        return "Liquid Staked ETH";
+    }
+
+    /// @inheritdoc ISharesManagerV1
+    function symbol() external pure returns (string memory) {
+        return "LsETH";
+    }
+
+    /// @inheritdoc ISharesManagerV1
+    function decimals() external pure returns (uint8) {
+        return 18;
+    }
+
+    /// @inheritdoc ISharesManagerV1
+    function totalSupply() external view returns (uint256) {
+        return _totalSupply();
+    }
+
+    /// @inheritdoc ISharesManagerV1
+    function totalUnderlyingSupply() external view returns (uint256) {
+        return _assetBalance();
+    }
+
+    /// @inheritdoc ISharesManagerV1
+    function balanceOf(address _owner) external view returns (uint256) {
+        return _balanceOf(_owner);
+    }
+
+    /// @inheritdoc ISharesManagerV1
+    function balanceOfUnderlying(address _owner) public view returns (uint256) {
+        return _balanceFromShares(SharesPerOwner.get(_owner));
+    }
+
+    /// @inheritdoc ISharesManagerV1
+    function underlyingBalanceFromShares(uint256 _shares) external view returns (uint256) {
+        return _balanceFromShares(_shares);
+    }
+
+    /// @inheritdoc ISharesManagerV1
+    function sharesFromUnderlyingBalance(uint256 _underlyingAssetAmount) external view returns (uint256) {
+        return _sharesFromBalance(_underlyingAssetAmount);
+    }
+
+    /// @inheritdoc ISharesManagerV1
+    function allowance(address _owner, address _spender) external view returns (uint256) {
+        return ApprovalsPerOwner.get(_owner, _spender);
+    }
+
+    /// @inheritdoc ISharesManagerV1
+    function transfer(address _to, uint256 _value)
+        external
+        transferAllowed(msg.sender, _to)
+        isNotZero(_value)
+        hasFunds(msg.sender, _value)
+        returns (bool)
+    {
+        if (_to == address(0)) {
+            revert UnauthorizedTransfer(msg.sender, address(0));
+        }
+        return _transfer(msg.sender, _to, _value);
+    }
+
+    /// @inheritdoc ISharesManagerV1
+    function transferFrom(address _from, address _to, uint256 _value)
+        external
+        transferAllowed(_from, _to)
+        isNotZero(_value)
+        hasFunds(_from, _value)
+        returns (bool)
+    {
+        if (_to == address(0)) {
+            revert UnauthorizedTransfer(_from, address(0));
+        }
+        _spendAllowance(_from, _value);
+        return _transfer(_from, _to, _value);
+    }
+
+    /// @inheritdoc ISharesManagerV1
+    function approve(address _spender, uint256 _value) external returns (bool) {
+        _approve(msg.sender, _spender, _value);
+        return true;
+    }
+
+    /// @inheritdoc ISharesManagerV1
+    function increaseAllowance(address _spender, uint256 _additionalValue) external returns (bool) {
+        _approve(msg.sender, _spender, ApprovalsPerOwner.get(msg.sender, _spender) + _additionalValue);
+        return true;
+    }
+
+    /// @inheritdoc ISharesManagerV1
+    function decreaseAllowance(address _spender, uint256 _subtractableValue) external returns (bool) {
+        _approve(msg.sender, _spender, ApprovalsPerOwner.get(msg.sender, _spender) - _subtractableValue);
+        return true;
+    }
+
+    /// @notice Internal utility to spend the allowance of an account from the message sender
+    /// @param _from Address owning the allowance
+    /// @param _value Amount of allowance in shares to spend
+    function _spendAllowance(address _from, uint256 _value) internal {
+        uint256 currentAllowance = ApprovalsPerOwner.get(_from, msg.sender);
+        if (currentAllowance < _value) {
+            revert AllowanceTooLow(_from, msg.sender, currentAllowance, _value);
+        }
+        if (currentAllowance != type(uint256).max) {
+            _approve(_from, msg.sender, currentAllowance - _value);
+        }
+    }
+
+    /// @notice Internal utility to change the allowance of an owner to a spender
+    /// @param _owner The owner of the shares
+    /// @param _spender The allowed spender of the shares
+    /// @param _value The new allowance value
+    function _approve(address _owner, address _spender, uint256 _value) internal {
+        LibSanitize._notZeroAddress(_owner);
+        LibSanitize._notZeroAddress(_spender);
+        ApprovalsPerOwner.set(_owner, _spender, _value);
+        emit Approval(_owner, _spender, _value);
+    }
+
+    /// @notice Internal utility to retrieve the total supply of tokens
+    /// @return The total supply
+    function _totalSupply() internal view returns (uint256) {
+        return Shares.get();
+    }
+
+    /// @notice Internal utility to perform an unchecked transfer
+    /// @param _from Address sending the tokens
+    /// @param _to Address receiving the tokens
+    /// @param _value Amount of shares to be sent
+    /// @return True if success
+    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {
+        SharesPerOwner.set(_from, SharesPerOwner.get(_from) - _value);
+        SharesPerOwner.set(_to, SharesPerOwner.get(_to) + _value);
+
+        emit Transfer(_from, _to, _value);
+
+        return true;
+    }
+
+    function mulDivDown(uint256 a, uint256 b, uint256 c) internal pure returns (uint256 res)
+    {
+        res = a * b / c;
+    }
+
+    /// @notice Internal utility to retrieve the underlying asset balance for the given shares
+    /// @param _shares Amount of shares to convert
+    /// @return The balance from the given shares
+    function _balanceFromShares(uint256 _shares) internal view returns (uint256) {
+        uint256 _totalSharesValue = Shares.get();
+
+        if (_totalSharesValue == 0) {
+            return 0;
+        }
+
+        // return ((_shares * _assetBalance())) / _totalSharesValue;
+        return mulDivDown(_shares , _assetBalance(), _totalSharesValue); // Munged by Certora
+    }
+
+    /// @notice Internal utility to retrieve the shares count for a given underlying asset amount
+    /// @param _balance Amount of underlying asset balance to convert
+    /// @return The shares from the given balance
+    function _sharesFromBalance(uint256 _balance) internal view returns (uint256) {
+        uint256 _totalSharesValue = Shares.get();
+
+        if (_totalSharesValue == 0) {
+            return 0;
+        }
+
+        // return (_balance * _totalSharesValue) / _assetBalance();
+        return mulDivDown(_balance, _totalSharesValue, _assetBalance()); // Munged by Certora
+    }
+
+    /// @notice Internal utility to mint shares for the specified user
+    /// @dev This method assumes that funds received are now part of the _assetBalance()
+    /// @param _owner Account that should receive the new shares
+    /// @param _underlyingAssetValue Value of underlying asset received, to convert into shares
+    /// @return sharesToMint The amnount of minted shares
+    function _mintShares(address _owner, uint256 _underlyingAssetValue) internal returns (uint256 sharesToMint) {
+        uint256 oldTotalAssetBalance = _assetBalance() - _underlyingAssetValue;
+
+        if (oldTotalAssetBalance == 0) {
+            sharesToMint = _underlyingAssetValue;
+            _mintRawShares(_owner, _underlyingAssetValue);
+        } else {
+            // sharesToMint = (_underlyingAssetValue * _totalSupply()) / oldTotalAssetBalance;
+            sharesToMint = mulDivDown(_underlyingAssetValue, _totalSupply(), oldTotalAssetBalance); // Munged by Certora
+            _mintRawShares(_owner, sharesToMint);
+        }
+    }
+
+    /// @notice Internal utility to retrieve the amount of shares per owner
+    /// @param _owner Account to be checked
+    /// @return The balance of the account in shares
+    function _balanceOf(address _owner) internal view returns (uint256) {
+        return SharesPerOwner.get(_owner);
+    }
+
+    /// @notice Internal utility to mint shares without any conversion, and emits a mint Transfer event
+    /// @param _owner Account that should receive the new shares
+    /// @param _value Amount of shares to mint
+    function _mintRawShares(address _owner, uint256 _value) internal {
+        _setTotalSupply(Shares.get() + _value);
+        SharesPerOwner.set(_owner, SharesPerOwner.get(_owner) + _value);
+        emit Transfer(address(0), _owner, _value);
+    }
+
+    /// @notice Internal utility to burn shares without any conversion, and emits a burn Transfer event
+    /// @param _owner Account that should burn its shares
+    /// @param _value Amount of shares to burn
+    function _burnRawShares(address _owner, uint256 _value) internal {
+        _setTotalSupply(Shares.get() - _value);
+        SharesPerOwner.set(_owner, SharesPerOwner.get(_owner) - _value);
+        emit Transfer(_owner, address(0), _value);
+    }
+
+    /// @notice Internal utility to set the total supply and emit an event
+    /// @param newTotalSupply The new total supply value
+    function _setTotalSupply(uint256 newTotalSupply) internal {
+        Shares.set(newTotalSupply);
+        emit SetTotalSupply(newTotalSupply);
+    }
+}
diff -ruN src/contracts/src/components/UserDepositManager.1.sol contracts/src/components/UserDepositManager.1.sol
--- src/contracts/src/components/UserDepositManager.1.sol	1970-01-01 01:00:00
+++ contracts/src/components/UserDepositManager.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,56 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../interfaces/components/IUserDepositManager.1.sol";
+
+import "../libraries/LibSanitize.sol";
+
+import "../state/river/BalanceToDeposit.sol";
+
+/// @title User Deposit Manager (v1)
+/// @author Kiln
+/// @notice This contract handles the inbound transfers cases or the explicit submissions
+abstract contract UserDepositManagerV1 is IUserDepositManagerV1 {
+    /// @notice Handler called whenever a user has sent funds to the contract
+    /// @dev Must be overridden
+    /// @param _depositor Address that made the deposit
+    /// @param _recipient Address that receives the minted shares
+    /// @param _amount Amount deposited
+    function _onDeposit(address _depositor, address _recipient, uint256 _amount) internal virtual;
+    function _setBalanceToDeposit(uint256 newBalanceToDeposit) internal virtual;
+
+    /// @inheritdoc IUserDepositManagerV1
+    function deposit() external payable {
+        _deposit(msg.sender);
+    }
+
+    /// @inheritdoc IUserDepositManagerV1
+    function depositAndTransfer(address _recipient) external payable {
+        LibSanitize._notZeroAddress(_recipient);
+        _deposit(_recipient);
+    }
+
+    /// @inheritdoc IUserDepositManagerV1
+    receive() external payable {
+        _deposit(msg.sender);
+    }
+
+    /// @inheritdoc IUserDepositManagerV1
+    fallback() external payable {
+        revert LibErrors.InvalidCall();
+    }
+
+    /// @notice Internal utility calling the deposit handler and emitting the deposit details
+    /// @param _recipient The account receiving the minted shares
+    function _deposit(address _recipient) internal {
+        if (msg.value == 0) {
+            revert EmptyDeposit();
+        }
+
+        _setBalanceToDeposit(BalanceToDeposit.get() + msg.value);
+
+        _onDeposit(msg.sender, _recipient, msg.value);
+
+        emit UserDeposit(msg.sender, _recipient, msg.value);
+    }
+}
diff -ruN src/contracts/src/interfaces/IAdministrable.sol contracts/src/interfaces/IAdministrable.sol
--- src/contracts/src/interfaces/IAdministrable.sol	1970-01-01 01:00:00
+++ contracts/src/interfaces/IAdministrable.sol	2024-01-16 15:06:39
@@ -0,0 +1,34 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Administrable Interface
+/// @author Kiln
+/// @notice This interface exposes methods to handle the ownership of the contracts
+interface IAdministrable {
+    /// @notice The pending admin address changed
+    /// @param pendingAdmin New pending admin address
+    event SetPendingAdmin(address indexed pendingAdmin);
+
+    /// @notice The admin address changed
+    /// @param admin New admin address
+    event SetAdmin(address indexed admin);
+
+    /// @notice Retrieves the current admin address
+    /// @return The admin address
+    function getAdmin() external view returns (address);
+
+    /// @notice Retrieve the current pending admin address
+    /// @return The pending admin address
+    function getPendingAdmin() external view returns (address);
+
+    /// @notice Proposes a new address as admin
+    /// @dev This security prevents setting an invalid address as an admin. The pending
+    /// @dev admin has to claim its ownership of the contract, and prove that the new
+    /// @dev address is able to perform regular transactions.
+    /// @param _newAdmin New admin address
+    function proposeAdmin(address _newAdmin) external;
+
+    /// @notice Accept the transfer of ownership
+    /// @dev Only callable by the pending admin. Resets the pending admin if succesful.
+    function acceptAdmin() external;
+}
diff -ruN src/contracts/src/interfaces/IAllowlist.1.sol contracts/src/interfaces/IAllowlist.1.sol
--- src/contracts/src/interfaces/IAllowlist.1.sol	1970-01-01 01:00:00
+++ contracts/src/interfaces/IAllowlist.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,107 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Allowlist Interface (v1)
+/// @author Kiln
+/// @notice This interface exposes methods to handle the list of allowed recipients.
+interface IAllowlistV1 {
+    /// @notice The permissions of several accounts have changed
+    /// @param accounts List of accounts
+    /// @param permissions New permissions for each account at the same index
+    event SetAllowlistPermissions(address[] accounts, uint256[] permissions);
+
+    /// @notice The stored allower address has been changed
+    /// @param allower The new allower address
+    event SetAllower(address indexed allower);
+
+    /// @notice The stored denier address has been changed
+    /// @param denier The new denier address
+    event SetDenier(address indexed denier);
+
+    /// @notice The provided accounts list is empty
+    error InvalidCount();
+
+    /// @notice The account is denied access
+    /// @param _account The denied account
+    error Denied(address _account);
+
+    /// @notice The provided accounts and permissions list have different lengths
+    error MismatchedArrayLengths();
+
+    /// @notice Allower can't set deny permission
+    error AttemptToSetDenyPermission();
+
+    /// @notice Allower can't remove deny permission
+    error AttemptToRemoveDenyPermission();
+
+    /// @notice Initializes the allowlist
+    /// @param _admin Address of the Allowlist administrator
+    /// @param _allower Address of the allower
+    function initAllowlistV1(address _admin, address _allower) external;
+
+    /// @notice Initializes the allowlist denier
+    /// @param _denier Address of the denier
+    function initAllowlistV1_1(address _denier) external;
+
+    /// @notice Retrieves the allower address
+    /// @return The address of the allower
+    function getAllower() external view returns (address);
+
+    /// @notice Retrieves the denier address
+    /// @return The address of the denier
+    function getDenier() external view returns (address);
+
+    /// @notice This method returns true if the user has the expected permission and
+    ///         is not in the deny list
+    /// @param _account Recipient to verify
+    /// @param _mask Combination of permissions to verify
+    /// @return True if mask is respected and user is allowed
+    function isAllowed(address _account, uint256 _mask) external view returns (bool);
+
+    /// @notice This method returns true if the user is in the deny list
+    /// @param _account Recipient to verify
+    /// @return True if user is denied access
+    function isDenied(address _account) external view returns (bool);
+
+    /// @notice This method returns true if the user has the expected permission
+    ///         ignoring any deny list membership
+    /// @param _account Recipient to verify
+    /// @param _mask Combination of permissions to verify
+    /// @return True if mask is respected
+    function hasPermission(address _account, uint256 _mask) external view returns (bool);
+
+    /// @notice This method retrieves the raw permission value
+    /// @param _account Recipient to verify
+    /// @return The raw permissions value of the account
+    function getPermissions(address _account) external view returns (uint256);
+
+    /// @notice This method should be used as a modifier and is expected to revert
+    ///         if the user hasn't got the required permission or if the user is
+    ///         in the deny list.
+    /// @param _account Recipient to verify
+    /// @param _mask Combination of permissions to verify
+    function onlyAllowed(address _account, uint256 _mask) external view;
+
+    /// @notice Changes the allower address
+    /// @param _newAllowerAddress New address allowed to edit the allowlist
+    function setAllower(address _newAllowerAddress) external;
+
+    /// @notice Changes the denier address
+    /// @param _newDenierAddress New address allowed to edit the allowlist
+    function setDenier(address _newDenierAddress) external;
+
+    /// @notice Sets the allow permissions for one or more accounts
+    /// @dev This function is for allocating or removing deposit, redeem or donate permissions.
+    ///      This function could be used to give any permissions that we come up with in the future.
+    ///      An address which was denied has to be undenied first before they could be given any permission(s).
+    /// @param _accounts Accounts to update
+    /// @param _permissions New permission values
+    function setAllowPermissions(address[] calldata _accounts, uint256[] calldata _permissions) external;
+
+    /// @notice Sets the deny permissions for one or more accounts
+    /// @dev This function is for allocating or removing deny permissions.
+    ///      An address which is undenied has to be given permissions again for them to be able to deposit, donate or redeem.
+    /// @param _accounts Accounts to update
+    /// @param _permissions New permission values
+    function setDenyPermissions(address[] calldata _accounts, uint256[] calldata _permissions) external;
+}
diff -ruN src/contracts/src/interfaces/ICoverageFund.1.sol contracts/src/interfaces/ICoverageFund.1.sol
--- src/contracts/src/interfaces/ICoverageFund.1.sol	1970-01-01 01:00:00
+++ contracts/src/interfaces/ICoverageFund.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,40 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Coverage Fund Interface (v1)
+/// @author Kiln
+/// @notice This interface exposes methods to receive donations for the slashing coverage fund and pull the funds into river
+interface ICoverageFundV1 {
+    /// @notice The storage river address has changed
+    /// @param river The new river address
+    event SetRiver(address indexed river);
+
+    /// @notice A donation has been made to the coverage fund
+    /// @param donator Address that performed the donation
+    /// @param amount The amount donated
+    event Donate(address indexed donator, uint256 amount);
+
+    /// @notice The fallback or receive callback has been triggered
+    error InvalidCall();
+
+    /// @notice A donation with 0 ETH has been performed
+    error EmptyDonation();
+
+    /// @notice Initialize the coverage fund with the required arguments
+    /// @param _riverAddress Address of River
+    function initCoverageFundV1(address _riverAddress) external;
+
+    /// @notice Pulls ETH into the River contract
+    /// @dev Only callable by the River contract
+    /// @param _maxAmount The maximum amount to pull into the system
+    function pullCoverageFunds(uint256 _maxAmount) external;
+
+    /// @notice Donates ETH to the coverage fund contract
+    function donate() external payable;
+
+    /// @notice Ether receiver
+    receive() external payable;
+
+    /// @notice Invalid fallback detector
+    fallback() external payable;
+}
diff -ruN src/contracts/src/interfaces/IDepositContract.sol contracts/src/interfaces/IDepositContract.sol
--- src/contracts/src/interfaces/IDepositContract.sol	1970-01-01 01:00:00
+++ contracts/src/interfaces/IDepositContract.sol	2024-01-16 15:06:39
@@ -0,0 +1,18 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Deposit Contract Interface
+/// @notice This interface exposes methods to perform validator deposits
+interface IDepositContract {
+    /// @notice Official deposit method to activate a validator on the consensus layer
+    /// @param pubkey The 48 bytes long BLS Public key representing the validator
+    /// @param withdrawalCredentials The 32 bytes long withdrawal credentials, configures the withdrawal recipient
+    /// @param signature The 96 bytes long BLS Signature performed by the pubkey's private key
+    /// @param depositDataRoot The root hash of the whole deposit data structure
+    function deposit(
+        bytes calldata pubkey,
+        bytes calldata withdrawalCredentials,
+        bytes calldata signature,
+        bytes32 depositDataRoot
+    ) external payable;
+}
diff -ruN src/contracts/src/interfaces/IELFeeRecipient.1.sol contracts/src/interfaces/IELFeeRecipient.1.sol
--- src/contracts/src/interfaces/IELFeeRecipient.1.sol	1970-01-01 01:00:00
+++ contracts/src/interfaces/IELFeeRecipient.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,29 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Execution Layer Fee Recipient Interface (v1)
+/// @author Kiln
+/// @notice This interface exposes methods to receive all the execution layer fees from the proposed blocks + bribes
+interface IELFeeRecipientV1 {
+    /// @notice The storage river address has changed
+    /// @param river The new river address
+    event SetRiver(address indexed river);
+
+    /// @notice The fallback has been triggered
+    error InvalidCall();
+
+    /// @notice Initialize the fee recipient with the required arguments
+    /// @param _riverAddress Address of River
+    function initELFeeRecipientV1(address _riverAddress) external;
+
+    /// @notice Pulls ETH to the River contract
+    /// @dev Only callable by the River contract
+    /// @param _maxAmount The maximum amount to pull into the system
+    function pullELFees(uint256 _maxAmount) external;
+
+    /// @notice Ether receiver
+    receive() external payable;
+
+    /// @notice Invalid fallback detector
+    fallback() external payable;
+}
diff -ruN src/contracts/src/interfaces/IFirewall.sol contracts/src/interfaces/IFirewall.sol
--- src/contracts/src/interfaces/IFirewall.sol	1970-01-01 01:00:00
+++ contracts/src/interfaces/IFirewall.sol	2024-01-16 15:06:39
@@ -0,0 +1,48 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Firewall
+/// @author Figment
+/// @notice This interface exposes methods to accept calls to admin-level functions of an underlying contract.
+interface IFirewall {
+    /// @notice The stored executor address has been changed
+    /// @param executor The new executor address
+    event SetExecutor(address indexed executor);
+
+    /// @notice The stored destination address has been changed
+    /// @param destination The new destination address
+    event SetDestination(address indexed destination);
+
+    /// @notice The storage permission for a selector has been changed
+    /// @param selector The 4 bytes method selector
+    /// @param status True if executor is allowed
+    event SetExecutorPermissions(bytes4 selector, bool status);
+
+    /// @notice Retrieve the executor address
+    /// @return The executor address
+    function executor() external view returns (address);
+
+    /// @notice Retrieve the destination address
+    /// @return The destination address
+    function destination() external view returns (address);
+
+    /// @notice Returns true if the executor is allowed to perform a call on the given selector
+    /// @param _selector The selector to verify
+    /// @return True if executor is allowed to call
+    function executorCanCall(bytes4 _selector) external view returns (bool);
+
+    /// @notice Sets the executor address
+    /// @param _newExecutor New address for the executor
+    function setExecutor(address _newExecutor) external;
+
+    /// @notice Sets the permission for a function selector
+    /// @param _functionSelector Method signature on which the permission is changed
+    /// @param _executorCanCall True if selector is callable by the executor
+    function allowExecutor(bytes4 _functionSelector, bool _executorCanCall) external;
+
+    /// @notice Fallback method. All its parameters are forwarded to the destination if caller is authorized
+    fallback() external payable;
+
+    /// @notice Receive fallback method. All its parameters are forwarded to the destination if caller is authorized
+    receive() external payable;
+}
diff -ruN src/contracts/src/interfaces/IOperatorRegistry.1.sol contracts/src/interfaces/IOperatorRegistry.1.sol
--- src/contracts/src/interfaces/IOperatorRegistry.1.sol	1970-01-01 01:00:00
+++ contracts/src/interfaces/IOperatorRegistry.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,333 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../state/operatorsRegistry/Operators.2.sol";
+
+/// @title Operators Registry Interface (v1)
+/// @author Kiln
+/// @notice This interface exposes methods to handle the list of operators and their keys
+interface IOperatorsRegistryV1 {
+    /// @notice A new operator has been added to the registry
+    /// @param index The operator index
+    /// @param name The operator display name
+    /// @param operatorAddress The operator address
+    event AddedOperator(uint256 indexed index, string name, address indexed operatorAddress);
+
+    /// @notice The operator status has been changed
+    /// @param index The operator index
+    /// @param active True if the operator is active
+    event SetOperatorStatus(uint256 indexed index, bool active);
+
+    /// @notice The operator limit has been changed
+    /// @param index The operator index
+    /// @param newLimit The new operator staking limit
+    event SetOperatorLimit(uint256 indexed index, uint256 newLimit);
+
+    /// @notice The operator stopped validator count has been changed
+    /// @param index The operator index
+    /// @param newStoppedValidatorCount The new stopped validator count
+    event SetOperatorStoppedValidatorCount(uint256 indexed index, uint256 newStoppedValidatorCount);
+
+    /// @notice The operator address has been changed
+    /// @param index The operator index
+    /// @param newOperatorAddress The new operator address
+    event SetOperatorAddress(uint256 indexed index, address indexed newOperatorAddress);
+
+    /// @notice The operator display name has been changed
+    /// @param index The operator index
+    /// @param newName The new display name
+    event SetOperatorName(uint256 indexed index, string newName);
+
+    /// @notice The operator or the admin added new validator keys and signatures
+    /// @dev The public keys and signatures are concatenated
+    /// @dev A public key is 48 bytes long
+    /// @dev A signature is 96 bytes long
+    /// @dev [P1, S1, P2, S2, ..., PN, SN] where N is the bytes length divided by (96 + 48)
+    /// @param index The operator index
+    /// @param publicKeysAndSignatures The concatenated public keys and signatures
+    event AddedValidatorKeys(uint256 indexed index, bytes publicKeysAndSignatures);
+
+    /// @notice The operator or the admin removed a public key and its signature from the registry
+    /// @param index The operator index
+    /// @param publicKey The BLS public key that has been removed
+    event RemovedValidatorKey(uint256 indexed index, bytes publicKey);
+
+    /// @notice The stored river address has been changed
+    /// @param river The new river address
+    event SetRiver(address indexed river);
+
+    /// @notice The operator edited its keys after the snapshot block
+    /// @dev This means that we cannot assume that its key set is checked by the snapshot
+    /// @dev This happens only if the limit was meant to be increased
+    /// @param index The operator index
+    /// @param currentLimit The current operator limit
+    /// @param newLimit The new operator limit that was attempted to be set
+    /// @param latestKeysEditBlockNumber The last block number at which the operator changed its keys
+    /// @param snapshotBlock The block number of the snapshot
+    event OperatorEditsAfterSnapshot(
+        uint256 indexed index,
+        uint256 currentLimit,
+        uint256 newLimit,
+        uint256 indexed latestKeysEditBlockNumber,
+        uint256 indexed snapshotBlock
+    );
+
+    /// @notice The call didn't alter the limit of the operator
+    /// @param index The operator index
+    /// @param limit The limit of the operator
+    event OperatorLimitUnchanged(uint256 indexed index, uint256 limit);
+
+    /// @notice The stopped validator array has been changed
+    /// @notice A validator is considered stopped if exiting, exited or slashed
+    /// @notice This event is emitted when the oracle reports new stopped validators counts
+    /// @param stoppedValidatorCounts The new stopped validator counts
+    event UpdatedStoppedValidators(uint32[] stoppedValidatorCounts);
+
+    /// @notice The requested exit count has been updated
+    /// @param index The operator index
+    /// @param count The count of requested exits
+    event RequestedValidatorExits(uint256 indexed index, uint256 count);
+
+    /// @notice The exit request demand has been updated
+    /// @param previousValidatorExitsDemand The previous exit request demand
+    /// @param nextValidatorExitsDemand The new exit request demand
+    event SetCurrentValidatorExitsDemand(uint256 previousValidatorExitsDemand, uint256 nextValidatorExitsDemand);
+
+    /// @notice The total requested exit has been updated
+    /// @param previousTotalValidatorExitsRequested The previous total requested exit
+    /// @param newTotalValidatorExitsRequested The new total requested exit
+    event SetTotalValidatorExitsRequested(
+        uint256 previousTotalValidatorExitsRequested, uint256 newTotalValidatorExitsRequested
+    );
+
+    /// @notice A validator key got funded on the deposit contract
+    /// @notice This event was introduced during a contract upgrade, in order to cover all possible public keys, this event
+    /// @notice will be replayed for past funded keys in order to have a complete coverage of all the funded public keys.
+    /// @notice In this particuliar scenario, the deferred value will be set to true, to indicate that we are not going to have
+    /// @notice the expected additional events and side effects in the same transaction (deposit to official DepositContract etc ...) because
+    /// @notice the event was synthetically crafted.
+    /// @param index The operator index
+    /// @param publicKeys BLS Public key that got funded
+    /// @param deferred True if event has been replayed in the context of a migration
+    event FundedValidatorKeys(uint256 indexed index, bytes[] publicKeys, bool deferred);
+
+    /// @notice The requested exit count has been update to fill the gap with the reported stopped count
+    /// @param index The operator index
+    /// @param oldRequestedExits The old requested exit count
+    /// @param newRequestedExits The new requested exit count
+    event UpdatedRequestedValidatorExitsUponStopped(
+        uint256 indexed index, uint32 oldRequestedExits, uint32 newRequestedExits
+    );
+
+    /// @notice The calling operator is inactive
+    /// @param index The operator index
+    error InactiveOperator(uint256 index);
+
+    /// @notice A funded key deletion has been attempted
+    error InvalidFundedKeyDeletionAttempt();
+
+    /// @notice The index provided are not sorted properly (descending order)
+    error InvalidUnsortedIndexes();
+
+    /// @notice The provided operator and limits array have different lengths
+    error InvalidArrayLengths();
+
+    /// @notice The provided operator and limits array are empty
+    error InvalidEmptyArray();
+
+    /// @notice The provided key count is 0
+    error InvalidKeyCount();
+
+    /// @notice The provided concatenated keys do not have the expected length
+    error InvalidKeysLength();
+
+    /// @notice The index that is removed is out of bounds
+    error InvalidIndexOutOfBounds();
+
+    /// @notice The value for the operator limit is too high
+    /// @param index The operator index
+    /// @param limit The new limit provided
+    /// @param keyCount The operator key count
+    error OperatorLimitTooHigh(uint256 index, uint256 limit, uint256 keyCount);
+
+    /// @notice The value for the limit is too low
+    /// @param index The operator index
+    /// @param limit The new limit provided
+    /// @param fundedKeyCount The operator funded key count
+    error OperatorLimitTooLow(uint256 index, uint256 limit, uint256 fundedKeyCount);
+
+    /// @notice The provided list of operators is not in increasing order
+    error UnorderedOperatorList();
+
+    /// @notice Thrown when an invalid empty stopped validator array is provided
+    error InvalidEmptyStoppedValidatorCountsArray();
+
+    /// @notice Thrown when the sum of stopped validators is invalid
+    error InvalidStoppedValidatorCountsSum();
+
+    /// @notice Throw when an element in the stopped validator array is decreasing
+    error StoppedValidatorCountsDecreased();
+
+    /// @notice Thrown when the number of elements in the array is too high compared to operator count
+    error StoppedValidatorCountsTooHigh();
+
+    /// @notice Thrown when no exit requests can be performed
+    error NoExitRequestsToPerform();
+
+    /// @notice The provided stopped validator count array is shrinking
+    error StoppedValidatorCountArrayShrinking();
+
+    /// @notice The provided stopped validator count of an operator is above its funded validator count
+    error StoppedValidatorCountAboveFundedCount(uint256 operatorIndex, uint32 stoppedCount, uint32 fundedCount);
+
+    /// @notice Initializes the operators registry
+    /// @param _admin Admin in charge of managing operators
+    /// @param _river Address of River system
+    function initOperatorsRegistryV1(address _admin, address _river) external;
+
+    /// @notice Initializes the operators registry for V1_1
+    function initOperatorsRegistryV1_1() external;
+
+    /// @notice Retrieve the River address
+    /// @return The address of River
+    function getRiver() external view returns (address);
+
+    /// @notice Get operator details
+    /// @param _index The index of the operator
+    /// @return The details of the operator
+    function getOperator(uint256 _index) external view returns (OperatorsV2.Operator memory);
+
+    /// @notice Get operator count
+    /// @return The operator count
+    function getOperatorCount() external view returns (uint256);
+
+    /// @notice Retrieve the stopped validator count for an operator index
+    /// @param _idx The index of the operator
+    /// @return The stopped validator count of the operator
+    function getOperatorStoppedValidatorCount(uint256 _idx) external view returns (uint32);
+
+    /// @notice Retrieve the total stopped validator count
+    /// @return The total stopped validator count
+    function getTotalStoppedValidatorCount() external view returns (uint32);
+
+    /// @notice Retrieve the total requested exit count
+    /// @notice This value is the amount of exit requests that have been performed, emitting an event for operators to catch
+    /// @return The total requested exit count
+    function getTotalValidatorExitsRequested() external view returns (uint256);
+
+    /// @notice Get the current exit request demand waiting to be triggered
+    /// @notice This value is the amount of exit requests that are demanded and not yet performed by the contract
+    /// @return The current exit request demand
+    function getCurrentValidatorExitsDemand() external view returns (uint256);
+
+    /// @notice Retrieve the total stopped and requested exit count
+    /// @return The total stopped count
+    /// @return The total requested exit count
+    function getStoppedAndRequestedExitCounts() external view returns (uint32, uint256);
+
+    /// @notice Retrieve the raw stopped validators array from storage
+    /// @return The stopped validator array
+    function getStoppedValidatorCountPerOperator() external view returns (uint32[] memory);
+
+    /// @notice Get the details of a validator
+    /// @param _operatorIndex The index of the operator
+    /// @param _validatorIndex The index of the validator
+    /// @return publicKey The public key of the validator
+    /// @return signature The signature used during deposit
+    /// @return funded True if validator has been funded
+    function getValidator(uint256 _operatorIndex, uint256 _validatorIndex)
+        external
+        view
+        returns (bytes memory publicKey, bytes memory signature, bool funded);
+
+    /// @notice Retrieve the active operator set
+    /// @return The list of active operators and their details
+    function listActiveOperators() external view returns (OperatorsV2.Operator[] memory);
+
+    /// @notice Allows river to override the stopped validators array
+    /// @notice This actions happens during the Oracle report processing
+    /// @param _stoppedValidatorCounts The new stopped validators array
+    /// @param _depositedValidatorCount The total deposited validator count
+    function reportStoppedValidatorCounts(uint32[] calldata _stoppedValidatorCounts, uint256 _depositedValidatorCount)
+        external;
+
+    /// @notice Adds an operator to the registry
+    /// @dev Only callable by the administrator
+    /// @param _name The name identifying the operator
+    /// @param _operator The address representing the operator, receiving the rewards
+    /// @return The index of the new operator
+    function addOperator(string calldata _name, address _operator) external returns (uint256);
+
+    /// @notice Changes the operator address of an operator
+    /// @dev Only callable by the administrator or the previous operator address
+    /// @param _index The operator index
+    /// @param _newOperatorAddress The new address of the operator
+    function setOperatorAddress(uint256 _index, address _newOperatorAddress) external;
+
+    /// @notice Changes the operator name
+    /// @dev Only callable by the administrator or the operator
+    /// @param _index The operator index
+    /// @param _newName The new operator name
+    function setOperatorName(uint256 _index, string calldata _newName) external;
+
+    /// @notice Changes the operator status
+    /// @dev Only callable by the administrator
+    /// @param _index The operator index
+    /// @param _newStatus The new status of the operator
+    function setOperatorStatus(uint256 _index, bool _newStatus) external;
+
+    /// @notice Changes the operator staking limit
+    /// @dev Only callable by the administrator
+    /// @dev The operator indexes must be in increasing order and contain no duplicate
+    /// @dev The limit cannot exceed the total key count of the operator
+    /// @dev The _indexes and _newLimits must have the same length.
+    /// @dev Each limit value is applied to the operator index at the same index in the _indexes array.
+    /// @param _operatorIndexes The operator indexes, in increasing order and duplicate free
+    /// @param _newLimits The new staking limit of the operators
+    /// @param _snapshotBlock The block number at which the snapshot was computed
+    function setOperatorLimits(
+        uint256[] calldata _operatorIndexes,
+        uint32[] calldata _newLimits,
+        uint256 _snapshotBlock
+    ) external;
+
+    /// @notice Adds new keys for an operator
+    /// @dev Only callable by the administrator or the operator address
+    /// @param _index The operator index
+    /// @param _keyCount The amount of keys provided
+    /// @param _publicKeysAndSignatures Public keys of the validator, concatenated
+    function addValidators(uint256 _index, uint32 _keyCount, bytes calldata _publicKeysAndSignatures) external;
+
+    /// @notice Remove validator keys
+    /// @dev Only callable by the administrator or the operator address
+    /// @dev The indexes must be provided sorted in decreasing order and duplicate-free, otherwise the method will revert
+    /// @dev The operator limit will be set to the lowest deleted key index if the operator's limit wasn't equal to its total key count
+    /// @dev The operator or the admin cannot remove funded keys
+    /// @dev When removing validators, the indexes of specific unfunded keys can be changed in order to properly
+    /// @dev remove the keys from the storage array. Beware of this specific behavior when chaining calls as the
+    /// @dev targeted public key indexes can point to a different key after a first call was made and performed
+    /// @dev some swaps
+    /// @param _index The operator index
+    /// @param _indexes The indexes of the keys to remove
+    function removeValidators(uint256 _index, uint256[] calldata _indexes) external;
+
+    /// @notice Retrieve validator keys based on operator statuses
+    /// @param _count Max amount of keys requested
+    /// @return publicKeys An array of public keys
+    /// @return signatures An array of signatures linked to the public keys
+    function pickNextValidatorsToDeposit(uint256 _count)
+        external
+        returns (bytes[] memory publicKeys, bytes[] memory signatures);
+
+    /// @notice Public endpoint to consume the exit request demand and perform the actual exit requests
+    /// @notice The selection algorithm will pick validators based on their active validator counts
+    /// @notice This value is computed by using the count of funded keys and taking into account the stopped validator counts and exit requests
+    /// @param _count Max amount of exits to request
+    function requestValidatorExits(uint256 _count) external;
+
+    /// @notice Increases the exit request demand
+    /// @dev This method is only callable by the river contract, and to actually forward the information to the node operators via event emission, the unprotected requestValidatorExits method must be called
+    /// @param _count The amount of exit requests to add to the demand
+    /// @param _depositedValidatorCount The total deposited validator count
+    function demandValidatorExits(uint256 _count, uint256 _depositedValidatorCount) external;
+}
diff -ruN src/contracts/src/interfaces/IOracle.1.sol contracts/src/interfaces/IOracle.1.sol
--- src/contracts/src/interfaces/IOracle.1.sol	1970-01-01 01:00:00
+++ contracts/src/interfaces/IOracle.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,184 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "./IRiver.1.sol";
+import "../state/oracle/ReportsVariants.sol";
+
+/// @title Oracle Interface (v1)
+/// @author Kiln
+/// @notice This interface exposes methods to handle the input from the allowed oracle members.
+/// @notice Highly inspired by Lido's implementation.
+interface IOracleV1 {
+    /// @notice The storage quorum value has been changed
+    /// @param newQuorum The new quorum value
+    event SetQuorum(uint256 newQuorum);
+
+    /// @notice A member has been added to the oracle member list
+    /// @param member The address of the member
+    event AddMember(address indexed member);
+
+    /// @notice A member has been removed from the oracle member list
+    /// @param member The address of the member
+    event RemoveMember(address indexed member);
+
+    /// @notice A member address has been edited
+    /// @param oldAddress The previous member address
+    /// @param newAddress The new member address
+    event SetMember(address indexed oldAddress, address indexed newAddress);
+
+    /// @notice The storage river address value has been changed
+    /// @param _river The new river address
+    event SetRiver(address _river);
+
+    /// @notice The consensus layer spec has been changed
+    /// @param epochsPerFrame The number of epochs inside a frame (225 = 24 hours)
+    /// @param slotsPerEpoch The number of slots inside an epoch (32 on ethereum mainnet)
+    /// @param secondsPerSlot The time between two slots (12 seconds on ethereum mainnet)
+    /// @param genesisTime The timestamp of block #0
+    event SetSpec(uint64 epochsPerFrame, uint64 slotsPerEpoch, uint64 secondsPerSlot, uint64 genesisTime);
+
+    /// @notice The report bounds have been changed
+    /// @param annualAprUpperBound The maximum allowed apr. 10% means increases in balance extrapolated to a year should not exceed 10%.
+    /// @param relativeLowerBound The maximum allowed balance decrease as a relative % of the total balance
+    event SetBounds(uint256 annualAprUpperBound, uint256 relativeLowerBound);
+
+    /// @notice An oracle member performed a report
+    /// @param member The oracle member
+    /// @param variant The variant of the report
+    /// @param report The raw report structure
+    /// @param voteCount The vote count
+    event ReportedConsensusLayerData(
+        address indexed member,
+        bytes32 indexed variant,
+        IRiverV1.ConsensusLayerReport report,
+        uint256 voteCount,
+        uint256 quorum
+    );
+
+    /// @notice The last reported epoch has changed
+    event SetLastReportedEpoch(uint256 lastReportedEpoch);
+
+    /// @notice Cleared reporting data
+    event ClearedReporting();
+
+    /// @notice The provided epoch is too old compared to the expected epoch id
+    /// @param providedEpochId The epoch id provided as input
+    /// @param minExpectedEpochId The minimum epoch id expected
+    error EpochTooOld(uint256 providedEpochId, uint256 minExpectedEpochId);
+
+    /// @notice Thrown when the reported epoch is invalid
+    /// @param epoch The invalid epoch
+    error InvalidEpoch(uint256 epoch);
+
+    /// @notice Thrown when the report indexs fetched is out of bounds
+    /// @param index Requested index
+    /// @param length Size of the variant array
+    error ReportIndexOutOfBounds(uint256 index, uint256 length);
+
+    /// @notice The member already reported on the given epoch id
+    /// @param epochId The epoch id provided as input
+    /// @param member The oracle member
+    error AlreadyReported(uint256 epochId, address member);
+
+    /// @notice The address is already in use by an oracle member
+    /// @param newAddress The address already in use
+    error AddressAlreadyInUse(address newAddress);
+
+    /// @notice Initializes the oracle
+    /// @param _river Address of the River contract, able to receive oracle input data after quorum is met
+    /// @param _administratorAddress Address able to call administrative methods
+    /// @param _epochsPerFrame CL spec parameter. Number of epochs in a frame.
+    /// @param _slotsPerEpoch CL spec parameter. Number of slots in one epoch.
+    /// @param _secondsPerSlot CL spec parameter. Number of seconds between slots.
+    /// @param _genesisTime CL spec parameter. Timestamp of the genesis slot.
+    /// @param _annualAprUpperBound CL bound parameter. Maximum apr allowed for balance increase. Delta between updates is extrapolated on a year time frame.
+    /// @param _relativeLowerBound CL bound parameter. Maximum relative balance decrease.
+    function initOracleV1(
+        address _river,
+        address _administratorAddress,
+        uint64 _epochsPerFrame,
+        uint64 _slotsPerEpoch,
+        uint64 _secondsPerSlot,
+        uint64 _genesisTime,
+        uint256 _annualAprUpperBound,
+        uint256 _relativeLowerBound
+    ) external;
+
+    /// @notice Initializes the oracle
+    function initOracleV1_1() external;
+
+    /// @notice Retrieve River address
+    /// @return The address of River
+    function getRiver() external view returns (address);
+
+    /// @notice Retrieve member report status
+    /// @param _oracleMember Address of member to check
+    /// @return True if member has reported
+    function getMemberReportStatus(address _oracleMember) external view returns (bool);
+
+    /// @notice Retrieve member report status
+    /// @return The raw report status value
+    function getGlobalReportStatus() external view returns (uint256);
+
+    /// @notice Retrieve report variants count
+    /// @return The count of report variants
+    function getReportVariantsCount() external view returns (uint256);
+
+    /// @notice Retrieve the details of a report variant
+    /// @param _idx The index of the report variant
+    /// @return The report variant details
+    function getReportVariantDetails(uint256 _idx)
+        external
+        view
+        returns (ReportsVariants.ReportVariantDetails memory);
+
+    /// @notice Retrieve the current quorum
+    /// @return The current quorum
+    function getQuorum() external view returns (uint256);
+
+    /// @notice Retrieve the list of oracle members
+    /// @return The oracle members
+    function getOracleMembers() external view returns (address[] memory);
+
+    /// @notice Returns true if address is member
+    /// @dev Performs a naive search, do not call this on-chain, used as an off-chain helper
+    /// @param _memberAddress Address of the member
+    /// @return True if address is a member
+    function isMember(address _memberAddress) external view returns (bool);
+
+    /// @notice Retrieve the last reported epoch id
+    /// @dev The Oracle contracts expects reports on an epoch id >= that the returned value
+    /// @return The last reported epoch id
+    function getLastReportedEpochId() external view returns (uint256);
+
+    /// @notice Adds new address as oracle member, giving the ability to push cl reports.
+    /// @dev Only callable by the adminstrator
+    /// @dev Modifying the quorum clears all the reporting data
+    /// @param _newOracleMember Address of the new member
+    /// @param _newQuorum New quorum value
+    function addMember(address _newOracleMember, uint256 _newQuorum) external;
+
+    /// @notice Removes an address from the oracle members.
+    /// @dev Only callable by the adminstrator
+    /// @dev Modifying the quorum clears all the reporting data
+    /// @dev Remaining members that have already voted should vote again for the same frame.
+    /// @param _oracleMember Address to remove
+    /// @param _newQuorum New quorum value
+    function removeMember(address _oracleMember, uint256 _newQuorum) external;
+
+    /// @notice Changes the address of an oracle member
+    /// @dev Only callable by the adminitrator or the member itself
+    /// @dev Cannot use an address already in use
+    /// @param _oracleMember Address to change
+    /// @param _newAddress New address for the member
+    function setMember(address _oracleMember, address _newAddress) external;
+
+    /// @notice Edits the quorum required to forward cl data to River
+    /// @dev Modifying the quorum clears all the reporting data
+    /// @param _newQuorum New quorum parameter
+    function setQuorum(uint256 _newQuorum) external;
+
+    /// @notice Submit a report as an oracle member
+    /// @param _report The report structure
+    function reportConsensusLayerData(IRiverV1.ConsensusLayerReport calldata _report) external;
+}
diff -ruN src/contracts/src/interfaces/IRedeemManager.1.sol contracts/src/interfaces/IRedeemManager.1.sol
--- src/contracts/src/interfaces/IRedeemManager.1.sol	1970-01-01 01:00:00
+++ contracts/src/interfaces/IRedeemManager.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,190 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../state/redeemManager/RedeemQueue.sol";
+import "../state/redeemManager/WithdrawalStack.sol";
+
+/// @title Redeem Manager Interface (v1)
+/// @author Kiln
+/// @notice This contract handles the redeem requests of all users
+interface IRedeemManagerV1 {
+    /// @notice Emitted when a redeem request is created
+    /// @param owner The owner of the redeem request
+    /// @param height The height of the redeem request in LsETH
+    /// @param amount The amount of the redeem request in LsETH
+    /// @param maxRedeemableEth The maximum amount of eth that can be redeemed from this request
+    /// @param id The id of the new redeem request
+    event RequestedRedeem(address indexed owner, uint256 height, uint256 amount, uint256 maxRedeemableEth, uint32 id);
+
+    /// @notice Emitted when a withdrawal event is created
+    /// @param height The height of the withdrawal event in LsETH
+    /// @param amount The amount of the withdrawal event in LsETH
+    /// @param ethAmount The amount of eth to distrubute to claimers
+    /// @param id The id of the withdrawal event
+    event ReportedWithdrawal(uint256 height, uint256 amount, uint256 ethAmount, uint32 id);
+
+    /// @notice Emitted when a redeem request has been satisfied and filled (even partially) from a withdrawal event
+    /// @param redeemRequestId The id of the redeem request
+    /// @param withdrawalEventId The id of the withdrawal event used to fill the request
+    /// @param lsEthAmountSatisfied The amount of LsETH filled
+    /// @param ethAmountSatisfied The amount of ETH filled
+    /// @param lsEthAmountRemaining The amount of LsETH remaining
+    /// @param ethAmountExceeding The amount of eth added to the exceeding buffer
+    event SatisfiedRedeemRequest(
+        uint32 indexed redeemRequestId,
+        uint32 indexed withdrawalEventId,
+        uint256 lsEthAmountSatisfied,
+        uint256 ethAmountSatisfied,
+        uint256 lsEthAmountRemaining,
+        uint256 ethAmountExceeding
+    );
+
+    /// @notice Emitted when a redeem request claim has been processed and matched at least once and funds are sent to the recipient
+    /// @param redeemRequestId The id of the redeem request
+    /// @param recipient The address receiving the redeem request funds
+    /// @param ethAmount The amount of eth retrieved
+    /// @param lsEthAmount The total amount of LsETH used to redeem the eth
+    /// @param remainingLsEthAmount The amount of LsETH remaining
+    event ClaimedRedeemRequest(
+        uint32 indexed redeemRequestId,
+        address indexed recipient,
+        uint256 ethAmount,
+        uint256 lsEthAmount,
+        uint256 remainingLsEthAmount
+    );
+
+    /// @notice Emitted when the redeem demand is set
+    /// @param oldRedeemDemand The old redeem demand
+    /// @param newRedeemDemand The new redeem demand
+    event SetRedeemDemand(uint256 oldRedeemDemand, uint256 newRedeemDemand);
+
+    /// @notice Emitted when the River address is set
+    /// @param river The new river address
+    event SetRiver(address river);
+
+    /// @notice Thrown When a zero value is provided
+    error InvalidZeroAmount();
+
+    /// @notice Thrown when a transfer error occured with LsETH
+    error TransferError();
+
+    /// @notice Thrown when the provided arrays don't have matching lengths
+    error IncompatibleArrayLengths();
+
+    /// @notice Thrown when the provided redeem request id is out of bounds
+    /// @param id The redeem request id
+    error RedeemRequestOutOfBounds(uint256 id);
+
+    /// @notice Thrown when the withdrawal request id if out of bounds
+    /// @param id The withdrawal event id
+    error WithdrawalEventOutOfBounds(uint256 id);
+
+    /// @notice Thrown when	the redeem request id is already claimed
+    /// @param id The redeem request id
+    error RedeemRequestAlreadyClaimed(uint256 id);
+
+    /// @notice Thrown when the redeem request and withdrawal event are not matching during claim
+    /// @param redeemRequestId The provided redeem request id
+    /// @param withdrawalEventId The provided associated withdrawal event id
+    error DoesNotMatch(uint256 redeemRequestId, uint256 withdrawalEventId);
+
+    /// @notice Thrown when the provided withdrawal event exceeds the redeem demand
+    /// @param withdrawalAmount The amount of the withdrawal event
+    /// @param redeemDemand The current redeem demand
+    error WithdrawalExceedsRedeemDemand(uint256 withdrawalAmount, uint256 redeemDemand);
+
+    /// @notice Thrown when the payment after a claim failed
+    /// @param recipient The recipient of the payment
+    /// @param rdata The revert data
+    error ClaimRedeemFailed(address recipient, bytes rdata);
+
+    /// @param _river The address of the River contract
+    function initializeRedeemManagerV1(address _river) external;
+
+    /// @notice Retrieve River address
+    /// @return The address of River
+    function getRiver() external view returns (address);
+
+    /// @notice Retrieve the global count of redeem requests
+    function getRedeemRequestCount() external view returns (uint256);
+
+    /// @notice Retrieve the details of a specific redeem request
+    /// @param _redeemRequestId The id of the request
+    /// @return The redeem request details
+    function getRedeemRequestDetails(uint32 _redeemRequestId)
+        external
+        view
+        returns (RedeemQueue.RedeemRequest memory);
+
+    /// @notice Retrieve the global count of withdrawal events
+    function getWithdrawalEventCount() external view returns (uint256);
+
+    /// @notice Retrieve the details of a specific withdrawal event
+    /// @param _withdrawalEventId The id of the withdrawal event
+    /// @return The withdrawal event details
+    function getWithdrawalEventDetails(uint32 _withdrawalEventId)
+        external
+        view
+        returns (WithdrawalStack.WithdrawalEvent memory);
+
+    /// @notice Retrieve the amount of redeemed LsETH pending to be supplied with withdrawn ETH
+    /// @return The amount of eth in the buffer
+    function getBufferedExceedingEth() external view returns (uint256);
+
+    /// @notice Retrieve the amount of LsETH waiting to be exited
+    /// @return The amount of LsETH waiting to be exited
+    function getRedeemDemand() external view returns (uint256);
+
+    /// @notice Resolves the provided list of redeem request ids
+    /// @dev The result is an array of equal length with ids or error code
+    /// @dev -1 means that the request is not satisfied yet
+    /// @dev -2 means that the request is out of bounds
+    /// @dev -3 means that the request has already been claimed
+    /// @dev This call was created to be called by an off-chain interface, the output could then be used to perform the claimRewards call in a regular transaction
+    /// @param _redeemRequestIds The list of redeem requests to resolve
+    /// @return withdrawalEventIds The list of withdrawal events matching every redeem request (or error codes)
+    function resolveRedeemRequests(uint32[] calldata _redeemRequestIds)
+        external
+        view
+        returns (int64[] memory withdrawalEventIds);
+
+    /// @notice Creates a redeem request
+    /// @param _lsETHAmount The amount of LsETH to redeem
+    /// @param _recipient The recipient owning the redeem request
+    /// @return redeemRequestId The id of the redeem request
+    function requestRedeem(uint256 _lsETHAmount, address _recipient) external returns (uint32 redeemRequestId);
+
+    /// @notice Creates a redeem request using msg.sender as recipient
+    /// @param _lsETHAmount The amount of LsETH to redeem
+    /// @return redeemRequestId The id of the redeem request
+    function requestRedeem(uint256 _lsETHAmount) external returns (uint32 redeemRequestId);
+
+    /// @notice Claims the rewards of the provided redeem request ids
+    /// @param _redeemRequestIds The list of redeem requests to claim
+    /// @param _withdrawalEventIds The list of withdrawal events to use for every redeem request claim
+    /// @param _skipAlreadyClaimed True if the call should not revert on claiming of already claimed requests
+    /// @param _depth The maximum recursive depth for the resolution of the redeem requests
+    /// @return claimStatuses The list of claim statuses. 0 for fully claimed, 1 for partially claimed, 2 for skipped
+    function claimRedeemRequests(
+        uint32[] calldata _redeemRequestIds,
+        uint32[] calldata _withdrawalEventIds,
+        bool _skipAlreadyClaimed,
+        uint16 _depth
+    ) external returns (uint8[] memory claimStatuses);
+
+    /// @notice Claims the rewards of the provided redeem request ids
+    /// @param _redeemRequestIds The list of redeem requests to claim
+    /// @param _withdrawalEventIds The list of withdrawal events to use for every redeem request claim
+    /// @return claimStatuses The list of claim statuses. 0 for fully claimed, 1 for partially claimed, 2 for skipped
+    function claimRedeemRequests(uint32[] calldata _redeemRequestIds, uint32[] calldata _withdrawalEventIds)
+        external
+        returns (uint8[] memory claimStatuses);
+
+    /// @notice Reports a withdraw event from River
+    /// @param _lsETHWithdrawable The amount of LsETH that can be redeemed due to this new withdraw event
+    function reportWithdraw(uint256 _lsETHWithdrawable) external payable;
+
+    /// @notice Pulls exceeding buffer eth
+    /// @param _max The maximum amount that should be pulled
+    function pullExceedingEth(uint256 _max) external;
+}
diff -ruN src/contracts/src/interfaces/IRiver.1.sol contracts/src/interfaces/IRiver.1.sol
--- src/contracts/src/interfaces/IRiver.1.sol	1970-01-01 01:00:00
+++ contracts/src/interfaces/IRiver.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,271 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../state/river/DailyCommittableLimits.sol";
+
+import "./components/IConsensusLayerDepositManager.1.sol";
+import "./components/IOracleManager.1.sol";
+import "./components/ISharesManager.1.sol";
+import "./components/IUserDepositManager.1.sol";
+
+/// @title River Interface (v1)
+/// @author Kiln
+/// @notice The main system interface
+interface IRiverV1 is IConsensusLayerDepositManagerV1, IUserDepositManagerV1, ISharesManagerV1, IOracleManagerV1 {
+    /// @notice Funds have been pulled from the Execution Layer Fee Recipient
+    /// @param amount The amount pulled
+    event PulledELFees(uint256 amount);
+
+    /// @notice Funds have been pulled from the Coverage Fund
+    /// @param amount The amount pulled
+    event PulledCoverageFunds(uint256 amount);
+
+    /// @notice Emitted when funds are pulled from the redeem manager
+    /// @param amount The amount pulled
+    event PulledRedeemManagerExceedingEth(uint256 amount);
+
+    /// @notice Emitted when funds are pulled from the CL recipient
+    /// @param pulledSkimmedEthAmount The amount of skimmed ETH pulled
+    /// @param pullExitedEthAmount The amount of exited ETH pulled
+    event PulledCLFunds(uint256 pulledSkimmedEthAmount, uint256 pullExitedEthAmount);
+
+    /// @notice The stored Execution Layer Fee Recipient has been changed
+    /// @param elFeeRecipient The new Execution Layer Fee Recipient
+    event SetELFeeRecipient(address indexed elFeeRecipient);
+
+    /// @notice The stored Coverage Fund has been changed
+    /// @param coverageFund The new Coverage Fund
+    event SetCoverageFund(address indexed coverageFund);
+
+    /// @notice The stored Collector has been changed
+    /// @param collector The new Collector
+    event SetCollector(address indexed collector);
+
+    /// @notice The stored Allowlist has been changed
+    /// @param allowlist The new Allowlist
+    event SetAllowlist(address indexed allowlist);
+
+    /// @notice The stored Global Fee has been changed
+    /// @param fee The new Global Fee
+    event SetGlobalFee(uint256 fee);
+
+    /// @notice The stored Operators Registry has been changed
+    /// @param operatorRegistry The new Operators Registry
+    event SetOperatorsRegistry(address indexed operatorRegistry);
+
+    /// @notice The stored Metadata URI string has been changed
+    /// @param metadataURI The new Metadata URI string
+    event SetMetadataURI(string metadataURI);
+
+    /// @notice The system underlying supply increased. This is a snapshot of the balances for accounting purposes
+    /// @param _collector The address of the collector during this event
+    /// @param _oldTotalUnderlyingBalance Old total ETH balance under management by River
+    /// @param _oldTotalSupply Old total supply in shares
+    /// @param _newTotalUnderlyingBalance New total ETH balance under management by River
+    /// @param _newTotalSupply New total supply in shares
+    event RewardsEarned(
+        address indexed _collector,
+        uint256 _oldTotalUnderlyingBalance,
+        uint256 _oldTotalSupply,
+        uint256 _newTotalUnderlyingBalance,
+        uint256 _newTotalSupply
+    );
+
+    /// @notice Emitted when the daily committable limits are changed
+    /// @param minNetAmount The minimum amount that must be used as the daily committable amount
+    /// @param maxRelativeAmount The maximum amount that can be used as the daily committable amount, relative to the total underlying supply
+    event SetMaxDailyCommittableAmounts(uint256 minNetAmount, uint256 maxRelativeAmount);
+
+    /// @notice Emitted when the redeem manager address is changed
+    /// @param redeemManager The address of the redeem manager
+    event SetRedeemManager(address redeemManager);
+
+    /// @notice Emitted when the balance to deposit is updated
+    /// @param oldAmount The old balance to deposit
+    /// @param newAmount The new balance to deposit
+    event SetBalanceToDeposit(uint256 oldAmount, uint256 newAmount);
+
+    /// @notice Emitted when the balance to redeem is updated
+    /// @param oldAmount The old balance to redeem
+    /// @param newAmount The new balance to redeem
+    event SetBalanceToRedeem(uint256 oldAmount, uint256 newAmount);
+
+    /// @notice Emitted when the balance committed to deposit
+    /// @param oldAmount The old balance committed to deposit
+    /// @param newAmount The new balance committed to deposit
+    event SetBalanceCommittedToDeposit(uint256 oldAmount, uint256 newAmount);
+
+    /// @notice Emitted when the redeem manager received a withdraw event report
+    /// @param redeemManagerDemand The total demand in LsETH of the redeem manager
+    /// @param suppliedRedeemManagerDemand The amount of LsETH demand actually supplied
+    /// @param suppliedRedeemManagerDemandInEth The amount in ETH of the supplied demand
+    event ReportedRedeemManager(
+        uint256 redeemManagerDemand, uint256 suppliedRedeemManagerDemand, uint256 suppliedRedeemManagerDemandInEth
+    );
+
+    /// @notice Thrown when the amount received from the Withdraw contract doe not match the requested amount
+    /// @param requested The amount that was requested
+    /// @param received The amount that was received
+    error InvalidPulledClFundsAmount(uint256 requested, uint256 received);
+
+    /// @notice The computed amount of shares to mint is 0
+    error ZeroMintedShares();
+
+    /// @notice The access was denied
+    /// @param account The account that was denied
+    error Denied(address account);
+
+    /// @notice Initializes the River system
+    /// @param _depositContractAddress Address to make Consensus Layer deposits
+    /// @param _elFeeRecipientAddress Address that receives the execution layer fees
+    /// @param _withdrawalCredentials Credentials to use for every validator deposit
+    /// @param _oracleAddress The address of the Oracle contract
+    /// @param _systemAdministratorAddress Administrator address
+    /// @param _allowlistAddress Address of the allowlist contract
+    /// @param _operatorRegistryAddress Address of the operator registry
+    /// @param _collectorAddress Address receiving the the global fee on revenue
+    /// @param _globalFee Amount retained when the ETH balance increases and sent to the collector
+    function initRiverV1(
+        address _depositContractAddress,
+        address _elFeeRecipientAddress,
+        bytes32 _withdrawalCredentials,
+        address _oracleAddress,
+        address _systemAdministratorAddress,
+        address _allowlistAddress,
+        address _operatorRegistryAddress,
+        address _collectorAddress,
+        uint256 _globalFee
+    ) external;
+
+    /// @notice Initialized version 1.1 of the River System
+    /// @param _redeemManager The redeem manager address
+    /// @param _epochsPerFrame The amounts of epochs in a frame
+    /// @param _slotsPerEpoch The slots inside an epoch
+    /// @param _secondsPerSlot The seconds inside a slot
+    /// @param _genesisTime The genesis timestamp
+    /// @param _epochsToAssumedFinality The number of epochs before an epoch is considered final on-chain
+    /// @param _annualAprUpperBound The reporting upper bound
+    /// @param _relativeLowerBound The reporting lower bound
+    /// @param _maxDailyNetCommittableAmount_ The net daily committable limit
+    /// @param _maxDailyRelativeCommittableAmount_ The relative daily committable limit
+    function initRiverV1_1(
+        address _redeemManager,
+        uint64 _epochsPerFrame,
+        uint64 _slotsPerEpoch,
+        uint64 _secondsPerSlot,
+        uint64 _genesisTime,
+        uint64 _epochsToAssumedFinality,
+        uint256 _annualAprUpperBound,
+        uint256 _relativeLowerBound,
+        uint128 _maxDailyNetCommittableAmount_,
+        uint128 _maxDailyRelativeCommittableAmount_
+    ) external;
+
+    /// @notice Initializes version 1.2 of the River System
+    function initRiverV1_2() external;
+
+    /// @notice Get the current global fee
+    /// @return The global fee
+    function getGlobalFee() external view returns (uint256);
+
+    /// @notice Retrieve the allowlist address
+    /// @return The allowlist address
+    function getAllowlist() external view returns (address);
+
+    /// @notice Retrieve the collector address
+    /// @return The collector address
+    function getCollector() external view returns (address);
+
+    /// @notice Retrieve the execution layer fee recipient
+    /// @return The execution layer fee recipient address
+    function getELFeeRecipient() external view returns (address);
+
+    /// @notice Retrieve the coverage fund
+    /// @return The coverage fund address
+    function getCoverageFund() external view returns (address);
+
+    /// @notice Retrieve the redeem manager
+    /// @return The redeem manager address
+    function getRedeemManager() external view returns (address);
+
+    /// @notice Retrieve the operators registry
+    /// @return The operators registry address
+    function getOperatorsRegistry() external view returns (address);
+
+    /// @notice Retrieve the metadata uri string value
+    /// @return The metadata uri string value
+    function getMetadataURI() external view returns (string memory);
+
+    /// @notice Retrieve the configured daily committable limits
+    /// @return The daily committable limits structure
+    function getDailyCommittableLimits()
+        external
+        view
+        returns (DailyCommittableLimits.DailyCommittableLimitsStruct memory);
+
+    /// @notice Resolves the provided redeem requests by calling the redeem manager
+    /// @param _redeemRequestIds The list of redeem requests to resolve
+    /// @return withdrawalEventIds The list of matching withdrawal events, or error codes
+    function resolveRedeemRequests(uint32[] calldata _redeemRequestIds)
+        external
+        view
+        returns (int64[] memory withdrawalEventIds);
+
+    /// @notice Set the daily committable limits
+    /// @param _dcl The Daily Committable Limits structure
+    function setDailyCommittableLimits(DailyCommittableLimits.DailyCommittableLimitsStruct memory _dcl) external;
+
+    /// @notice Retrieve the current balance to redeem
+    /// @return The current balance to redeem
+    function getBalanceToRedeem() external view returns (uint256);
+
+    /// @notice Performs a redeem request on the redeem manager
+    /// @param _lsETHAmount The amount of LsETH to redeem
+    /// @param _recipient The address that will own the redeem request
+    /// @return redeemRequestId The ID of the newly created redeem request
+    function requestRedeem(uint256 _lsETHAmount, address _recipient) external returns (uint32 redeemRequestId);
+
+    /// @notice Claims several redeem requests
+    /// @param _redeemRequestIds The list of redeem requests to claim
+    /// @param _withdrawalEventIds The list of resolved withdrawal event ids
+    /// @return claimStatuses The operation status results
+    function claimRedeemRequests(uint32[] calldata _redeemRequestIds, uint32[] calldata _withdrawalEventIds)
+        external
+        returns (uint8[] memory claimStatuses);
+
+    /// @notice Changes the global fee parameter
+    /// @param _newFee New fee value
+    function setGlobalFee(uint256 _newFee) external;
+
+    /// @notice Changes the allowlist address
+    /// @param _newAllowlist New address for the allowlist
+    function setAllowlist(address _newAllowlist) external;
+
+    /// @notice Changes the collector address
+    /// @param _newCollector New address for the collector
+    function setCollector(address _newCollector) external;
+
+    /// @notice Changes the execution layer fee recipient
+    /// @param _newELFeeRecipient New address for the recipient
+    function setELFeeRecipient(address _newELFeeRecipient) external;
+
+    /// @notice Changes the coverage fund
+    /// @param _newCoverageFund New address for the fund
+    function setCoverageFund(address _newCoverageFund) external;
+
+    /// @notice Sets the metadata uri string value
+    /// @param _metadataURI The new metadata uri string value
+    function setMetadataURI(string memory _metadataURI) external;
+
+    /// @notice Input for execution layer fee earnings
+    function sendELFees() external payable;
+
+    /// @notice Input for consensus layer funds, containing both exit and skimming
+    function sendCLFunds() external payable;
+
+    /// @notice Input for coverage funds
+    function sendCoverageFunds() external payable;
+
+    /// @notice Input for the redeem manager funds
+    function sendRedeemManagerExceedingFunds() external payable;
+}
diff -ruN src/contracts/src/interfaces/ITLC.1.sol contracts/src/interfaces/ITLC.1.sol
--- src/contracts/src/interfaces/ITLC.1.sol	1970-01-01 01:00:00
+++ contracts/src/interfaces/ITLC.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,19 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol";
+import "openzeppelin-contracts-upgradeable/contracts/governance/utils/IVotesUpgradeable.sol";
+
+import "./components/IERC20VestableVotesUpgradeable.1.sol";
+
+/// @title TLC Interface (v1)
+/// @author Alluvial
+/// @notice TLC token interface
+interface ITLCV1 is IERC20Upgradeable, IVotesUpgradeable, IERC20VestableVotesUpgradeableV1 {
+    /// @notice Initializes the TLC Token
+    /// @param _account The initial account to grant all the minted tokens
+    function initTLCV1(address _account) external;
+
+    /// @notice Migrates the vesting schedule state structures
+    function migrateVestingSchedules() external;
+}
diff -ruN src/contracts/src/interfaces/IWLSETH.1.sol contracts/src/interfaces/IWLSETH.1.sol
--- src/contracts/src/interfaces/IWLSETH.1.sol	1970-01-01 01:00:00
+++ contracts/src/interfaces/IWLSETH.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,138 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Wrapped LsETH Interface (v1)
+/// @author Kiln
+/// @notice This interface exposes methods to wrap the LsETH token into a rebase token.
+interface IWLSETHV1 {
+    /// @notice A transfer has been made
+    /// @param from The transfer sender
+    /// @param to The transfer recipient
+    /// @param value The amount transfered
+    event Transfer(address indexed from, address indexed to, uint256 value);
+
+    /// @notice An approval has been made
+    /// @param owner The token owner
+    /// @param spender The account allowed by the owner
+    /// @param value The amount allowed
+    event Approval(address indexed owner, address indexed spender, uint256 value);
+
+    /// @notice Tokens have been minted
+    /// @param recipient The account receiving the new tokens
+    /// @param shares The amount of LsETH provided
+    event Mint(address indexed recipient, uint256 shares);
+
+    /// @notice Tokens have been burned
+    /// @param recipient The account that receive the underlying LsETH
+    /// @param shares The amount of LsETH that got sent back
+    event Burn(address indexed recipient, uint256 shares);
+
+    /// @notice The stored value of river has been changed
+    /// @param river The new address of river
+    event SetRiver(address indexed river);
+
+    /// @notice The token transfer failed during the minting or burning process
+    error TokenTransferError();
+
+    /// @notice Balance too low to perform operation
+    error BalanceTooLow();
+
+    /// @notice Allowance too low to perform operation
+    /// @param _from Account where funds are sent from
+    /// @param _operator Account attempting the transfer
+    /// @param _allowance Current allowance
+    /// @param _value Requested transfer value
+    error AllowanceTooLow(address _from, address _operator, uint256 _allowance, uint256 _value);
+
+    /// @notice Invalid empty transfer
+    error NullTransfer();
+
+    /// @notice Invalid transfer recipients
+    /// @param _from Account sending the funds in the invalid transfer
+    /// @param _to Account receiving the funds in the invalid transfer
+    error UnauthorizedTransfer(address _from, address _to);
+
+    /// @notice Initializes the wrapped token contract
+    /// @param _river Address of the River contract
+    function initWLSETHV1(address _river) external;
+
+    /// @notice Retrieves the token full name
+    /// @return The name of the token
+    function name() external pure returns (string memory);
+
+    /// @notice Retrieves the token symbol
+    /// @return The symbol of the token
+    function symbol() external pure returns (string memory);
+
+    /// @notice Retrieves the token decimal count
+    /// @return The decimal count
+    function decimals() external pure returns (uint8);
+
+    /// @notice Retrieves the token total supply
+    /// @return The total supply
+    function totalSupply() external view returns (uint256);
+
+    /// @notice Retrieves the token balance of the specified user
+    /// @param _owner Owner to check the balance
+    /// @return The balance of the owner
+    function balanceOf(address _owner) external view returns (uint256);
+
+    /// @notice Retrieves the raw shares count of the user
+    /// @param _owner Owner to check the shares balance
+    /// @return The shares of the owner
+    function sharesOf(address _owner) external view returns (uint256);
+
+    /// @notice Retrieves the token allowance given from one address to another
+    /// @param _owner Owner that gave the allowance
+    /// @param _spender Spender that received the allowance
+    /// @return The allowance of the owner to the spender
+    function allowance(address _owner, address _spender) external view returns (uint256);
+
+    /// @notice Transfers tokens between the message sender and a recipient
+    /// @param _to Recipient of the transfer
+    /// @param _value Amount to transfer
+    /// @return True if success
+    function transfer(address _to, uint256 _value) external returns (bool);
+
+    /// @notice Transfers tokens between two accounts
+    /// @dev It is expected that _from has given at least _value allowance to msg.sender
+    /// @param _from Sender account
+    /// @param _to Recipient of the transfer
+    /// @param _value Amount to transfer
+    /// @return True if success
+    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);
+
+    /// @notice Approves another account to transfer tokens
+    /// @param _spender Spender that receives the allowance
+    /// @param _value Amount to allow
+    /// @return True if success
+    function approve(address _spender, uint256 _value) external returns (bool);
+
+    /// @notice Increase allowance to another account
+    /// @param _spender Spender that receives the allowance
+    /// @param _additionalValue Amount to add
+    /// @return True if success
+    function increaseAllowance(address _spender, uint256 _additionalValue) external returns (bool);
+
+    /// @notice Decrease allowance to another account
+    /// @param _spender Spender that receives the allowance
+    /// @param _subtractableValue Amount to subtract
+    /// @return True if success
+    function decreaseAllowance(address _spender, uint256 _subtractableValue) external returns (bool);
+
+    /// @notice Mint tokens by providing LsETH tokens
+    /// @dev The message sender locks LsETH tokens and received wrapped LsETH tokens in exchange
+    /// @dev The message sender needs to approve the contract to mint the wrapped tokens
+    /// @dev The minted wrapped LsETH is sent to the specified recipient
+    /// @param _recipient The account receiving the new minted wrapped LsETH
+    /// @param _shares The amount of LsETH to wrap
+    function mint(address _recipient, uint256 _shares) external;
+
+    /// @notice Burn tokens and retrieve underlying LsETH tokens
+    /// @dev The message sender burns shares from its balance for the LsETH equivalent value
+    /// @dev The message sender doesn't need to approve the contract to burn the shares
+    /// @dev The freed LsETH is sent to the specified recipient
+    /// @param _recipient The account receiving the underlying LsETH tokens after shares are burned
+    /// @param _shares Amount of LsETH to free by burning wrapped LsETH
+    function burn(address _recipient, uint256 _shares) external;
+}
diff -ruN src/contracts/src/interfaces/IWithdraw.1.sol contracts/src/interfaces/IWithdraw.1.sol
--- src/contracts/src/interfaces/IWithdraw.1.sol	1970-01-01 01:00:00
+++ contracts/src/interfaces/IWithdraw.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,26 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Withdraw Interface (V1)
+/// @author Kiln
+/// @notice This contract is in charge of holding the exit and skimming funds and allow river to pull these funds
+interface IWithdrawV1 {
+    /// @notice Emitted when the linked River address is changed
+    /// @param river The new River address
+    event SetRiver(address river);
+
+    /// @param _river The address of the River contract
+    function initializeWithdrawV1(address _river) external;
+
+    /// @notice Retrieve the withdrawal credentials to use
+    /// @return The withdrawal credentials
+    function getCredentials() external view returns (bytes32);
+
+    /// @notice Retrieve the linked River address
+    /// @return The River address
+    function getRiver() external view returns (address);
+
+    /// @notice Callable by River, sends the specified amount of ETH to River
+    /// @param _amount The amount to pull
+    function pullEth(uint256 _amount) external;
+}
diff -ruN src/contracts/src/interfaces/components/IConsensusLayerDepositManager.1.sol contracts/src/interfaces/components/IConsensusLayerDepositManager.1.sol
--- src/contracts/src/interfaces/components/IConsensusLayerDepositManager.1.sol	1970-01-01 01:00:00
+++ contracts/src/interfaces/components/IConsensusLayerDepositManager.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,64 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Consensys Layer Deposit Manager Interface (v1)
+/// @author Kiln
+/// @notice This interface exposes methods to handle the interactions with the official deposit contract
+interface IConsensusLayerDepositManagerV1 {
+    /// @notice The stored deposit contract address changed
+    /// @param depositContract Address of the deposit contract
+    event SetDepositContractAddress(address indexed depositContract);
+
+    /// @notice The stored withdrawal credentials changed
+    /// @param withdrawalCredentials The withdrawal credentials to use for deposits
+    event SetWithdrawalCredentials(bytes32 withdrawalCredentials);
+
+    /// @notice Emitted when the deposited validator count is updated
+    /// @param oldDepositedValidatorCount The old deposited validator count value
+    /// @param newDepositedValidatorCount The new deposited validator count value
+    event SetDepositedValidatorCount(uint256 oldDepositedValidatorCount, uint256 newDepositedValidatorCount);
+
+    /// @notice Not enough funds to deposit one validator
+    error NotEnoughFunds();
+
+    /// @notice The length of the BLS Public key is invalid during deposit
+    error InconsistentPublicKeys();
+
+    /// @notice The length of the BLS Signature is invalid during deposit
+    error InconsistentSignatures();
+
+    /// @notice The internal key retrieval returned no keys
+    error NoAvailableValidatorKeys();
+
+    /// @notice The received count of public keys to deposit is invalid
+    error InvalidPublicKeyCount();
+
+    /// @notice The received count of signatures to deposit is invalid
+    error InvalidSignatureCount();
+
+    /// @notice The withdrawal credentials value is null
+    error InvalidWithdrawalCredentials();
+
+    /// @notice An error occured during the deposit
+    error ErrorOnDeposit();
+
+    /// @notice Returns the amount of ETH not yet committed for deposit
+    /// @return The amount of ETH not yet committed for deposit
+    function getBalanceToDeposit() external view returns (uint256);
+
+    /// @notice Returns the amount of ETH committed for deposit
+    /// @return The amount of ETH committed for deposit
+    function getCommittedBalance() external view returns (uint256);
+
+    /// @notice Retrieve the withdrawal credentials
+    /// @return The withdrawal credentials
+    function getWithdrawalCredentials() external view returns (bytes32);
+
+    /// @notice Get the deposited validator count (the count of deposits made by the contract)
+    /// @return The deposited validator count
+    function getDepositedValidatorCount() external view returns (uint256);
+
+    /// @notice Deposits current balance to the Consensus Layer by batches of 32 ETH
+    /// @param _maxCount The maximum amount of validator keys to fund
+    function depositToConsensusLayer(uint256 _maxCount) external;
+}
diff -ruN src/contracts/src/interfaces/components/IERC20VestableVotesUpgradeable.1.sol contracts/src/interfaces/components/IERC20VestableVotesUpgradeable.1.sol
--- src/contracts/src/interfaces/components/IERC20VestableVotesUpgradeable.1.sol	1970-01-01 01:00:00
+++ contracts/src/interfaces/components/IERC20VestableVotesUpgradeable.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,140 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../state/tlc/VestingSchedules.2.sol";
+
+/// @title ERC20 Vestable Votes Upgradeable Interface(v1)
+/// @author Alluvial
+/// @notice This interface exposes methods to manage vestings
+interface IERC20VestableVotesUpgradeableV1 {
+    /// @notice A new vesting schedule has been created
+    /// @param index Vesting schedule index
+    /// @param creator Creator of the vesting schedule
+    /// @param beneficiary Vesting beneficiary address
+    /// @param amount Vesting schedule amount
+    event CreatedVestingSchedule(uint256 index, address indexed creator, address indexed beneficiary, uint256 amount);
+
+    /// @notice Vesting schedule has been released
+    /// @param index Vesting schedule index
+    /// @param releasedAmount Amount of tokens released to the beneficiary
+    event ReleasedVestingSchedule(uint256 index, uint256 releasedAmount);
+
+    /// @notice Vesting schedule has been revoked
+    /// @param index Vesting schedule index
+    /// @param returnedAmount Amount of tokens returned to the creator
+    /// @param newEnd New end timestamp after revoke action
+    event RevokedVestingSchedule(uint256 index, uint256 returnedAmount, uint256 newEnd);
+
+    /// @notice Vesting escrow has been delegated
+    /// @param index Vesting schedule index
+    /// @param oldDelegatee old delegatee
+    /// @param newDelegatee new delegatee
+    /// @param beneficiary vesting schedule beneficiary
+    event DelegatedVestingEscrow(
+        uint256 index, address indexed oldDelegatee, address indexed newDelegatee, address indexed beneficiary
+    );
+
+    /// @notice Vesting schedule creator has unsufficient balance to create vesting schedule
+    error UnsufficientVestingScheduleCreatorBalance();
+
+    /// @notice Invalid parameter for a vesting schedule
+    error InvalidVestingScheduleParameter(string msg);
+
+    /// @notice Attempt to revoke a schedule in the past
+    error VestingScheduleNotRevocableInPast();
+
+    /// @notice The vesting schedule is not revocable
+    error VestingScheduleNotRevocable();
+
+    /// @notice The vesting schedule is locked
+    error VestingScheduleIsLocked();
+
+    /// @notice Attempt to revoke a vesting schedule with an invalid end parameter
+    error InvalidRevokedVestingScheduleEnd();
+
+    /// @notice No token to release
+    error ZeroReleasableAmount();
+
+    /// @notice Underflow in global unlock logic (should never happen)
+    error GlobalUnlockUnderlfow();
+
+    /// @notice Get vesting schedule
+    /// @dev The vesting schedule structure represents a static configuration used to compute the desired
+    /// @dev vesting details of a beneficiary at all times. The values won't change even after tokens are released.
+    /// @dev The only dynamic field of the structure is end, and is updated whenever a vesting schedule is revoked
+    /// @param _index Index of the vesting schedule
+    function getVestingSchedule(uint256 _index) external view returns (VestingSchedulesV2.VestingSchedule memory);
+
+    /// @notice Get vesting global unlock schedule activation status for a vesting schedule
+    /// @param _index Index of the vesting schedule
+    /// @return true if the vesting schedule should ignore the global unlock schedule
+    function isGlobalUnlockedScheduleIgnored(uint256 _index) external view returns (bool);
+
+    /// @notice Get count of vesting schedules
+    /// @return count of vesting schedules
+    function getVestingScheduleCount() external view returns (uint256);
+
+    /// @notice Get the address of the escrow for a vesting schedule
+    /// @param _index Index of the vesting schedule
+    /// @return address of the escrow
+    function vestingEscrow(uint256 _index) external view returns (address);
+
+    /// @notice Computes the releasable amount of tokens for a vesting schedule.
+    /// @param _index index of the vesting schedule
+    /// @return amount of releasable tokens
+    function computeVestingReleasableAmount(uint256 _index) external view returns (uint256);
+
+    /// @notice Computes the vested amount of tokens for a vesting schedule.
+    /// @param _index index of the vesting schedule
+    /// @return amount of vested tokens
+    function computeVestingVestedAmount(uint256 _index) external view returns (uint256);
+
+    /// @notice Creates a new vesting schedule
+    /// @notice There may delay between the time a user should start vesting tokens and the time the vesting schedule is actually created on the contract.
+    /// @notice Typically a user joins the Liquid Collective but some weeks pass before the user gets all legal agreements in place and signed for the
+    /// @notice token grant emission to happen. In this case, the vesting schedule created for the token grant would start on the join date which is in the past.
+    /// @dev As vesting schedules can be created in the past, this means that you should be careful when creating a vesting schedule and what duration parameters
+    /// @dev you use as this contract would allow creating a vesting schedule in the past and even a vesting schedule that has already ended.
+    /// @param _start start time of the vesting
+    /// @param _cliffDuration duration to vesting cliff (in seconds)
+    /// @param _duration total vesting schedule duration after which all tokens are vested (in seconds)
+    /// @param _periodDuration duration of a period after which new tokens unlock (in seconds)
+    /// @param _lockDuration duration during which tokens are locked (in seconds)
+    /// @param _revocable whether the vesting schedule is revocable or not
+    /// @param _amount amount of token attributed by the vesting schedule
+    /// @param _beneficiary address of the beneficiary of the tokens
+    /// @param _delegatee address to delegate escrow voting power to
+    /// @param _ignoreGlobalUnlockSchedule whether the vesting schedule should ignore the global lock
+    /// @return index of the created vesting schedule
+    function createVestingSchedule(
+        uint64 _start,
+        uint32 _cliffDuration,
+        uint32 _duration,
+        uint32 _periodDuration,
+        uint32 _lockDuration,
+        bool _revocable,
+        uint256 _amount,
+        address _beneficiary,
+        address _delegatee,
+        bool _ignoreGlobalUnlockSchedule
+    ) external returns (uint256);
+
+    /// @notice Revoke vesting schedule
+    /// @param _index Index of the vesting schedule to revoke
+    /// @param _end End date for the schedule
+    /// @return returnedAmount amount returned to the vesting schedule creator
+    function revokeVestingSchedule(uint256 _index, uint64 _end) external returns (uint256 returnedAmount);
+
+    /// @notice Release vesting schedule
+    /// @notice When tokens are released from the escrow, the delegated address of the escrow will see its voting power decrease.
+    /// @notice The beneficiary has to make sure its delegation parameters are set properly to be able to use/delegate the voting power of its balance.
+    /// @param _index Index of the vesting schedule to release
+    /// @return released amount
+    function releaseVestingSchedule(uint256 _index) external returns (uint256);
+
+    /// @notice Delegate vesting escrowed tokens
+    /// @param _index index of the vesting schedule
+    /// @param _delegatee address to delegate the token to
+    /// @return True on success
+    function delegateVestingEscrow(uint256 _index, address _delegatee) external returns (bool);
+}
diff -ruN src/contracts/src/interfaces/components/IOracleManager.1.sol contracts/src/interfaces/components/IOracleManager.1.sol
--- src/contracts/src/interfaces/components/IOracleManager.1.sol	1970-01-01 01:00:00
+++ contracts/src/interfaces/components/IOracleManager.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,237 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../state/river/CLSpec.sol";
+import "../../state/river/ReportBounds.sol";
+
+/// @title Oracle Manager (v1)
+/// @author Kiln
+/// @notice This interface exposes methods to handle the inputs provided by the oracle
+interface IOracleManagerV1 {
+    /// @notice The stored oracle address changed
+    /// @param oracleAddress The new oracle address
+    event SetOracle(address indexed oracleAddress);
+
+    /// @notice The consensus layer data provided by the oracle has been updated
+    /// @param validatorCount The new count of validators running on the consensus layer
+    /// @param validatorTotalBalance The new total balance sum of all validators
+    /// @param roundId Round identifier
+    event ConsensusLayerDataUpdate(uint256 validatorCount, uint256 validatorTotalBalance, bytes32 roundId);
+
+    /// @notice The Consensus Layer Spec is changed
+    /// @param epochsPerFrame The number of epochs inside a frame
+    /// @param slotsPerEpoch The number of slots inside an epoch
+    /// @param secondsPerSlot The number of seconds inside a slot
+    /// @param genesisTime The genesis timestamp
+    /// @param epochsToAssumedFinality The number of epochs before an epoch is considered final
+    event SetSpec(
+        uint64 epochsPerFrame,
+        uint64 slotsPerEpoch,
+        uint64 secondsPerSlot,
+        uint64 genesisTime,
+        uint64 epochsToAssumedFinality
+    );
+
+    /// @notice The Report Bounds are changed
+    /// @param annualAprUpperBound The reporting upper bound
+    /// @param relativeLowerBound The reporting lower bound
+    event SetBounds(uint256 annualAprUpperBound, uint256 relativeLowerBound);
+
+    /// @notice The provided report has beend processed
+    /// @param report The report that was provided
+    /// @param trace The trace structure providing more insights on internals
+    event ProcessedConsensusLayerReport(
+        IOracleManagerV1.ConsensusLayerReport report, ConsensusLayerDataReportingTrace trace
+    );
+
+    /// @notice The reported validator count is invalid
+    /// @param providedValidatorCount The received validator count value
+    /// @param depositedValidatorCount The number of deposits performed by the system
+    /// @param lastReportedValidatorCount The last reported validator count
+    error InvalidValidatorCountReport(
+        uint256 providedValidatorCount, uint256 depositedValidatorCount, uint256 lastReportedValidatorCount
+    );
+
+    /// @notice Thrown when an invalid epoch was reported
+    /// @param epoch Invalid epoch
+    error InvalidEpoch(uint256 epoch);
+
+    /// @notice The balance increase is higher than the maximum allowed by the upper bound
+    /// @param prevTotalEthIncludingExited The previous total balance, including all exited balance
+    /// @param postTotalEthIncludingExited The post-report total balance, including all exited balance
+    /// @param timeElapsed The time in seconds since last report
+    /// @param annualAprUpperBound The upper bound value that was used
+    error TotalValidatorBalanceIncreaseOutOfBound(
+        uint256 prevTotalEthIncludingExited,
+        uint256 postTotalEthIncludingExited,
+        uint256 timeElapsed,
+        uint256 annualAprUpperBound
+    );
+
+    /// @notice The balance decrease is higher than the maximum allowed by the lower bound
+    /// @param prevTotalEthIncludingExited The previous total balance, including all exited balance
+    /// @param postTotalEthIncludingExited The post-report total balance, including all exited balance
+    /// @param timeElapsed The time in seconds since last report
+    /// @param relativeLowerBound The lower bound value that was used
+    error TotalValidatorBalanceDecreaseOutOfBound(
+        uint256 prevTotalEthIncludingExited,
+        uint256 postTotalEthIncludingExited,
+        uint256 timeElapsed,
+        uint256 relativeLowerBound
+    );
+
+    /// @notice The total exited balance decreased
+    /// @param currentValidatorsExitedBalance The current exited balance
+    /// @param newValidatorsExitedBalance The new exited balance
+    error InvalidDecreasingValidatorsExitedBalance(
+        uint256 currentValidatorsExitedBalance, uint256 newValidatorsExitedBalance
+    );
+
+    /// @notice The total skimmed balance decreased
+    /// @param currentValidatorsSkimmedBalance The current exited balance
+    /// @param newValidatorsSkimmedBalance The new exited balance
+    error InvalidDecreasingValidatorsSkimmedBalance(
+        uint256 currentValidatorsSkimmedBalance, uint256 newValidatorsSkimmedBalance
+    );
+
+    /// @notice Trace structure emitted via logs during reporting
+    struct ConsensusLayerDataReportingTrace {
+        uint256 rewards;
+        uint256 pulledELFees;
+        uint256 pulledRedeemManagerExceedingEthBuffer;
+        uint256 pulledCoverageFunds;
+    }
+
+    /// @notice The format of the oracle report
+    struct ConsensusLayerReport {
+        // this is the epoch at which the report was performed
+        // data should be fetched up to the state of this epoch by the oracles
+        uint256 epoch;
+        // the sum of all the validator balances on the consensus layer
+        // when a validator enters the exit queue, the validator is considered stopped, its balance is accounted in both validatorsExitingBalance and validatorsBalance
+        // when a validator leaves the exit queue and the funds are sweeped onto the execution layer, the balance is only accounted in validatorsExitedBalance and not in validatorsBalance
+        // this value can decrease between reports
+        uint256 validatorsBalance;
+        // the sum of all the skimmings performed on the validators
+        // these values can be found in the execution layer block bodies under the withdrawals field
+        // a withdrawal is considered skimming if
+        // - the epoch at which it happened is < validator.withdrawableEpoch
+        // - the epoch at which it happened is >= validator.withdrawableEpoch and in that case we only account for what would be above 32 eth as skimming
+        // this value cannot decrease over reports
+        uint256 validatorsSkimmedBalance;
+        // the sum of all the exits performed on the validators
+        // these values can be found in the execution layer block bodies under the withdrawals field
+        // a withdrawal is considered exit if
+        // - the epoch at which it happened is >= validator.withdrawableEpoch and in that case we only account for what would be <= 32 eth as exit
+        // this value cannot decrease over reports
+        uint256 validatorsExitedBalance;
+        // the sum of all the exiting balance, which is all the validators on their way to get sweeped and exited
+        // this includes voluntary exits and slashings
+        // this value can decrease between reports
+        uint256 validatorsExitingBalance;
+        // the count of activated validators
+        // even validators that are exited are still accounted
+        // this value cannot decrease over reports
+        uint32 validatorsCount;
+        // an array containing the count of stopped validators per operator
+        // the first element of the array is the sum of all stopped validators
+        // then index 1 would be operator 0
+        // these values cannot decrease over reports
+        uint32[] stoppedValidatorCountPerOperator;
+        // flag enabled by the oracles when the buffer rebalancing is activated
+        // the activation logic is written in the oracle specification and all oracle members must agree on the activation
+        // when active, the eth in the deposit buffer can be used to pay for exits in the redeem manager
+        bool rebalanceDepositToRedeemMode;
+        // flag enabled by the oracles when the slashing containment is activated
+        // the activation logic is written in the oracle specification and all oracle members must agree on the activation
+        // This flag is activated when a pre-defined threshold of slashed validators in our set of validators is reached
+        // This flag is deactivated when a bottom threshold is met, this means that when we reach the upper threshold and activate the flag, we will deactivate it when we reach the bottom threshold and not before
+        // when active, no more validator exits can be requested by the protocol
+        bool slashingContainmentMode;
+    }
+
+    /// @notice The format of the oracle report in storage
+    /// @notice These fields have the exact same function as the ones in ConsensusLayerReport, but this struct is optimized for storage
+    struct StoredConsensusLayerReport {
+        uint256 epoch;
+        uint256 validatorsBalance;
+        uint256 validatorsSkimmedBalance;
+        uint256 validatorsExitedBalance;
+        uint256 validatorsExitingBalance;
+        uint32 validatorsCount;
+        bool rebalanceDepositToRedeemMode;
+        bool slashingContainmentMode;
+    }
+
+    /// @notice Get oracle address
+    /// @return The oracle address
+    function getOracle() external view returns (address);
+
+    /// @notice Get CL validator total balance
+    /// @return The CL Validator total balance
+    function getCLValidatorTotalBalance() external view returns (uint256);
+
+    /// @notice Get CL validator count (the amount of validator reported by the oracles)
+    /// @return The CL validator count
+    function getCLValidatorCount() external view returns (uint256);
+
+    /// @notice Verifies if the provided epoch is valid
+    /// @param epoch The epoch to lookup
+    /// @return True if valid
+    function isValidEpoch(uint256 epoch) external view returns (bool);
+
+    /// @notice Retrieve the block timestamp
+    /// @return The current timestamp from the EVM context
+    function getTime() external view returns (uint256);
+
+    /// @notice Retrieve expected epoch id
+    /// @return The current expected epoch id
+    function getExpectedEpochId() external view returns (uint256);
+
+    /// @notice Retrieve the last completed epoch id
+    /// @return The last completed epoch id
+    function getLastCompletedEpochId() external view returns (uint256);
+
+    /// @notice Retrieve the current epoch id based on block timestamp
+    /// @return The current epoch id
+    function getCurrentEpochId() external view returns (uint256);
+
+    /// @notice Retrieve the current cl spec
+    /// @return The Consensus Layer Specification
+    function getCLSpec() external view returns (CLSpec.CLSpecStruct memory);
+
+    /// @notice Retrieve the current frame details
+    /// @return _startEpochId The epoch at the beginning of the frame
+    /// @return _startTime The timestamp of the beginning of the frame in seconds
+    /// @return _endTime The timestamp of the end of the frame in seconds
+    function getCurrentFrame() external view returns (uint256 _startEpochId, uint256 _startTime, uint256 _endTime);
+
+    /// @notice Retrieve the first epoch id of the frame of the provided epoch id
+    /// @param _epochId Epoch id used to get the frame
+    /// @return The first epoch id of the frame containing the given epoch id
+    function getFrameFirstEpochId(uint256 _epochId) external view returns (uint256);
+
+    /// @notice Retrieve the report bounds
+    /// @return The report bounds
+    function getReportBounds() external view returns (ReportBounds.ReportBoundsStruct memory);
+
+    /// @notice Retrieve the last consensus layer report
+    /// @return The stored consensus layer report
+    function getLastConsensusLayerReport() external view returns (IOracleManagerV1.StoredConsensusLayerReport memory);
+
+    /// @notice Set the oracle address
+    /// @param _oracleAddress Address of the oracle
+    function setOracle(address _oracleAddress) external;
+
+    /// @notice Set the consensus layer spec
+    /// @param _newValue The new consensus layer spec value
+    function setCLSpec(CLSpec.CLSpecStruct calldata _newValue) external;
+
+    /// @notice Set the report bounds
+    /// @param _newValue The new report bounds value
+    function setReportBounds(ReportBounds.ReportBoundsStruct calldata _newValue) external;
+
+    /// @notice Performs all the reporting logics
+    /// @param _report The consensus layer report structure
+    function setConsensusLayerData(ConsensusLayerReport calldata _report) external;
+}
diff -ruN src/contracts/src/interfaces/components/ISharesManager.1.sol contracts/src/interfaces/components/ISharesManager.1.sol
--- src/contracts/src/interfaces/components/ISharesManager.1.sol	1970-01-01 01:00:00
+++ contracts/src/interfaces/components/ISharesManager.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,108 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
+
+/// @title Shares Manager Interface (v1)
+/// @author Kiln
+/// @notice This interface exposes methods to handle the shares of the depositor and the ERC20 interface
+interface ISharesManagerV1 is IERC20 {
+    /// @notice Emitted when the total supply is changed
+    event SetTotalSupply(uint256 totalSupply);
+
+    /// @notice Balance too low to perform operation
+    error BalanceTooLow();
+
+    /// @notice Allowance too low to perform operation
+    /// @param _from Account where funds are sent from
+    /// @param _operator Account attempting the transfer
+    /// @param _allowance Current allowance
+    /// @param _value Requested transfer value in shares
+    error AllowanceTooLow(address _from, address _operator, uint256 _allowance, uint256 _value);
+
+    /// @notice Invalid empty transfer
+    error NullTransfer();
+
+    /// @notice Invalid transfer recipients
+    /// @param _from Account sending the funds in the invalid transfer
+    /// @param _to Account receiving the funds in the invalid transfer
+    error UnauthorizedTransfer(address _from, address _to);
+
+    /// @notice Retrieve the token name
+    /// @return The token name
+    function name() external pure returns (string memory);
+
+    /// @notice Retrieve the token symbol
+    /// @return The token symbol
+    function symbol() external pure returns (string memory);
+
+    /// @notice Retrieve the decimal count
+    /// @return The decimal count
+    function decimals() external pure returns (uint8);
+
+    /// @notice Retrieve the total token supply
+    /// @return The total supply in shares
+    function totalSupply() external view returns (uint256);
+
+    /// @notice Retrieve the total underlying asset supply
+    /// @return The total underlying asset supply
+    function totalUnderlyingSupply() external view returns (uint256);
+
+    /// @notice Retrieve the balance of an account
+    /// @param _owner Address to be checked
+    /// @return The balance of the account in shares
+    function balanceOf(address _owner) external view returns (uint256);
+
+    /// @notice Retrieve the underlying asset balance of an account
+    /// @param _owner Address to be checked
+    /// @return The underlying balance of the account
+    function balanceOfUnderlying(address _owner) external view returns (uint256);
+
+    /// @notice Retrieve the underlying asset balance from an amount of shares
+    /// @param _shares Amount of shares to convert
+    /// @return The underlying asset balance represented by the shares
+    function underlyingBalanceFromShares(uint256 _shares) external view returns (uint256);
+
+    /// @notice Retrieve the shares count from an underlying asset amount
+    /// @param _underlyingAssetAmount Amount of underlying asset to convert
+    /// @return The amount of shares worth the underlying asset amopunt
+    function sharesFromUnderlyingBalance(uint256 _underlyingAssetAmount) external view returns (uint256);
+
+    /// @notice Retrieve the allowance value for a spender
+    /// @param _owner Address that issued the allowance
+    /// @param _spender Address that received the allowance
+    /// @return The allowance in shares for a given spender
+    function allowance(address _owner, address _spender) external view returns (uint256);
+
+    /// @notice Performs a transfer from the message sender to the provided account
+    /// @param _to Address receiving the tokens
+    /// @param _value Amount of shares to be sent
+    /// @return True if success
+    function transfer(address _to, uint256 _value) external returns (bool);
+
+    /// @notice Performs a transfer between two recipients
+    /// @param _from Address sending the tokens
+    /// @param _to Address receiving the tokens
+    /// @param _value Amount of shares to be sent
+    /// @return True if success
+    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);
+
+    /// @notice Approves an account for future spendings
+    /// @dev An approved account can use transferFrom to transfer funds on behalf of the token owner
+    /// @param _spender Address that is allowed to spend the tokens
+    /// @param _value The allowed amount in shares, will override previous value
+    /// @return True if success
+    function approve(address _spender, uint256 _value) external returns (bool);
+
+    /// @notice Increase allowance to another account
+    /// @param _spender Spender that receives the allowance
+    /// @param _additionalValue Amount of shares to add
+    /// @return True if success
+    function increaseAllowance(address _spender, uint256 _additionalValue) external returns (bool);
+
+    /// @notice Decrease allowance to another account
+    /// @param _spender Spender that receives the allowance
+    /// @param _subtractableValue Amount of shares to subtract
+    /// @return True if success
+    function decreaseAllowance(address _spender, uint256 _subtractableValue) external returns (bool);
+}
diff -ruN src/contracts/src/interfaces/components/IUserDepositManager.1.sol contracts/src/interfaces/components/IUserDepositManager.1.sol
--- src/contracts/src/interfaces/components/IUserDepositManager.1.sol	1970-01-01 01:00:00
+++ contracts/src/interfaces/components/IUserDepositManager.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,29 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title User Deposit Manager (v1)
+/// @author Kiln
+/// @notice This interface exposes methods to handle the inbound transfers cases or the explicit submissions
+interface IUserDepositManagerV1 {
+    /// @notice User deposited ETH in the system
+    /// @param depositor Address performing the deposit
+    /// @param recipient Address receiving the minted shares
+    /// @param amount Amount in ETH deposited
+    event UserDeposit(address indexed depositor, address indexed recipient, uint256 amount);
+
+    /// @notice And empty deposit attempt was made
+    error EmptyDeposit();
+
+    /// @notice Explicit deposit method to mint on msg.sender
+    function deposit() external payable;
+
+    /// @notice Explicit deposit method to mint on msg.sender and transfer to _recipient
+    /// @param _recipient Address receiving the minted LsETH
+    function depositAndTransfer(address _recipient) external payable;
+
+    /// @notice Implicit deposit method, when the user performs a regular transfer to the contract
+    receive() external payable;
+
+    /// @notice Invalid call, when the user sends a transaction with a data payload but no method matched
+    fallback() external payable;
+}
diff -ruN src/contracts/src/libraries/LibAdministrable.sol contracts/src/libraries/LibAdministrable.sol
--- src/contracts/src/libraries/LibAdministrable.sol	1970-01-01 01:00:00
+++ contracts/src/libraries/LibAdministrable.sol	2024-01-16 15:06:39
@@ -0,0 +1,34 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../state/shared/AdministratorAddress.sol";
+import "../state/shared/PendingAdministratorAddress.sol";
+
+/// @title Lib Administrable
+/// @author Kiln
+/// @notice This library handles the admin and pending admin storage vars
+library LibAdministrable {
+    /// @notice Retrieve the system admin
+    /// @return The address of the system admin
+    function _getAdmin() internal view returns (address) {
+        return AdministratorAddress.get();
+    }
+
+    /// @notice Retrieve the pending system admin
+    /// @return The adress of the pending system admin
+    function _getPendingAdmin() internal view returns (address) {
+        return PendingAdministratorAddress.get();
+    }
+
+    /// @notice Sets the system admin
+    /// @param _admin New system admin
+    function _setAdmin(address _admin) internal {
+        AdministratorAddress.set(_admin);
+    }
+
+    /// @notice Sets the pending system admin
+    /// @param _pendingAdmin New pending system admin
+    function _setPendingAdmin(address _pendingAdmin) internal {
+        PendingAdministratorAddress.set(_pendingAdmin);
+    }
+}
diff -ruN src/contracts/src/libraries/LibAllowlistMasks.sol contracts/src/libraries/LibAllowlistMasks.sol
--- src/contracts/src/libraries/LibAllowlistMasks.sol	1970-01-01 01:00:00
+++ contracts/src/libraries/LibAllowlistMasks.sol	2024-01-16 15:06:39
@@ -0,0 +1,15 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Lib Allowlist Masks
+/// @notice Holds all the mask values
+library LibAllowlistMasks {
+    /// @notice Mask used for denied accounts
+    uint256 internal constant DENY_MASK = 0x1 << 255;
+    /// @notice The mask for the deposit right
+    uint256 internal constant DEPOSIT_MASK = 0x1;
+    /// @notice The mask for the donation right
+    uint256 internal constant DONATE_MASK = 0x1 << 1;
+    /// @notice The mask for the redeem right
+    uint256 internal constant REDEEM_MASK = 0x1 << 2;
+}
diff -ruN src/contracts/src/libraries/LibBasisPoints.sol contracts/src/libraries/LibBasisPoints.sol
--- src/contracts/src/libraries/LibBasisPoints.sol	1970-01-01 01:00:00
+++ contracts/src/libraries/LibBasisPoints.sol	2024-01-16 15:06:39
@@ -0,0 +1,9 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Lib Basis Points
+/// @notice Holds the basis points max value
+library LibBasisPoints {
+    /// @notice The max value for basis points (represents 100%)
+    uint256 internal constant BASIS_POINTS_MAX = 10_000;
+}
diff -ruN src/contracts/src/libraries/LibBytes.sol contracts/src/libraries/LibBytes.sol
--- src/contracts/src/libraries/LibBytes.sol	1970-01-01 01:00:00
+++ contracts/src/libraries/LibBytes.sol	2024-01-16 15:06:39
@@ -0,0 +1,83 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Lib Bytes
+/// @notice This library helps manipulating bytes
+library LibBytes {
+    /// @notice The length overflows an uint
+    error SliceOverflow();
+
+    /// @notice The slice is outside of the initial bytes bounds
+    error SliceOutOfBounds();
+
+    /// @notice Slices the provided bytes
+    /// @param _bytes Bytes to slice
+    /// @param _start The starting index of the slice
+    /// @param _length The length of the slice
+    /// @return The slice of _bytes starting at _start of length _length
+    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {
+        unchecked {
+            if (_length + 31 < _length) {
+                revert SliceOverflow();
+            }
+        }
+        if (_bytes.length < _start + _length) {
+            revert SliceOutOfBounds();
+        }
+
+        bytes memory tempBytes;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            switch iszero(_length)
+            case 0 {
+                // Get a location of some free memory and store it in tempBytes as
+                // Solidity does for memory variables.
+                tempBytes := mload(0x40)
+
+                // The first word of the slice result is potentially a partial
+                // word read from the original array. To read it, we calculate
+                // the length of that partial word and start copying that many
+                // bytes into the array. The first word we copy will start with
+                // data we don't care about, but the last `lengthmod` bytes will
+                // land at the beginning of the contents of the new array. When
+                // we're done copying, we overwrite the full first word with
+                // the actual length of the slice.
+                let lengthmod := and(_length, 31)
+
+                // The multiplication in the next line is necessary
+                // because when slicing multiples of 32 bytes (lengthmod == 0)
+                // the following copy loop was copying the origin's length
+                // and then ending prematurely not copying everything it should.
+                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))
+                let end := add(mc, _length)
+
+                for {
+                    // The multiplication in the next line has the same exact purpose
+                    // as the one above.
+                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)
+                } lt(mc, end) {
+                    mc := add(mc, 0x20)
+                    cc := add(cc, 0x20)
+                } { mstore(mc, mload(cc)) }
+
+                mstore(tempBytes, _length)
+
+                //update free-memory pointer
+                //allocating the array padded to 32 bytes like the compiler does now
+                mstore(0x40, and(add(mc, 31), not(31)))
+            }
+            //if we want a zero-length slice let's just return a zero-length array
+            default {
+                tempBytes := mload(0x40)
+                //zero out the 32 bytes slice we are about to return
+                //we need to do it because Solidity does not garbage collect
+                mstore(tempBytes, 0)
+
+                mstore(0x40, add(tempBytes, 0x20))
+            }
+        }
+
+        return tempBytes;
+    }
+}
diff -ruN src/contracts/src/libraries/LibErrors.sol contracts/src/libraries/LibErrors.sol
--- src/contracts/src/libraries/LibErrors.sol	1970-01-01 01:00:00
+++ contracts/src/libraries/LibErrors.sol	2024-01-16 15:06:39
@@ -0,0 +1,25 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Lib Errors
+/// @notice Library of common errors
+library LibErrors {
+    /// @notice The operator is unauthorized for the caller
+    /// @param caller Address performing the call
+    error Unauthorized(address caller);
+
+    /// @notice The call was invalid
+    error InvalidCall();
+
+    /// @notice The argument was invalid
+    error InvalidArgument();
+
+    /// @notice The address is zero
+    error InvalidZeroAddress();
+
+    /// @notice The string is empty
+    error InvalidEmptyString();
+
+    /// @notice The fee is invalid
+    error InvalidFee();
+}
diff -ruN src/contracts/src/libraries/LibSanitize.sol contracts/src/libraries/LibSanitize.sol
--- src/contracts/src/libraries/LibSanitize.sol	1970-01-01 01:00:00
+++ contracts/src/libraries/LibSanitize.sol	2024-01-16 15:06:39
@@ -0,0 +1,33 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "./LibErrors.sol";
+import "./LibBasisPoints.sol";
+
+/// @title Lib Sanitize
+/// @notice Utilities to sanitize input values
+library LibSanitize {
+    /// @notice Reverts if address is 0
+    /// @param _address Address to check
+    function _notZeroAddress(address _address) internal pure {
+        if (_address == address(0)) {
+            revert LibErrors.InvalidZeroAddress();
+        }
+    }
+
+    /// @notice Reverts if string is empty
+    /// @param _string String to check
+    function _notEmptyString(string memory _string) internal pure {
+        if (bytes(_string).length == 0) {
+            revert LibErrors.InvalidEmptyString();
+        }
+    }
+
+    /// @notice Reverts if fee is invalid
+    /// @param _fee Fee to check
+    function _validFee(uint256 _fee) internal pure {
+        if (_fee > LibBasisPoints.BASIS_POINTS_MAX) {
+            revert LibErrors.InvalidFee();
+        }
+    }
+}
diff -ruN src/contracts/src/libraries/LibUint256.sol contracts/src/libraries/LibUint256.sol
--- src/contracts/src/libraries/LibUint256.sol	1970-01-01 01:00:00
+++ contracts/src/libraries/LibUint256.sol	2024-01-16 15:06:39
@@ -0,0 +1,64 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Lib Uint256
+/// @notice Utilities to perform uint operations
+library LibUint256 {
+    /// @notice Converts a value to little endian (64 bits)
+    /// @param _value The value to convert
+    /// @return result The converted value
+    function toLittleEndian64(uint256 _value) internal pure returns (uint256 result) {
+        result = 0;
+        uint256 tempValue = _value;
+        result = tempValue & 0xFF;
+        tempValue >>= 8;
+
+        result = (result << 8) | (tempValue & 0xFF);
+        tempValue >>= 8;
+
+        result = (result << 8) | (tempValue & 0xFF);
+        tempValue >>= 8;
+
+        result = (result << 8) | (tempValue & 0xFF);
+        tempValue >>= 8;
+
+        result = (result << 8) | (tempValue & 0xFF);
+        tempValue >>= 8;
+
+        result = (result << 8) | (tempValue & 0xFF);
+        tempValue >>= 8;
+
+        result = (result << 8) | (tempValue & 0xFF);
+        tempValue >>= 8;
+
+        result = (result << 8) | (tempValue & 0xFF);
+        tempValue >>= 8;
+
+        assert(0 == tempValue); // fully converted
+        result <<= (24 * 8);
+    }
+
+    /// @notice Returns the minimum value
+    /// @param _a First value
+    /// @param _b Second value
+    /// @return Smallest value between _a and _b
+    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {
+        return (_a > _b ? _b : _a);
+    }
+
+    /// @notice Returns the max value
+    /// @param _a First value
+    /// @param _b Second value
+    /// @return Highest value between _a and _b
+    function max(uint256 _a, uint256 _b) internal pure returns (uint256) {
+        return (_a < _b ? _b : _a);
+    }
+
+    /// @notice Performs a ceiled division
+    /// @param _a Numerator
+    /// @param _b Denominator
+    /// @return ceil(_a / _b)
+    function ceil(uint256 _a, uint256 _b) internal pure returns (uint256) {
+        return (_a / _b) + (_a % _b > 0 ? 1 : 0);
+    }
+}
diff -ruN src/contracts/src/libraries/LibUnstructuredStorage.sol contracts/src/libraries/LibUnstructuredStorage.sol
--- src/contracts/src/libraries/LibUnstructuredStorage.sol	1970-01-01 01:00:00
+++ contracts/src/libraries/LibUnstructuredStorage.sol	2024-01-16 15:06:39
@@ -0,0 +1,87 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity 0.8.20;
+
+/// @title Lib Unstructured Storage
+/// @notice Utilities to work with unstructured storage
+library LibUnstructuredStorage {
+    /// @notice Retrieve a bool value at a storage slot
+    /// @param _position The storage slot to retrieve
+    /// @return data The bool value
+    function getStorageBool(bytes32 _position) internal view returns (bool data) {
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            data := sload(_position)
+        }
+    }
+
+    /// @notice Retrieve an address value at a storage slot
+    /// @param _position The storage slot to retrieve
+    /// @return data The address value
+    function getStorageAddress(bytes32 _position) internal view returns (address data) {
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            data := sload(_position)
+        }
+    }
+
+    /// @notice Retrieve a bytes32 value at a storage slot
+    /// @param _position The storage slot to retrieve
+    /// @return data The bytes32 value
+    function getStorageBytes32(bytes32 _position) internal view returns (bytes32 data) {
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            data := sload(_position)
+        }
+    }
+
+    /// @notice Retrieve an uint256 value at a storage slot
+    /// @param _position The storage slot to retrieve
+    /// @return data The uint256 value
+    function getStorageUint256(bytes32 _position) internal view returns (uint256 data) {
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            data := sload(_position)
+        }
+    }
+
+    /// @notice Sets a bool value at a storage slot
+    /// @param _position The storage slot to set
+    /// @param _data The bool value to set
+    function setStorageBool(bytes32 _position, bool _data) internal {
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            sstore(_position, _data)
+        }
+    }
+
+    /// @notice Sets an address value at a storage slot
+    /// @param _position The storage slot to set
+    /// @param _data The address value to set
+    function setStorageAddress(bytes32 _position, address _data) internal {
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            sstore(_position, _data)
+        }
+    }
+
+    /// @notice Sets a bytes32 value at a storage slot
+    /// @param _position The storage slot to set
+    /// @param _data The bytes32 value to set
+    function setStorageBytes32(bytes32 _position, bytes32 _data) internal {
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            sstore(_position, _data)
+        }
+    }
+
+    /// @notice Sets an uint256 value at a storage slot
+    /// @param _position The storage slot to set
+    /// @param _data The uint256 value to set
+    function setStorageUint256(bytes32 _position, uint256 _data) internal {
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            sstore(_position, _data)
+        }
+    }
+}
diff -ruN src/contracts/src/migration/TLC_globalUnlockScheduleMigration.sol contracts/src/migration/TLC_globalUnlockScheduleMigration.sol
--- src/contracts/src/migration/TLC_globalUnlockScheduleMigration.sol	1970-01-01 01:00:00
+++ contracts/src/migration/TLC_globalUnlockScheduleMigration.sol	2024-01-16 15:06:39
@@ -0,0 +1,416 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../state/tlc/VestingSchedules.2.sol";
+import "../state/tlc/IgnoreGlobalUnlockSchedule.sol";
+
+struct VestingScheduleMigration {
+    // number of consecutive schedules to migrate with the same parameters
+    uint8 scheduleCount;
+    // The new lock duration
+    uint32 newLockDuration;
+    // if != 0, the new start value
+    uint64 newStart;
+    // if != 0, the new end value
+    uint64 newEnd;
+    // set cliff to 0 if true
+    bool setCliff;
+    // if true set vesting duration to 86400
+    bool setDuration;
+    // if true set vesting period duration to 86400
+    bool setPeriodDuration;
+    // if true schedule will not be subject to global unlock schedule
+    bool ignoreGlobalUnlock;
+}
+
+uint256 constant OCTOBER_16_2024 = 1729036800;
+
+contract TlcMigration {
+    error CliffTooLong(uint256 i);
+    error WrongUnlockDate(uint256 i);
+    error WrongEnd(uint256 i);
+
+    function migrate() external {
+        VestingScheduleMigration[] memory migrations = new VestingScheduleMigration[](30);
+        // 0 -> 6
+        migrations[0] = VestingScheduleMigration({
+            scheduleCount: 7,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 75772800,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: false
+        });
+        // 7
+        migrations[1] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 70329600,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: false
+        });
+        // 8
+        migrations[2] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 65491200,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: false
+        });
+        // 9 -> 12
+        migrations[3] = VestingScheduleMigration({
+            scheduleCount: 4,
+            newStart: 0,
+            newEnd: 1656720000,
+            newLockDuration: 72403200,
+            setCliff: true,
+            setDuration: true,
+            setPeriodDuration: true,
+            ignoreGlobalUnlock: false
+        });
+        // 13
+        migrations[4] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 67046400,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: false
+        });
+        // 14
+        migrations[5] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 56505600,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: false
+        });
+        // 15
+        migrations[6] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 58233600,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: false
+        });
+        // 16
+        migrations[7] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 57974400,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: false
+        });
+        // 17
+        migrations[8] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 53740800,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: true
+        });
+        // 18
+        migrations[9] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 75772800,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: false
+        });
+        // 19
+        migrations[10] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 49474800,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: false
+        });
+        // 20
+        migrations[11] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 75772800,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: false
+        });
+        // 21
+        migrations[12] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 49474800,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: false
+        });
+        // 22
+        migrations[13] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 75772800,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: false
+        });
+        // 23
+        migrations[14] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 49474800,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: false
+        });
+        // 24 -> 26
+        migrations[15] = VestingScheduleMigration({
+            scheduleCount: 3,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 75772800,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: false
+        });
+        // 27
+        migrations[16] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 70329600,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: false
+        });
+        // 28 -> 29
+        migrations[17] = VestingScheduleMigration({
+            scheduleCount: 2,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 50371200,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: false
+        });
+        // 30
+        migrations[18] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 50716800,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: true
+        });
+        // 31
+        migrations[19] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 50803200,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: true
+        });
+        // 32
+        migrations[20] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 50889600,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: true
+        });
+        // 33
+        migrations[21] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 50716800,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: true
+        });
+        // 34 -> 35
+        migrations[22] = VestingScheduleMigration({
+            scheduleCount: 2,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 50889600,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: true
+        });
+        // 36 -> 60
+        migrations[23] = VestingScheduleMigration({
+            scheduleCount: 25,
+            newStart: 1686175200,
+            newEnd: 1686261600,
+            newLockDuration: 42861600,
+            setCliff: false,
+            setDuration: true,
+            setPeriodDuration: true,
+            ignoreGlobalUnlock: false
+        });
+        // 61
+        migrations[24] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 40953600,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: false
+        });
+        // 62
+        migrations[25] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 48729600,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: false
+        });
+        // 63
+        migrations[26] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 41644800,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: true
+        });
+        // 64
+        migrations[27] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 47001600,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: true
+        });
+        // 65
+        migrations[28] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 45014400,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: true
+        });
+        // 66
+        migrations[29] = VestingScheduleMigration({
+            scheduleCount: 1,
+            newStart: 0,
+            newEnd: 0,
+            newLockDuration: 38188800,
+            setCliff: false,
+            setDuration: false,
+            setPeriodDuration: false,
+            ignoreGlobalUnlock: true
+        });
+        // All schedules covered
+
+        uint256 index = 0;
+        for (uint256 i = 0; i < migrations.length; i++) {
+            VestingScheduleMigration memory migration = migrations[i];
+            for (uint256 j = 0; j < migration.scheduleCount; j++) {
+                VestingSchedulesV2.VestingSchedule storage sch = VestingSchedulesV2.get(index);
+
+                bool isRevoked = false;
+                if (sch.start + sch.duration != sch.end) {
+                    isRevoked = true;
+                }
+                // Modifications
+                sch.lockDuration = migration.newLockDuration;
+                if (migration.newStart != 0) {
+                    sch.start = migration.newStart;
+                }
+                if (migration.newEnd != 0) {
+                    sch.end = migration.newEnd;
+                }
+                if (migration.setCliff) {
+                    sch.cliffDuration = 0;
+                }
+                if (migration.setDuration) {
+                    sch.duration = 86400;
+                }
+                if (migration.setPeriodDuration) {
+                    sch.periodDuration = 86400;
+                }
+                if (migration.ignoreGlobalUnlock) {
+                    IgnoreGlobalUnlockSchedule.set(index, true);
+                }
+
+                // Post effects checks
+                // check cliff is not longer than duration
+                if (sch.cliffDuration > sch.duration) {
+                    revert CliffTooLong(index);
+                }
+                // sanity checks on non revoked schedules
+                if (!isRevoked && (sch.end != sch.start + sch.duration)) {
+                    revert WrongEnd(index);
+                }
+                // check all the schedules are locked until unix : 1729036800
+                if (sch.start + sch.lockDuration != OCTOBER_16_2024) {
+                    revert WrongUnlockDate(index);
+                }
+
+                index += 1;
+            }
+        }
+    }
+}
diff -ruN src/contracts/src/mock/DepositContractMock.sol contracts/src/mock/DepositContractMock.sol
--- src/contracts/src/mock/DepositContractMock.sol	1970-01-01 01:00:00
+++ contracts/src/mock/DepositContractMock.sol	2024-01-16 15:06:39
@@ -0,0 +1,45 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../interfaces/IDepositContract.sol";
+
+contract DepositContractMock is IDepositContract {
+    event DepositEvent(bytes pubkey, bytes withdrawal_credentials, bytes amount, bytes signature, bytes index);
+
+    uint256 public depositCount;
+    address public receiver;
+
+    constructor(address _receiver) {
+        receiver = _receiver;
+    }
+
+    function to_little_endian_64(uint64 value) internal pure returns (bytes memory ret) {
+        ret = new bytes(8);
+        bytes8 bytesValue = bytes8(value);
+        // Byteswapping during copying to bytes.
+        ret[0] = bytesValue[7];
+        ret[1] = bytesValue[6];
+        ret[2] = bytesValue[5];
+        ret[3] = bytesValue[4];
+        ret[4] = bytesValue[3];
+        ret[5] = bytesValue[2];
+        ret[6] = bytesValue[1];
+        ret[7] = bytesValue[0];
+    }
+
+    function deposit(bytes calldata pubkey, bytes calldata withdrawalCredentials, bytes calldata signature, bytes32)
+        external
+        payable
+    {
+        emit DepositEvent(
+            pubkey,
+            withdrawalCredentials,
+            to_little_endian_64(uint64(msg.value / 1 gwei)),
+            signature,
+            to_little_endian_64(uint64(depositCount))
+        );
+        depositCount += 1;
+        (bool sent,) = receiver.call{value: address(this).balance}("");
+        require(sent, "Fund transfer failed");
+    }
+}
diff -ruN src/contracts/src/state/allowlist/AllowerAddress.sol contracts/src/state/allowlist/AllowerAddress.sol
--- src/contracts/src/state/allowlist/AllowerAddress.sol	1970-01-01 01:00:00
+++ contracts/src/state/allowlist/AllowerAddress.sol	2024-01-16 15:06:39
@@ -0,0 +1,25 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+import "../../libraries/LibSanitize.sol";
+
+/// @title Allower Address Storage
+/// @notice Utility to manage the Allower Address in storage
+library AllowerAddress {
+    /// @notice Storage slot of the Allower Address
+    bytes32 internal constant ALLOWER_ADDRESS_SLOT = bytes32(uint256(keccak256("river.state.allowerAddress")) - 1);
+
+    /// @notice Retrieve the Allower Address
+    /// @return The Allower Address
+    function get() internal view returns (address) {
+        return LibUnstructuredStorage.getStorageAddress(ALLOWER_ADDRESS_SLOT);
+    }
+
+    /// @notice Sets the Allower Address
+    /// @param _newValue New Allower Address
+    function set(address _newValue) internal {
+        LibSanitize._notZeroAddress(_newValue);
+        LibUnstructuredStorage.setStorageAddress(ALLOWER_ADDRESS_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/allowlist/Allowlist.sol contracts/src/state/allowlist/Allowlist.sol
--- src/contracts/src/state/allowlist/Allowlist.sol	1970-01-01 01:00:00
+++ contracts/src/state/allowlist/Allowlist.sol	2024-01-16 15:06:39
@@ -0,0 +1,47 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Allowlist Storage
+/// @notice Utility to manage the Allowlist mapping in storage
+library Allowlist {
+    /// @notice Storage slot of the Allowlist mapping
+    bytes32 internal constant ALLOWLIST_SLOT = bytes32(uint256(keccak256("river.state.allowlist")) - 1);
+
+    /// @notice Structure stored in storage slot
+    struct Slot {
+        /// @custom:attribute Mapping keeping track of permissions per account
+        mapping(address => uint256) value;
+    }
+
+    /// @notice Retrieve the Allowlist value of an account
+    /// @param _account The account to verify
+    /// @return The Allowlist value
+    function get(address _account) internal view returns (uint256) {
+        bytes32 slot = ALLOWLIST_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        return r.value[_account];
+    }
+
+    /// @notice Sets the Allowlist value of an account
+    /// @param _account The account value to set
+    /// @param _status The value to set
+    function set(address _account, uint256 _status) internal {
+        bytes32 slot = ALLOWLIST_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        r.value[_account] = _status;
+    }
+}
diff -ruN src/contracts/src/state/allowlist/DenierAddress.sol contracts/src/state/allowlist/DenierAddress.sol
--- src/contracts/src/state/allowlist/DenierAddress.sol	1970-01-01 01:00:00
+++ contracts/src/state/allowlist/DenierAddress.sol	2024-01-16 15:06:39
@@ -0,0 +1,25 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+import "../../libraries/LibSanitize.sol";
+
+/// @title Denier Address Storage
+/// @notice Utility to manage the Denier Address in storage
+library DenierAddress {
+    /// @notice Storage slot of the Denier Address
+    bytes32 internal constant DENIER_ADDRESS_SLOT = bytes32(uint256(keccak256("river.state.denierAddress")) - 1);
+
+    /// @notice Retrieve the Denier Address
+    /// @return The Denier Address
+    function get() internal view returns (address) {
+        return LibUnstructuredStorage.getStorageAddress(DENIER_ADDRESS_SLOT);
+    }
+
+    /// @notice Sets the Denier Address
+    /// @param _newValue New Denier Address
+    function set(address _newValue) internal {
+        LibSanitize._notZeroAddress(_newValue);
+        LibUnstructuredStorage.setStorageAddress(DENIER_ADDRESS_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_KeyIndex.sol contracts/src/state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_KeyIndex.sol
--- src/contracts/src/state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_KeyIndex.sol	1970-01-01 01:00:00
+++ contracts/src/state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_KeyIndex.sol	2024-01-16 15:06:39
@@ -0,0 +1,17 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+
+library OperatorsRegistry_FundedKeyEventRebroadcasting_KeyIndex {
+    bytes32 internal constant KEY_INDEX_SLOT =
+        bytes32(uint256(keccak256("river.state.migration.operatorsRegistry.fundedKeyEventRebroadcasting.keyIndex")) - 1);
+
+    function get() internal view returns (uint256) {
+        return LibUnstructuredStorage.getStorageUint256(KEY_INDEX_SLOT);
+    }
+
+    function set(uint256 _newValue) internal {
+        LibUnstructuredStorage.setStorageUint256(KEY_INDEX_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex.sol contracts/src/state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex.sol
--- src/contracts/src/state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex.sol	1970-01-01 01:00:00
+++ contracts/src/state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex.sol	2024-01-16 15:06:39
@@ -0,0 +1,18 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+
+library OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex {
+    bytes32 internal constant OPERATOR_INDEX_SLOT = bytes32(
+        uint256(keccak256("river.state.migration.operatorsRegistry.fundedKeyEventRebroadcasting.operatorIndex")) - 1
+    );
+
+    function get() internal view returns (uint256) {
+        return LibUnstructuredStorage.getStorageUint256(OPERATOR_INDEX_SLOT);
+    }
+
+    function set(uint256 _newValue) internal {
+        LibUnstructuredStorage.setStorageUint256(OPERATOR_INDEX_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/operatorsRegistry/CurrentValidatorExitsDemand.sol contracts/src/state/operatorsRegistry/CurrentValidatorExitsDemand.sol
--- src/contracts/src/state/operatorsRegistry/CurrentValidatorExitsDemand.sol	1970-01-01 01:00:00
+++ contracts/src/state/operatorsRegistry/CurrentValidatorExitsDemand.sol	2024-01-16 15:06:39
@@ -0,0 +1,26 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+
+/// @title CurrentValidatorExitsDemand Storage
+/// @notice This value controls the current demand for exits that still need to be triggered
+/// @notice in order to notify the operators
+/// @notice Utility to manage the CurrentValidatorExitsDemand in storage
+library CurrentValidatorExitsDemand {
+    /// @notice Storage slot of the CurrentValidatorExitsDemand
+    bytes32 internal constant CURRENT_VALIDATOR_EXITS_DEMAND_SLOT =
+        bytes32(uint256(keccak256("river.state.currentValidatorExitsDemand")) - 1);
+
+    /// @notice Retrieve the CurrentValidatorExitsDemand
+    /// @return The CurrentValidatorExitsDemand
+    function get() internal view returns (uint256) {
+        return LibUnstructuredStorage.getStorageUint256(CURRENT_VALIDATOR_EXITS_DEMAND_SLOT);
+    }
+
+    /// @notice Sets the CurrentValidatorExitsDemand
+    /// @param _newValue New CurrentValidatorExitsDemand
+    function set(uint256 _newValue) internal {
+        return LibUnstructuredStorage.setStorageUint256(CURRENT_VALIDATOR_EXITS_DEMAND_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/operatorsRegistry/Operators.1.sol contracts/src/state/operatorsRegistry/Operators.1.sol
--- src/contracts/src/state/operatorsRegistry/Operators.1.sol	1970-01-01 01:00:00
+++ contracts/src/state/operatorsRegistry/Operators.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,239 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibSanitize.sol";
+
+/// @title Operators Storage
+/// @notice Utility to manage the Operators in storage
+/// @notice This state variable is deprecated and was kept due to migration logic needs
+library OperatorsV1 {
+    /// @notice Storage slot of the Operators
+    bytes32 internal constant OPERATORS_SLOT = bytes32(uint256(keccak256("river.state.operators")) - 1);
+
+    /// @notice The Operator structure in storage
+    struct Operator {
+        /// @custom:attribute True if the operator is active and allowed to operate on River
+        bool active;
+        /// @custom:attribute Display name of the operator
+        string name;
+        /// @custom:attribute Address of the operator
+        address operator;
+        /// @dev The following values respect this invariant:
+        /// @dev     keys >= limit >= funded >= stopped
+
+        /// @custom:attribute Staking limit of the operator
+        uint256 limit;
+        /// @custom:attribute The count of funded validators
+        uint256 funded;
+        /// @custom:attribute The total count of keys of the operator
+        uint256 keys;
+        /// @custom:attribute The count of stopped validators. Stopped validators are validators
+        ///                   that exited the consensus layer (voluntary or slashed)
+        uint256 stopped;
+        uint256 latestKeysEditBlockNumber;
+    }
+
+    /// @notice The Operator structure when loaded in memory
+    struct CachedOperator {
+        /// @custom:attribute True if the operator is active and allowed to operate on River
+        bool active;
+        /// @custom:attribute Display name of the operator
+        string name;
+        /// @custom:attribute Address of the operator
+        address operator;
+        /// @custom:attribute Staking limit of the operator
+        uint256 limit;
+        /// @custom:attribute The count of funded validators
+        uint256 funded;
+        /// @custom:attribute The total count of keys of the operator
+        uint256 keys;
+        /// @custom:attribute The count of stopped validators
+        uint256 stopped;
+        /// @custom:attribute The count of stopped validators. Stopped validators are validators
+        ///                   that exited the consensus layer (voluntary or slashed)
+        uint256 index;
+        /// @custom:attribute The amount of picked keys, buffer used before changing funded in storage
+        uint256 picked;
+    }
+
+    /// @notice The structure at the storage slot
+    struct SlotOperator {
+        /// @custom:attribute Array containing all the operators
+        Operator[] value;
+    }
+
+    /// @notice The operator was not found
+    /// @param index The provided index
+    error OperatorNotFound(uint256 index);
+
+    /// @notice Retrieve the operator in storage
+    /// @param _index The index of the operator
+    /// @return The Operator structure
+    function get(uint256 _index) internal view returns (Operator storage) {
+        bytes32 slot = OPERATORS_SLOT;
+
+        SlotOperator storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        if (r.value.length <= _index) {
+            revert OperatorNotFound(_index);
+        }
+
+        return r.value[_index];
+    }
+
+    /// @notice Retrieve the operator count in storage
+    /// @return The count of operators in storage
+    function getCount() internal view returns (uint256) {
+        bytes32 slot = OPERATORS_SLOT;
+
+        SlotOperator storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        return r.value.length;
+    }
+
+    /// @notice Retrieve all the active operators
+    /// @return The list of active operator structures
+    function getAllActive() internal view returns (Operator[] memory) {
+        bytes32 slot = OPERATORS_SLOT;
+
+        SlotOperator storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        uint256 activeCount = 0;
+        uint256 operatorCount = r.value.length;
+
+        for (uint256 idx = 0; idx < operatorCount;) {
+            if (r.value[idx].active) {
+                unchecked {
+                    ++activeCount;
+                }
+            }
+            unchecked {
+                ++idx;
+            }
+        }
+
+        Operator[] memory activeOperators = new Operator[](activeCount);
+
+        uint256 activeIdx = 0;
+        for (uint256 idx = 0; idx < operatorCount;) {
+            if (r.value[idx].active) {
+                activeOperators[activeIdx] = r.value[idx];
+                unchecked {
+                    ++activeIdx;
+                }
+            }
+            unchecked {
+                ++idx;
+            }
+        }
+
+        return activeOperators;
+    }
+
+    /// @notice Retrieve all the active and fundable operators
+    /// @return The list of active and fundable operators
+    function getAllFundable() internal view returns (CachedOperator[] memory) {
+        bytes32 slot = OPERATORS_SLOT;
+
+        SlotOperator storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        uint256 activeCount = 0;
+        uint256 operatorCount = r.value.length;
+
+        for (uint256 idx = 0; idx < operatorCount;) {
+            if (_hasFundableKeys(r.value[idx])) {
+                unchecked {
+                    ++activeCount;
+                }
+            }
+            unchecked {
+                ++idx;
+            }
+        }
+
+        CachedOperator[] memory activeOperators = new CachedOperator[](activeCount);
+
+        uint256 activeIdx = 0;
+        for (uint256 idx = 0; idx < operatorCount;) {
+            Operator memory op = r.value[idx];
+            if (_hasFundableKeys(op)) {
+                activeOperators[activeIdx] = CachedOperator({
+                    active: op.active,
+                    name: op.name,
+                    operator: op.operator,
+                    limit: op.limit,
+                    funded: op.funded,
+                    keys: op.keys,
+                    stopped: op.stopped,
+                    index: idx,
+                    picked: 0
+                });
+                unchecked {
+                    ++activeIdx;
+                }
+            }
+            unchecked {
+                ++idx;
+            }
+        }
+
+        return activeOperators;
+    }
+
+    /// @notice Add a new operator in storage
+    /// @param _newOperator Value of the new operator
+    /// @return The size of the operator array after the operation
+    function push(Operator memory _newOperator) internal returns (uint256) {
+        LibSanitize._notZeroAddress(_newOperator.operator);
+        LibSanitize._notEmptyString(_newOperator.name);
+        bytes32 slot = OPERATORS_SLOT;
+
+        SlotOperator storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        r.value.push(_newOperator);
+
+        return r.value.length;
+    }
+
+    /// @notice Atomic operation to set the key count and update the latestKeysEditBlockNumber field at the same time
+    /// @param _index The operator index
+    /// @param _newKeys The new value for the key count
+    function setKeys(uint256 _index, uint256 _newKeys) internal {
+        Operator storage op = get(_index);
+
+        op.keys = _newKeys;
+        op.latestKeysEditBlockNumber = block.number;
+    }
+
+    /// @notice Checks if an operator is active and has fundable keys
+    /// @param _operator The operator details
+    /// @return True if active and fundable
+    function _hasFundableKeys(OperatorsV1.Operator memory _operator) internal pure returns (bool) {
+        return (_operator.active && _operator.limit > _operator.funded);
+    }
+}
diff -ruN src/contracts/src/state/operatorsRegistry/Operators.2.sol contracts/src/state/operatorsRegistry/Operators.2.sol
--- src/contracts/src/state/operatorsRegistry/Operators.2.sol	1970-01-01 01:00:00
+++ contracts/src/state/operatorsRegistry/Operators.2.sol	2024-01-16 15:06:39
@@ -0,0 +1,347 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibSanitize.sol";
+
+/// @title Operators Storage
+/// @notice Utility to manage the Operators in storage
+library OperatorsV2 {
+    /// @notice Storage slot of the Operators
+    bytes32 internal constant OPERATORS_SLOT = bytes32(uint256(keccak256("river.state.v2.operators")) - 1);
+
+    /// @notice The Operator structure in storage
+    struct Operator {
+        /// @dev The following values respect this invariant:
+        /// @dev     keys >= limit >= funded >= RequestedExits
+
+        /// @custom:attribute Staking limit of the operator
+        uint32 limit;
+        /// @custom:attribute The count of funded validators
+        uint32 funded;
+        /// @custom:attribute The count of exit requests made to this operator
+        uint32 requestedExits;
+        /// @custom:attribute The total count of keys of the operator
+        uint32 keys;
+        /// @custom attribute The block at which the last edit happened in the operator details
+        uint64 latestKeysEditBlockNumber;
+        /// @custom:attribute True if the operator is active and allowed to operate on River
+        bool active;
+        /// @custom:attribute Display name of the operator
+        string name;
+        /// @custom:attribute Address of the operator
+        address operator;
+    }
+
+    /// @notice The Operator structure when loaded in memory
+    struct CachedOperator {
+        /// @custom:attribute Staking limit of the operator
+        uint32 limit;
+        /// @custom:attribute The count of funded validators
+        uint32 funded;
+        /// @custom:attribute The count of exit requests made to this operator
+        uint32 requestedExits;
+        /// @custom:attribute The original index of the operator
+        uint32 index;
+        /// @custom:attribute The amount of picked keys, buffer used before changing funded in storage
+        uint32 picked;
+    }
+
+    /// @notice The Operator structure when loaded in memory for the exit selection
+    struct CachedExitableOperator {
+        /// @custom:attribute The count of funded validators
+        uint32 funded;
+        /// @custom:attribute The count of exit requests made to this operator
+        uint32 requestedExits;
+        /// @custom:attribute The original index of the operator
+        uint32 index;
+        /// @custom:attribute The amount of picked keys, buffer used before changing funded in storage
+        uint32 picked;
+    }
+
+    /// @notice The structure at the storage slot
+    struct SlotOperator {
+        /// @custom:attribute Array containing all the operators
+        Operator[] value;
+    }
+
+    /// @notice The operator was not found
+    /// @param index The provided index
+    error OperatorNotFound(uint256 index);
+
+    /// @notice Retrieve the operator in storage
+    /// @param _index The index of the operator
+    /// @return The Operator structure
+    function get(uint256 _index) internal view returns (Operator storage) {
+        bytes32 slot = OPERATORS_SLOT;
+
+        SlotOperator storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        if (r.value.length <= _index) {
+            revert OperatorNotFound(_index);
+        }
+
+        return r.value[_index];
+    }
+
+    /// @notice Retrieve the operators in storage
+    /// @return The Operator structure array
+    function getAll() internal view returns (Operator[] storage) {
+        bytes32 slot = OPERATORS_SLOT;
+
+        SlotOperator storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        return r.value;
+    }
+
+    /// @notice Retrieve the operator count in storage
+    /// @return The count of operators in storage
+    function getCount() internal view returns (uint256) {
+        bytes32 slot = OPERATORS_SLOT;
+
+        SlotOperator storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        return r.value.length;
+    }
+
+    /// @notice Retrieve all the active operators
+    /// @return The list of active operator structures
+    function getAllActive() internal view returns (Operator[] memory) {
+        bytes32 slot = OPERATORS_SLOT;
+
+        SlotOperator storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        uint256 activeCount = 0;
+        uint256 operatorCount = r.value.length;
+
+        for (uint256 idx = 0; idx < operatorCount;) {
+            if (r.value[idx].active) {
+                unchecked {
+                    ++activeCount;
+                }
+            }
+            unchecked {
+                ++idx;
+            }
+        }
+
+        Operator[] memory activeOperators = new Operator[](activeCount);
+
+        uint256 activeIdx = 0;
+        for (uint256 idx = 0; idx < operatorCount;) {
+            if (r.value[idx].active) {
+                activeOperators[activeIdx] = r.value[idx];
+                unchecked {
+                    ++activeIdx;
+                }
+            }
+            unchecked {
+                ++idx;
+            }
+        }
+
+        return activeOperators;
+    }
+
+    /// @notice Retrieve the stopped validator count for an operator by its index
+    /// @param stoppedValidatorCounts The storage pointer to the raw array containing the stopped validator counts
+    /// @param index The index of the operator to lookup
+    /// @return The amount of stopped validators for the given operator index
+    function _getStoppedValidatorCountAtIndex(uint32[] storage stoppedValidatorCounts, uint256 index)
+        internal
+        view
+        returns (uint32)
+    {
+        if (index + 1 >= stoppedValidatorCounts.length) {
+            return 0;
+        }
+        return stoppedValidatorCounts[index + 1];
+    }
+
+    /// @notice Retrieve all the active and fundable operators
+    /// @dev This method will return a memory array of length equal to the number of operator, but only
+    /// @dev populated up to the fundable operator count, also returned by the method
+    /// @return The list of active and fundable operators
+    /// @return The count of active and fundable operators
+    function getAllFundable() internal view returns (CachedOperator[] memory, uint256) {
+        bytes32 slot = OPERATORS_SLOT;
+
+        SlotOperator storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        uint256 fundableCount = 0;
+        uint256 operatorCount = r.value.length;
+        CachedOperator[] memory fundableOperators = new CachedOperator[](operatorCount);
+
+        uint32[] storage stoppedValidatorCounts = getStoppedValidators();
+
+        for (uint256 idx = 0; idx < operatorCount;) {
+            if (
+                _hasFundableKeys(r.value[idx])
+                    && _getStoppedValidatorCountAtIndex(stoppedValidatorCounts, idx) >= r.value[idx].requestedExits
+            ) {
+                Operator storage op = r.value[idx];
+                fundableOperators[fundableCount] = CachedOperator({
+                    limit: op.limit,
+                    funded: op.funded,
+                    requestedExits: op.requestedExits,
+                    index: uint32(idx),
+                    picked: 0
+                });
+                unchecked {
+                    ++fundableCount;
+                }
+            }
+            unchecked {
+                ++idx;
+            }
+        }
+
+        return (fundableOperators, fundableCount);
+    }
+
+    /// @notice Retrieve all the active and exitable operators
+    /// @dev This method will return a memory array of length equal to the number of operator, but only
+    /// @dev populated up to the exitable operator count, also returned by the method
+    /// @return The list of active and exitable operators
+    /// @return The count of active and exitable operators
+    function getAllExitable() internal view returns (CachedExitableOperator[] memory, uint256) {
+        bytes32 slot = OPERATORS_SLOT;
+
+        SlotOperator storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        uint256 exitableCount = 0;
+        uint256 operatorCount = r.value.length;
+
+        CachedExitableOperator[] memory exitableOperators = new CachedExitableOperator[](operatorCount);
+
+        for (uint256 idx = 0; idx < operatorCount;) {
+            if (_hasExitableKeys(r.value[idx])) {
+                Operator storage op = r.value[idx];
+                exitableOperators[exitableCount] = CachedExitableOperator({
+                    funded: op.funded,
+                    requestedExits: op.requestedExits,
+                    index: uint32(idx),
+                    picked: 0
+                });
+                unchecked {
+                    ++exitableCount;
+                }
+            }
+            unchecked {
+                ++idx;
+            }
+        }
+
+        return (exitableOperators, exitableCount);
+    }
+
+    /// @notice Add a new operator in storage
+    /// @param _newOperator Value of the new operator
+    /// @return The size of the operator array after the operation
+    function push(Operator memory _newOperator) internal returns (uint256) {
+        LibSanitize._notZeroAddress(_newOperator.operator);
+        LibSanitize._notEmptyString(_newOperator.name);
+        bytes32 slot = OPERATORS_SLOT;
+
+        SlotOperator storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        r.value.push(_newOperator);
+
+        return r.value.length;
+    }
+
+    /// @notice Atomic operation to set the key count and update the latestKeysEditBlockNumber field at the same time
+    /// @param _index The operator index
+    /// @param _newKeys The new value for the key count
+    function setKeys(uint256 _index, uint32 _newKeys) internal {
+        Operator storage op = get(_index);
+
+        op.keys = _newKeys;
+        op.latestKeysEditBlockNumber = uint64(block.number);
+    }
+
+    /// @notice Checks if an operator is active and has fundable keys
+    /// @param _operator The operator details
+    /// @return True if active and fundable
+    function _hasFundableKeys(OperatorsV2.Operator memory _operator) internal pure returns (bool) {
+        return (_operator.active && _operator.limit > _operator.funded);
+    }
+
+    /// @notice Checks if an operator is active and has exitable keys
+    /// @param _operator The operator details
+    /// @return True if active and exitable
+    function _hasExitableKeys(OperatorsV2.Operator memory _operator) internal pure returns (bool) {
+        return (_operator.active && _operator.funded > _operator.requestedExits);
+    }
+
+    /// @notice Storage slot of the Stopped Validators
+    bytes32 internal constant STOPPED_VALIDATORS_SLOT = bytes32(uint256(keccak256("river.state.stoppedValidators")) - 1);
+
+    struct SlotStoppedValidators {
+        uint32[] value;
+    }
+
+    /// @notice Retrieve the storage pointer of the Stopped Validators array
+    /// @return The Stopped Validators storage pointer
+    function getStoppedValidators() internal view returns (uint32[] storage) {
+        bytes32 slot = STOPPED_VALIDATORS_SLOT;
+
+        SlotStoppedValidators storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        return r.value;
+    }
+
+    /// @notice Sets the entire stopped validators array
+    /// @param value The new stopped validators array
+    function setRawStoppedValidators(uint32[] memory value) internal {
+        bytes32 slot = STOPPED_VALIDATORS_SLOT;
+
+        SlotStoppedValidators storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        r.value = value;
+    }
+}
diff -ruN src/contracts/src/state/operatorsRegistry/TotalValidatorExitsRequested.sol contracts/src/state/operatorsRegistry/TotalValidatorExitsRequested.sol
--- src/contracts/src/state/operatorsRegistry/TotalValidatorExitsRequested.sol	1970-01-01 01:00:00
+++ contracts/src/state/operatorsRegistry/TotalValidatorExitsRequested.sol	2024-01-16 15:06:39
@@ -0,0 +1,25 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+
+/// @title TotalValidatorExitsRequested Storage
+/// @notice This value is the amount of performed exit requests, only increased when there is current exit demand
+/// @notice Utility to manage the TotalValidatorExitsRequested in storage
+library TotalValidatorExitsRequested {
+    /// @notice Storage slot of the TotalValidatorExitsRequested
+    bytes32 internal constant TOTAL_VALIDATOR_EXITS_REQUESTED_SLOT =
+        bytes32(uint256(keccak256("river.state.totalValidatorExitsRequested")) - 1);
+
+    /// @notice Retrieve the TotalValidatorExitsRequested
+    /// @return The TotalValidatorExitsRequested
+    function get() internal view returns (uint256) {
+        return LibUnstructuredStorage.getStorageUint256(TOTAL_VALIDATOR_EXITS_REQUESTED_SLOT);
+    }
+
+    /// @notice Sets the TotalValidatorExitsRequested
+    /// @param _newValue New TotalValidatorExitsRequested
+    function set(uint256 _newValue) internal {
+        return LibUnstructuredStorage.setStorageUint256(TOTAL_VALIDATOR_EXITS_REQUESTED_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/operatorsRegistry/ValidatorKeys.sol contracts/src/state/operatorsRegistry/ValidatorKeys.sol
--- src/contracts/src/state/operatorsRegistry/ValidatorKeys.sol	1970-01-01 01:00:00
+++ contracts/src/state/operatorsRegistry/ValidatorKeys.sol	2024-01-16 15:06:39
@@ -0,0 +1,121 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibBytes.sol";
+
+/// @title Validator Keys Storage
+/// @notice Utility to manage the validator keys in storage
+library ValidatorKeys {
+    /// @notice Storage slot of the Validator Keys
+    bytes32 internal constant VALIDATOR_KEYS_SLOT = bytes32(uint256(keccak256("river.state.validatorKeys")) - 1);
+
+    /// @notice Length in bytes of a BLS Public Key used for validator deposits
+    uint256 internal constant PUBLIC_KEY_LENGTH = 48;
+
+    /// @notice Length in bytes of a BLS Signature used for validator deposits
+    uint256 internal constant SIGNATURE_LENGTH = 96;
+
+    /// @notice The provided public key is not matching the expected length
+    error InvalidPublicKey();
+
+    /// @notice The provided signature is not matching the expected length
+    error InvalidSignature();
+
+    /// @notice Structure of the Validator Keys in storage
+    struct Slot {
+        /// @custom:attribute The mapping from operator index to key index to key value
+        mapping(uint256 => mapping(uint256 => bytes)) value;
+    }
+
+    /// @notice Retrieve the Validator Key of an operator at a specific index
+    /// @param _operatorIndex The operator index
+    /// @param _idx the Validator Key index
+    /// @return publicKey The Validator Key public key
+    /// @return signature The Validator Key signature
+    function get(uint256 _operatorIndex, uint256 _idx)
+        internal
+        view
+        returns (bytes memory publicKey, bytes memory signature)
+    {
+        bytes32 slot = VALIDATOR_KEYS_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        bytes storage entry = r.value[_operatorIndex][_idx];
+
+        publicKey = LibBytes.slice(entry, 0, PUBLIC_KEY_LENGTH);
+        signature = LibBytes.slice(entry, PUBLIC_KEY_LENGTH, SIGNATURE_LENGTH);
+    }
+
+    /// @notice Retrieve the raw concatenated Validator Keys
+    /// @param _operatorIndex The operator index
+    /// @param _idx The Validator Key index
+    /// @return The concatenated public key and signature
+    function getRaw(uint256 _operatorIndex, uint256 _idx) internal view returns (bytes memory) {
+        bytes32 slot = VALIDATOR_KEYS_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        return r.value[_operatorIndex][_idx];
+    }
+
+    /// @notice Retrieve multiple keys of an operator starting at an index
+    /// @param _operatorIndex The operator index
+    /// @param _startIdx The starting index to retrieve the keys from
+    /// @param _amount The amount of keys to retrieve
+    /// @return publicKeys The public keys retrieved
+    /// @return signatures The signatures associated with the public keys
+    function getKeys(uint256 _operatorIndex, uint256 _startIdx, uint256 _amount)
+        internal
+        view
+        returns (bytes[] memory publicKeys, bytes[] memory signatures)
+    {
+        publicKeys = new bytes[](_amount);
+        signatures = new bytes[](_amount);
+
+        bytes32 slot = VALIDATOR_KEYS_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+        uint256 idx;
+        for (; idx < _amount;) {
+            bytes memory rawCredentials = r.value[_operatorIndex][idx + _startIdx];
+            publicKeys[idx] = LibBytes.slice(rawCredentials, 0, PUBLIC_KEY_LENGTH);
+            signatures[idx] = LibBytes.slice(rawCredentials, PUBLIC_KEY_LENGTH, SIGNATURE_LENGTH);
+            unchecked {
+                ++idx;
+            }
+        }
+    }
+
+    /// @notice Set the concatenated Validator Keys at an index for an operator
+    /// @param _operatorIndex The operator index
+    /// @param _idx The key index to write on
+    /// @param _publicKeyAndSignature The concatenated Validator Keys
+    function set(uint256 _operatorIndex, uint256 _idx, bytes memory _publicKeyAndSignature) internal {
+        bytes32 slot = VALIDATOR_KEYS_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        r.value[_operatorIndex][_idx] = _publicKeyAndSignature;
+    }
+}
diff -ruN src/contracts/src/state/oracle/LastEpochId.sol contracts/src/state/oracle/LastEpochId.sol
--- src/contracts/src/state/oracle/LastEpochId.sol	1970-01-01 01:00:00
+++ contracts/src/state/oracle/LastEpochId.sol	2024-01-16 15:06:39
@@ -0,0 +1,23 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+
+/// @title Last Epoch Id Storage
+/// @notice Utility to manage the Last Epoch Id in storage
+library LastEpochId {
+    /// @notice Storage slot of the Last Epoch Id
+    bytes32 internal constant LAST_EPOCH_ID_SLOT = bytes32(uint256(keccak256("river.state.lastEpochId")) - 1);
+
+    /// @notice Retrieve the Last Epoch Id
+    /// @return The Last Epoch Id
+    function get() internal view returns (uint256) {
+        return LibUnstructuredStorage.getStorageUint256(LAST_EPOCH_ID_SLOT);
+    }
+
+    /// @notice Sets the Last Epoch Id
+    /// @param _newValue New Last Epoch Id
+    function set(uint256 _newValue) internal {
+        LibUnstructuredStorage.setStorageUint256(LAST_EPOCH_ID_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/oracle/OracleMembers.sol contracts/src/state/oracle/OracleMembers.sol
--- src/contracts/src/state/oracle/OracleMembers.sol	1970-01-01 01:00:00
+++ contracts/src/state/oracle/OracleMembers.sol	2024-01-16 15:06:39
@@ -0,0 +1,111 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibSanitize.sol";
+
+/// @title Oracle Members Storage
+/// @notice Utility to manage the Oracle Members in storage
+/// @dev There can only be up to 256 oracle members. This is due to how report statuses are stored in Reports Positions
+library OracleMembers {
+    /// @notice Storage slot of the Oracle Members
+    bytes32 internal constant ORACLE_MEMBERS_SLOT = bytes32(uint256(keccak256("river.state.oracleMembers")) - 1);
+
+    /// @notice The structure in storage
+    struct Slot {
+        /// @custom:attribute The array of oracle members
+        address[] value;
+    }
+
+    /// @notice Retrieve the list of oracle members
+    /// @return List of oracle members
+    function get() internal view returns (address[] memory) {
+        bytes32 slot = ORACLE_MEMBERS_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        return r.value;
+    }
+
+    /// @notice Add a new oracle member to the list
+    /// @param _newOracleMember Address of the new oracle member
+    function push(address _newOracleMember) internal {
+        LibSanitize._notZeroAddress(_newOracleMember);
+
+        bytes32 slot = ORACLE_MEMBERS_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        r.value.push(_newOracleMember);
+    }
+
+    /// @notice Set an address in the oracle member list
+    /// @param _index The index to edit
+    /// @param _newOracleAddress The new value of the oracle member
+    function set(uint256 _index, address _newOracleAddress) internal {
+        bytes32 slot = ORACLE_MEMBERS_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        r.value[_index] = _newOracleAddress;
+    }
+
+    /// @notice Retrieve the index of the oracle member
+    /// @param _memberAddress The address to lookup
+    /// @return The index of the member, -1 if not found
+    function indexOf(address _memberAddress) internal view returns (int256) {
+        bytes32 slot = ORACLE_MEMBERS_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        for (uint256 idx = 0; idx < r.value.length;) {
+            if (r.value[idx] == _memberAddress) {
+                return int256(idx);
+            }
+            unchecked {
+                ++idx;
+            }
+        }
+
+        return int256(-1);
+    }
+
+    /// @notice Delete the oracle member at the given index
+    /// @param _idx The index of the member to remove
+    function deleteItem(uint256 _idx) internal {
+        bytes32 slot = ORACLE_MEMBERS_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        uint256 lastIdx = r.value.length - 1;
+        if (lastIdx != _idx) {
+            r.value[_idx] = r.value[lastIdx];
+        }
+
+        r.value.pop();
+    }
+}
diff -ruN src/contracts/src/state/oracle/Quorum.sol contracts/src/state/oracle/Quorum.sol
--- src/contracts/src/state/oracle/Quorum.sol	1970-01-01 01:00:00
+++ contracts/src/state/oracle/Quorum.sol	2024-01-16 15:06:39
@@ -0,0 +1,23 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+
+/// @title Quorum Storage
+/// @notice Utility to manage the Quorum in storage
+library Quorum {
+    /// @notice Storage slot of the Quorum
+    bytes32 internal constant QUORUM_SLOT = bytes32(uint256(keccak256("river.state.quorum")) - 1);
+
+    /// @notice Retrieve the Quorum
+    /// @return The Quorum
+    function get() internal view returns (uint256) {
+        return LibUnstructuredStorage.getStorageUint256(QUORUM_SLOT);
+    }
+
+    /// @notice Sets the Quorum
+    /// @param _newValue New Quorum
+    function set(uint256 _newValue) internal {
+        return LibUnstructuredStorage.setStorageUint256(QUORUM_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/oracle/ReportsPositions.sol contracts/src/state/oracle/ReportsPositions.sol
--- src/contracts/src/state/oracle/ReportsPositions.sol	1970-01-01 01:00:00
+++ contracts/src/state/oracle/ReportsPositions.sol	2024-01-16 15:06:39
@@ -0,0 +1,40 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+
+/// @title Reports Positions Storage
+/// @notice Utility to manage the Reports Positions in storage
+/// @dev Each bit in the stored uint256 value tells if the member at a given index has reported
+library ReportsPositions {
+    /// @notice Storage slot of the Reports Positions
+    bytes32 internal constant REPORTS_POSITIONS_SLOT = bytes32(uint256(keccak256("river.state.reportsPositions")) - 1);
+
+    /// @notice Retrieve the Reports Positions at index
+    /// @param _idx The index to retrieve
+    /// @return True if already reported
+    function get(uint256 _idx) internal view returns (bool) {
+        uint256 mask = 1 << _idx;
+        return LibUnstructuredStorage.getStorageUint256(REPORTS_POSITIONS_SLOT) & mask == mask;
+    }
+
+    /// @notice Retrieve the raw Reports Positions from storage
+    /// @return Raw Reports Positions
+    function getRaw() internal view returns (uint256) {
+        return LibUnstructuredStorage.getStorageUint256(REPORTS_POSITIONS_SLOT);
+    }
+
+    /// @notice Register an index as reported
+    /// @param _idx The index to register
+    function register(uint256 _idx) internal {
+        uint256 mask = 1 << _idx;
+        return LibUnstructuredStorage.setStorageUint256(
+            REPORTS_POSITIONS_SLOT, LibUnstructuredStorage.getStorageUint256(REPORTS_POSITIONS_SLOT) | mask
+        );
+    }
+
+    /// @notice Clears all the report positions in storage
+    function clear() internal {
+        return LibUnstructuredStorage.setStorageUint256(REPORTS_POSITIONS_SLOT, 0);
+    }
+}
diff -ruN src/contracts/src/state/oracle/ReportsVariants.sol contracts/src/state/oracle/ReportsVariants.sol
--- src/contracts/src/state/oracle/ReportsVariants.sol	1970-01-01 01:00:00
+++ contracts/src/state/oracle/ReportsVariants.sol	2024-01-16 15:06:39
@@ -0,0 +1,105 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Reports Variants Storage
+/// @notice Utility to manage the Reports Variants in storage
+library ReportsVariants {
+    /// @notice Storage slot of the Reports Variants
+    bytes32 internal constant REPORT_VARIANTS_SLOT = bytes32(uint256(keccak256("river.state.reportsVariants")) - 1);
+
+    struct ReportVariantDetails {
+        bytes32 variant;
+        uint256 votes;
+    }
+
+    /// @notice Structure in storage
+    struct Slot {
+        /// @custom:attribute The list of variants
+        ReportVariantDetails[] value;
+    }
+
+    /// @notice Retrieve the Reports Variants from storage
+    /// @return The Reports Variants
+    function get() internal view returns (ReportVariantDetails[] storage) {
+        bytes32 slot = REPORT_VARIANTS_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        return r.value;
+    }
+
+    /// @notice Set the Reports Variants value at index
+    /// @param _idx The index to set
+    /// @param _val The value to set
+    function set(uint256 _idx, ReportVariantDetails memory _val) internal {
+        bytes32 slot = REPORT_VARIANTS_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        r.value[_idx] = _val;
+    }
+
+    /// @notice Add a new variant in the list
+    /// @param _variant The new variant to add
+    function push(ReportVariantDetails memory _variant) internal {
+        bytes32 slot = REPORT_VARIANTS_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        r.value.push(_variant);
+    }
+
+    /// @notice Retrieve the index of a specific variant, ignoring the count field
+    /// @param _variant Variant value to lookup
+    /// @return The index of the variant, -1 if not found
+    function indexOfReport(bytes32 _variant) internal view returns (int256) {
+        bytes32 slot = REPORT_VARIANTS_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        for (uint256 idx = 0; idx < r.value.length;) {
+            if (r.value[idx].variant == _variant) {
+                return int256(idx);
+            }
+            unchecked {
+                ++idx;
+            }
+        }
+
+        return int256(-1);
+    }
+
+    /// @notice Clear all variants from storage
+    function clear() internal {
+        bytes32 slot = REPORT_VARIANTS_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        delete r.value;
+    }
+}
diff -ruN src/contracts/src/state/redeemManager/BufferedExceedingEth.sol contracts/src/state/redeemManager/BufferedExceedingEth.sol
--- src/contracts/src/state/redeemManager/BufferedExceedingEth.sol	1970-01-01 01:00:00
+++ contracts/src/state/redeemManager/BufferedExceedingEth.sol	2024-01-16 15:06:39
@@ -0,0 +1,24 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+
+/// @title Buffered Exceeding Eth storage
+/// @notice Redeen Manager utility to manage the exceeding ETH with a redeem request
+library BufferedExceedingEth {
+    /// @notice Storage slot of the Redeem Buffered Eth
+    bytes32 internal constant BUFFERED_EXCEEDING_ETH_SLOT =
+        bytes32(uint256(keccak256("river.state.bufferedExceedingEth")) - 1);
+
+    /// @notice Retrieve the Redeem Buffered Eth Value
+    /// @return The Redeem Buffered Eth Value
+    function get() internal view returns (uint256) {
+        return LibUnstructuredStorage.getStorageUint256(BUFFERED_EXCEEDING_ETH_SLOT);
+    }
+
+    /// @notice Sets the Redeem Buffered Eth Value
+    /// @param newValue The new value
+    function set(uint256 newValue) internal {
+        LibUnstructuredStorage.setStorageUint256(BUFFERED_EXCEEDING_ETH_SLOT, newValue);
+    }
+}
diff -ruN src/contracts/src/state/redeemManager/RedeemDemand.sol contracts/src/state/redeemManager/RedeemDemand.sol
--- src/contracts/src/state/redeemManager/RedeemDemand.sol	1970-01-01 01:00:00
+++ contracts/src/state/redeemManager/RedeemDemand.sol	2024-01-16 15:06:39
@@ -0,0 +1,23 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+
+/// @title Redeem Demand storage
+/// @notice Redeem Manager utility to store the current demand in LsETH
+library RedeemDemand {
+    /// @notice Storage slot of the Redeem Demand
+    bytes32 internal constant REDEEM_DEMAND_SLOT = bytes32(uint256(keccak256("river.state.redeemDemand")) - 1);
+
+    /// @notice Retrieve the Redeem Demand Value
+    /// @return The Redeem Demand Value
+    function get() internal view returns (uint256) {
+        return LibUnstructuredStorage.getStorageUint256(REDEEM_DEMAND_SLOT);
+    }
+
+    /// @notice Sets the Redeem Demand Value
+    /// @param newValue The new value
+    function set(uint256 newValue) internal {
+        LibUnstructuredStorage.setStorageUint256(REDEEM_DEMAND_SLOT, newValue);
+    }
+}
diff -ruN src/contracts/src/state/redeemManager/RedeemQueue.sol contracts/src/state/redeemManager/RedeemQueue.sol
--- src/contracts/src/state/redeemManager/RedeemQueue.sol	1970-01-01 01:00:00
+++ contracts/src/state/redeemManager/RedeemQueue.sol	2024-01-16 15:06:39
@@ -0,0 +1,30 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Redeem Manager Redeem Queue storage
+/// @notice Utility to manage the Redeem Queue in the Redeem Manager
+library RedeemQueue {
+    /// @notice Storage slot of the Redeem Queue
+    bytes32 internal constant REDEEM_QUEUE_ID_SLOT = bytes32(uint256(keccak256("river.state.redeemQueue")) - 1);
+
+    /// @notice The Redeemer structure represents the redeem request made by a user
+    struct RedeemRequest {
+        /// @custom:attribute The amount of the redeem request in LsETH
+        uint256 amount;
+        /// @custom:attribute The maximum amount of ETH redeemable by this request
+        uint256 maxRedeemableEth;
+        /// @custom:attribute The owner of the redeem request
+        address owner;
+        /// @custom:attribute The height is the cumulative sum of all the sizes of preceding redeem requests
+        uint256 height;
+    }
+
+    /// @notice Retrieve the Redeem Queue array storage pointer
+    /// @return data The Redeem Queue array storage pointer
+    function get() internal pure returns (RedeemRequest[] storage data) {
+        bytes32 position = REDEEM_QUEUE_ID_SLOT;
+        assembly {
+            data.slot := position
+        }
+    }
+}
diff -ruN src/contracts/src/state/redeemManager/WithdrawalStack.sol contracts/src/state/redeemManager/WithdrawalStack.sol
--- src/contracts/src/state/redeemManager/WithdrawalStack.sol	1970-01-01 01:00:00
+++ contracts/src/state/redeemManager/WithdrawalStack.sol	2024-01-16 15:06:39
@@ -0,0 +1,28 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Redeem Manager Withdrawal Stack storage
+/// @notice Utility to manage the Withdrawal Stack in the Redeem Manager
+library WithdrawalStack {
+    /// @notice Storage slot of the Withdrawal Stack
+    bytes32 internal constant WITHDRAWAL_STACK_ID_SLOT = bytes32(uint256(keccak256("river.state.withdrawalStack")) - 1);
+
+    /// @notice The Redeemer structure represents the withdrawal events made by River
+    struct WithdrawalEvent {
+        /// @custom:attribute The amount of the withdrawal event in LsETH
+        uint256 amount;
+        /// @custom:attribute The amount of the withdrawal event in ETH
+        uint256 withdrawnEth;
+        /// @custom:attribute The height is the cumulative sum of all the sizes of preceding withdrawal events
+        uint256 height;
+    }
+
+    /// @notice Retrieve the Withdrawal Stack array storage pointer
+    /// @return data The Withdrawal Stack array storage pointer
+    function get() internal pure returns (WithdrawalEvent[] storage data) {
+        bytes32 position = WITHDRAWAL_STACK_ID_SLOT;
+        assembly {
+            data.slot := position
+        }
+    }
+}
diff -ruN src/contracts/src/state/river/AllowlistAddress.sol contracts/src/state/river/AllowlistAddress.sol
--- src/contracts/src/state/river/AllowlistAddress.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/AllowlistAddress.sol	2024-01-16 15:06:39
@@ -0,0 +1,25 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+import "../../libraries/LibSanitize.sol";
+
+/// @title Allowlist Address Storage
+/// @notice Utility to manage the Allowlist Address in storage
+library AllowlistAddress {
+    /// @notice Storage slot of the Allowlist Address
+    bytes32 internal constant ALLOWLIST_ADDRESS_SLOT = bytes32(uint256(keccak256("river.state.allowlistAddress")) - 1);
+
+    /// @notice Retrieve the Allowlist Address
+    /// @return The Allowlist Address
+    function get() internal view returns (address) {
+        return LibUnstructuredStorage.getStorageAddress(ALLOWLIST_ADDRESS_SLOT);
+    }
+
+    /// @notice Sets the Allowlist Address
+    /// @param _newValue New Allowlist Address
+    function set(address _newValue) internal {
+        LibSanitize._notZeroAddress(_newValue);
+        LibUnstructuredStorage.setStorageAddress(ALLOWLIST_ADDRESS_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/river/BalanceToDeposit.sol contracts/src/state/river/BalanceToDeposit.sol
--- src/contracts/src/state/river/BalanceToDeposit.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/BalanceToDeposit.sol	2024-01-16 15:06:39
@@ -0,0 +1,16 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+
+library BalanceToDeposit {
+    bytes32 internal constant BALANCE_TO_DEPOSIT_SLOT = bytes32(uint256(keccak256("river.state.balanceToDeposit")) - 1);
+
+    function get() internal view returns (uint256) {
+        return LibUnstructuredStorage.getStorageUint256(BALANCE_TO_DEPOSIT_SLOT);
+    }
+
+    function set(uint256 newValue) internal {
+        LibUnstructuredStorage.setStorageUint256(BALANCE_TO_DEPOSIT_SLOT, newValue);
+    }
+}
diff -ruN src/contracts/src/state/river/BalanceToRedeem.sol contracts/src/state/river/BalanceToRedeem.sol
--- src/contracts/src/state/river/BalanceToRedeem.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/BalanceToRedeem.sol	2024-01-16 15:06:39
@@ -0,0 +1,16 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+
+library BalanceToRedeem {
+    bytes32 internal constant BALANCE_TO_REDEEM_SLOT = bytes32(uint256(keccak256("river.state.balanceToRedeem")) - 1);
+
+    function get() internal view returns (uint256) {
+        return LibUnstructuredStorage.getStorageUint256(BALANCE_TO_REDEEM_SLOT);
+    }
+
+    function set(uint256 newValue) internal {
+        LibUnstructuredStorage.setStorageUint256(BALANCE_TO_REDEEM_SLOT, newValue);
+    }
+}
diff -ruN src/contracts/src/state/river/CLSpec.sol contracts/src/state/river/CLSpec.sol
--- src/contracts/src/state/river/CLSpec.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/CLSpec.sol	2024-01-16 15:06:39
@@ -0,0 +1,59 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Consensus Layer Spec Storage
+/// @notice Utility to manage the Consensus Layer Spec in storage
+library CLSpec {
+    /// @notice Storage slot of the Consensus Layer Spec
+    bytes32 internal constant CL_SPEC_SLOT = bytes32(uint256(keccak256("river.state.clSpec")) - 1);
+
+    /// @notice The Consensus Layer Spec structure
+    struct CLSpecStruct {
+        /// @custom:attribute The count of epochs per frame, 225 means 24h
+        uint64 epochsPerFrame;
+        /// @custom:attribute The count of slots in an epoch (32 on mainnet)
+        uint64 slotsPerEpoch;
+        /// @custom:attribute The seconds in a slot (12 on mainnet)
+        uint64 secondsPerSlot;
+        /// @custom:attribute The block timestamp of the first consensus layer block
+        uint64 genesisTime;
+        /// @custom:attribute The count of epochs before considering an epoch final on-chain
+        uint64 epochsToAssumedFinality;
+    }
+
+    /// @notice The structure in storage
+    struct Slot {
+        /// @custom:attribute The structure in storage
+        CLSpecStruct value;
+    }
+
+    /// @notice Retrieve the Consensus Layer Spec from storage
+    /// @return The Consensus Layer Spec
+    function get() internal view returns (CLSpecStruct memory) {
+        bytes32 slot = CL_SPEC_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        return r.value;
+    }
+
+    /// @notice Set the Consensus Layer Spec value in storage
+    /// @param _newCLSpec The new value to set in storage
+    function set(CLSpecStruct memory _newCLSpec) internal {
+        bytes32 slot = CL_SPEC_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        r.value = _newCLSpec;
+    }
+}
diff -ruN src/contracts/src/state/river/CLValidatorCount.sol contracts/src/state/river/CLValidatorCount.sol
--- src/contracts/src/state/river/CLValidatorCount.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/CLValidatorCount.sol	2024-01-16 15:06:39
@@ -0,0 +1,24 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+
+/// @title Consensus Layer Validator Count Storage
+/// @notice Utility to manage the Consensus Layer Validator Count in storage
+/// @notice This state variable is deprecated and was kept due to migration logic needs
+library CLValidatorCount {
+    /// @notice Storage slot of the Consensus Layer Validator Count
+    bytes32 internal constant CL_VALIDATOR_COUNT_SLOT = bytes32(uint256(keccak256("river.state.clValidatorCount")) - 1);
+
+    /// @notice Retrieve the Consensus Layer Validator Count
+    /// @return The Consensus Layer Validator Count
+    function get() internal view returns (uint256) {
+        return LibUnstructuredStorage.getStorageUint256(CL_VALIDATOR_COUNT_SLOT);
+    }
+
+    /// @notice Sets the Consensus Layer Validator Count
+    /// @param _newValue New Consensus Layer Validator Count
+    function set(uint256 _newValue) internal {
+        LibUnstructuredStorage.setStorageUint256(CL_VALIDATOR_COUNT_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/river/CLValidatorTotalBalance.sol contracts/src/state/river/CLValidatorTotalBalance.sol
--- src/contracts/src/state/river/CLValidatorTotalBalance.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/CLValidatorTotalBalance.sol	2024-01-16 15:06:39
@@ -0,0 +1,25 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+
+/// @title Consensus Layer Validator Total Balance Storage
+/// @notice Utility to manage the Consensus Layer Validator Total Balance in storage
+/// @notice This state variable is deprecated and was kept due to migration logic needs
+library CLValidatorTotalBalance {
+    /// @notice Storage slot of the Consensus Layer Validator Total Balance
+    bytes32 internal constant CL_VALIDATOR_TOTAL_BALANCE_SLOT =
+        bytes32(uint256(keccak256("river.state.clValidatorTotalBalance")) - 1);
+
+    /// @notice Retrieve the Consensus Layer Validator Total Balance
+    /// @return The Consensus Layer Validator Total Balance
+    function get() internal view returns (uint256) {
+        return LibUnstructuredStorage.getStorageUint256(CL_VALIDATOR_TOTAL_BALANCE_SLOT);
+    }
+
+    /// @notice Sets the Consensus Layer Validator Total Balance
+    /// @param _newValue New Consensus Layer Validator Total Balance
+    function set(uint256 _newValue) internal {
+        LibUnstructuredStorage.setStorageUint256(CL_VALIDATOR_TOTAL_BALANCE_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/river/CollectorAddress.sol contracts/src/state/river/CollectorAddress.sol
--- src/contracts/src/state/river/CollectorAddress.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/CollectorAddress.sol	2024-01-16 15:06:39
@@ -0,0 +1,25 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+import "../../libraries/LibSanitize.sol";
+
+/// @title Collector Address Storage
+/// @notice Utility to manage the Collector Address in storage
+library CollectorAddress {
+    /// @notice Storage slot of the Collector Address
+    bytes32 internal constant COLLECTOR_ADDRESS_SLOT = bytes32(uint256(keccak256("river.state.collectorAddress")) - 1);
+
+    /// @notice Retrieve the Collector Address
+    /// @return The Collector Address
+    function get() internal view returns (address) {
+        return LibUnstructuredStorage.getStorageAddress(COLLECTOR_ADDRESS_SLOT);
+    }
+
+    /// @notice Sets the Collector Address
+    /// @param _newValue New Collector Address
+    function set(address _newValue) internal {
+        LibSanitize._notZeroAddress(_newValue);
+        LibUnstructuredStorage.setStorageAddress(COLLECTOR_ADDRESS_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/river/CommittedBalance.sol contracts/src/state/river/CommittedBalance.sol
--- src/contracts/src/state/river/CommittedBalance.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/CommittedBalance.sol	2024-01-16 15:06:39
@@ -0,0 +1,16 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+
+library CommittedBalance {
+    bytes32 internal constant COMMITTED_BALANCE_SLOT = bytes32(uint256(keccak256("river.state.committedBalance")) - 1);
+
+    function get() internal view returns (uint256) {
+        return LibUnstructuredStorage.getStorageUint256(COMMITTED_BALANCE_SLOT);
+    }
+
+    function set(uint256 newValue) internal {
+        LibUnstructuredStorage.setStorageUint256(COMMITTED_BALANCE_SLOT, newValue);
+    }
+}
diff -ruN src/contracts/src/state/river/CoverageFundAddress.sol contracts/src/state/river/CoverageFundAddress.sol
--- src/contracts/src/state/river/CoverageFundAddress.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/CoverageFundAddress.sol	2024-01-16 15:06:39
@@ -0,0 +1,26 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+import "../../libraries/LibSanitize.sol";
+
+/// @title Coverage Fund Address Storage
+/// @notice Utility to manage the Coverage Fund Address in storage
+library CoverageFundAddress {
+    /// @notice Storage slot of the Coverage Fund Address
+    bytes32 internal constant COVERAGE_FUND_ADDRESS_SLOT =
+        bytes32(uint256(keccak256("river.state.coverageFundAddress")) - 1);
+
+    /// @notice Retrieve the Coverage Fund Address
+    /// @return The Coverage Fund Address
+    function get() internal view returns (address) {
+        return LibUnstructuredStorage.getStorageAddress(COVERAGE_FUND_ADDRESS_SLOT);
+    }
+
+    /// @notice Sets the Coverage Fund Address
+    /// @param _newValue New Coverage Fund Address
+    function set(address _newValue) internal {
+        LibSanitize._notZeroAddress(_newValue);
+        LibUnstructuredStorage.setStorageAddress(COVERAGE_FUND_ADDRESS_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/river/DailyCommittableLimits.sol contracts/src/state/river/DailyCommittableLimits.sol
--- src/contracts/src/state/river/DailyCommittableLimits.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/DailyCommittableLimits.sol	2024-01-16 15:06:39
@@ -0,0 +1,54 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibSanitize.sol";
+
+/// @title Daily Committable Limits storage
+/// @notice Utility to manage the Daily Committable Limits in storage
+library DailyCommittableLimits {
+    /// @notice Storage slot of the Daily Committable Limits storage
+    bytes32 internal constant DAILY_COMMITTABLE_LIMITS_SLOT =
+        bytes32(uint256(keccak256("river.state.dailyCommittableLimits")) - 1);
+
+    /// @notice The daily committable limits structure
+    struct DailyCommittableLimitsStruct {
+        uint128 minDailyNetCommittableAmount;
+        uint128 maxDailyRelativeCommittableAmount;
+    }
+
+    /// @notice The structure in storage
+    struct Slot {
+        /// @custom:attribute The structure in storage
+        DailyCommittableLimitsStruct value;
+    }
+
+    /// @notice Retrieve the Daily Committable Limits from storage
+    /// @return The Daily Committable Limits
+    function get() internal view returns (DailyCommittableLimitsStruct memory) {
+        bytes32 slot = DAILY_COMMITTABLE_LIMITS_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        return r.value;
+    }
+
+    /// @notice Set the Daily Committable Limits value in storage
+    /// @param _newValue The new value to set in storage
+    function set(DailyCommittableLimitsStruct memory _newValue) internal {
+        bytes32 slot = DAILY_COMMITTABLE_LIMITS_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        r.value = _newValue;
+    }
+}
diff -ruN src/contracts/src/state/river/DepositContractAddress.sol contracts/src/state/river/DepositContractAddress.sol
--- src/contracts/src/state/river/DepositContractAddress.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/DepositContractAddress.sol	2024-01-16 15:06:39
@@ -0,0 +1,26 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibSanitize.sol";
+import "../../libraries/LibUnstructuredStorage.sol";
+
+/// @title Deposit Contract Address Storage
+/// @notice Utility to manage the Deposit Contract Address in storage
+library DepositContractAddress {
+    /// @notice Storage slot of the Deposit Contract Address
+    bytes32 internal constant DEPOSIT_CONTRACT_ADDRESS_SLOT =
+        bytes32(uint256(keccak256("river.state.depositContractAddress")) - 1);
+
+    /// @notice Retrieve the Deposit Contract Address
+    /// @return The Deposit Contract Address
+    function get() internal view returns (address) {
+        return LibUnstructuredStorage.getStorageAddress(DEPOSIT_CONTRACT_ADDRESS_SLOT);
+    }
+
+    /// @notice Sets the Deposit Contract Address
+    /// @param _newValue New Deposit Contract Address
+    function set(address _newValue) internal {
+        LibSanitize._notZeroAddress(_newValue);
+        LibUnstructuredStorage.setStorageAddress(DEPOSIT_CONTRACT_ADDRESS_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/river/DepositedValidatorCount.sol contracts/src/state/river/DepositedValidatorCount.sol
--- src/contracts/src/state/river/DepositedValidatorCount.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/DepositedValidatorCount.sol	2024-01-16 15:06:39
@@ -0,0 +1,24 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+
+/// @title Deposited Validator Count Storage
+/// @notice Utility to manage the Deposited Validator Count in storage
+library DepositedValidatorCount {
+    /// @notice Storage slot of the Deposited Validator Count
+    bytes32 internal constant DEPOSITED_VALIDATOR_COUNT_SLOT =
+        bytes32(uint256(keccak256("river.state.depositedValidatorCount")) - 1);
+
+    /// @notice Retrieve the Deposited Validator Count
+    /// @return The Deposited Validator Count
+    function get() internal view returns (uint256) {
+        return LibUnstructuredStorage.getStorageUint256(DEPOSITED_VALIDATOR_COUNT_SLOT);
+    }
+
+    /// @notice Sets the Deposited Validator Count
+    /// @param _newValue New Deposited Validator Count
+    function set(uint256 _newValue) internal {
+        LibUnstructuredStorage.setStorageUint256(DEPOSITED_VALIDATOR_COUNT_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/river/ELFeeRecipientAddress.sol contracts/src/state/river/ELFeeRecipientAddress.sol
--- src/contracts/src/state/river/ELFeeRecipientAddress.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/ELFeeRecipientAddress.sol	2024-01-16 15:06:39
@@ -0,0 +1,26 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+import "../../libraries/LibSanitize.sol";
+
+/// @title Execution Layer Fee Recipient Address Storage
+/// @notice Utility to manage the Execution Layer Fee Recipient Address in storage
+library ELFeeRecipientAddress {
+    /// @notice Storage slot of the Execution Layer Fee Recipient Address
+    bytes32 internal constant EL_FEE_RECIPIENT_ADDRESS =
+        bytes32(uint256(keccak256("river.state.elFeeRecipientAddress")) - 1);
+
+    /// @notice Retrieve the Execution Layer Fee Recipient Address
+    /// @return The Execution Layer Fee Recipient Address
+    function get() internal view returns (address) {
+        return LibUnstructuredStorage.getStorageAddress(EL_FEE_RECIPIENT_ADDRESS);
+    }
+
+    /// @notice Sets the Execution Layer Fee Recipient Address
+    /// @param _newValue New Execution Layer Fee Recipient Address
+    function set(address _newValue) internal {
+        LibSanitize._notZeroAddress(_newValue);
+        LibUnstructuredStorage.setStorageAddress(EL_FEE_RECIPIENT_ADDRESS, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/river/GlobalFee.sol contracts/src/state/river/GlobalFee.sol
--- src/contracts/src/state/river/GlobalFee.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/GlobalFee.sol	2024-01-16 15:06:39
@@ -0,0 +1,25 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibSanitize.sol";
+import "../../libraries/LibUnstructuredStorage.sol";
+
+/// @title Global Fee Storage
+/// @notice Utility to manage the Global Fee in storage
+library GlobalFee {
+    /// @notice Storage slot of the Global Fee
+    bytes32 internal constant GLOBAL_FEE_SLOT = bytes32(uint256(keccak256("river.state.globalFee")) - 1);
+
+    /// @notice Retrieve the Global Fee
+    /// @return The Global Fee
+    function get() internal view returns (uint256) {
+        return LibUnstructuredStorage.getStorageUint256(GLOBAL_FEE_SLOT);
+    }
+
+    /// @notice Sets the Global Fee
+    /// @param _newValue New Global Fee
+    function set(uint256 _newValue) internal {
+        LibSanitize._validFee(_newValue);
+        LibUnstructuredStorage.setStorageUint256(GLOBAL_FEE_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/river/LastConsensusLayerReport.sol contracts/src/state/river/LastConsensusLayerReport.sol
--- src/contracts/src/state/river/LastConsensusLayerReport.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/LastConsensusLayerReport.sol	2024-01-16 15:06:39
@@ -0,0 +1,48 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../interfaces/components/IOracleManager.1.sol";
+
+/// @title Last Consensus Layer Report Storage
+/// @notice Utility to manage the Last Consensus Layer Report in storage
+library LastConsensusLayerReport {
+    /// @notice Storage slot of the Last Consensus Layer Report
+    bytes32 internal constant LAST_CONSENSUS_LAYER_REPORT_SLOT =
+        bytes32(uint256(keccak256("river.state.lastConsensusLayerReport")) - 1);
+
+    /// @notice The structure in storage
+    struct Slot {
+        /// @custom:attribute The structure in storage
+        IOracleManagerV1.StoredConsensusLayerReport value;
+    }
+
+    /// @notice Retrieve the Last Consensus Layer Report from storage
+    /// @return The Last Consensus Layer Report
+    function get() internal view returns (IOracleManagerV1.StoredConsensusLayerReport storage) {
+        bytes32 slot = LAST_CONSENSUS_LAYER_REPORT_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        return r.value;
+    }
+
+    /// @notice Set the Last Consensus Layer Report value in storage
+    /// @param _newValue The new value to set in storage
+    function set(IOracleManagerV1.StoredConsensusLayerReport memory _newValue) internal {
+        bytes32 slot = LAST_CONSENSUS_LAYER_REPORT_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        r.value = _newValue;
+    }
+}
diff -ruN src/contracts/src/state/river/LastOracleRoundId.sol contracts/src/state/river/LastOracleRoundId.sol
--- src/contracts/src/state/river/LastOracleRoundId.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/LastOracleRoundId.sol	2024-01-16 15:06:39
@@ -0,0 +1,25 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+
+/// @title Last Oracle Round Id Storage
+/// @notice Utility to manage the Last Oracle Round Id in storage
+/// @notice This state variable is deprecated and was kept due to migration logic needs
+library LastOracleRoundId {
+    /// @notice Storage slot of the Last Oracle Round Id
+    bytes32 internal constant LAST_ORACLE_ROUND_ID_SLOT =
+        bytes32(uint256(keccak256("river.state.lastOracleRoundId")) - 1);
+
+    /// @notice Retrieve the Last Oracle Round Id
+    /// @return The Last Oracle Round Id
+    function get() internal view returns (bytes32) {
+        return LibUnstructuredStorage.getStorageBytes32(LAST_ORACLE_ROUND_ID_SLOT);
+    }
+
+    /// @notice Sets the Last Oracle Round Id
+    /// @param _newValue New Last Oracle Round Id
+    function set(bytes32 _newValue) internal {
+        LibUnstructuredStorage.setStorageBytes32(LAST_ORACLE_ROUND_ID_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/river/MetadataURI.sol contracts/src/state/river/MetadataURI.sol
--- src/contracts/src/state/river/MetadataURI.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/MetadataURI.sol	2024-01-16 15:06:39
@@ -0,0 +1,45 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Metadata URI Storage
+/// @notice Utility to manage the Metadata in storage
+library MetadataURI {
+    /// @notice Storage slot of the Metadata URI
+    bytes32 internal constant METADATA_URI_SLOT = bytes32(uint256(keccak256("river.state.metadataUri")) - 1);
+
+    /// @notice Structure in storage
+    struct Slot {
+        /// @custom:attribute The metadata value
+        string value;
+    }
+
+    /// @notice Retrieve the metadata URI
+    /// @return The metadata URI string
+    function get() internal view returns (string memory) {
+        bytes32 slot = METADATA_URI_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        return r.value;
+    }
+
+    /// @notice Set the metadata URI value
+    /// @param _newValue The new metadata URI value
+    function set(string memory _newValue) internal {
+        bytes32 slot = METADATA_URI_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        r.value = _newValue;
+    }
+}
diff -ruN src/contracts/src/state/river/OperatorsRegistryAddress.sol contracts/src/state/river/OperatorsRegistryAddress.sol
--- src/contracts/src/state/river/OperatorsRegistryAddress.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/OperatorsRegistryAddress.sol	2024-01-16 15:06:39
@@ -0,0 +1,26 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+import "../../libraries/LibSanitize.sol";
+
+/// @title Operators Registry Address Storage
+/// @notice Utility to manage the Operators Registry Address in storage
+library OperatorsRegistryAddress {
+    /// @notice Storage slot of the Operators Registry Address
+    bytes32 internal constant OPERATORS_REGISTRY_ADDRESS_SLOT =
+        bytes32(uint256(keccak256("river.state.operatorsRegistryAddress")) - 1);
+
+    /// @notice Retrieve the Operators Registry Address
+    /// @return The Operators Registry Address
+    function get() internal view returns (address) {
+        return LibUnstructuredStorage.getStorageAddress(OPERATORS_REGISTRY_ADDRESS_SLOT);
+    }
+
+    /// @notice Sets the Operators Registry Address
+    /// @param _newValue New Operators Registry Address
+    function set(address _newValue) internal {
+        LibSanitize._notZeroAddress(_newValue);
+        LibUnstructuredStorage.setStorageAddress(OPERATORS_REGISTRY_ADDRESS_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/river/OracleAddress.sol contracts/src/state/river/OracleAddress.sol
--- src/contracts/src/state/river/OracleAddress.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/OracleAddress.sol	2024-01-16 15:06:39
@@ -0,0 +1,25 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+import "../../libraries/LibSanitize.sol";
+
+/// @title Oracle Address Storage
+/// @notice Utility to manage the Oracle Address in storage
+library OracleAddress {
+    /// @notice Storage slot of the Oracle Address
+    bytes32 internal constant ORACLE_ADDRESS_SLOT = bytes32(uint256(keccak256("river.state.oracleAddress")) - 1);
+
+    /// @notice Retrieve the Oracle Address
+    /// @return The Oracle Address
+    function get() internal view returns (address) {
+        return LibUnstructuredStorage.getStorageAddress(ORACLE_ADDRESS_SLOT);
+    }
+
+    /// @notice Sets the Oracle Address
+    /// @param _newValue New Oracle Address
+    function set(address _newValue) internal {
+        LibSanitize._notZeroAddress(_newValue);
+        LibUnstructuredStorage.setStorageAddress(ORACLE_ADDRESS_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/river/RedeemManagerAddress.sol contracts/src/state/river/RedeemManagerAddress.sol
--- src/contracts/src/state/river/RedeemManagerAddress.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/RedeemManagerAddress.sol	2024-01-16 15:06:39
@@ -0,0 +1,26 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+import "../../libraries/LibSanitize.sol";
+
+/// @title Redeem Manager Address Storage
+/// @notice Utility to manage the Redeem Manager Address in storage
+library RedeemManagerAddress {
+    /// @notice Storage slot of the Redeem Manager Address
+    bytes32 internal constant REDEEM_MANAGER_ADDRESS_SLOT =
+        bytes32(uint256(keccak256("river.state.redeemManagerAddress")) - 1);
+
+    /// @notice Retrieve the Redeem Manager Address
+    /// @return The Redeem Manager Address
+    function get() internal view returns (address) {
+        return LibUnstructuredStorage.getStorageAddress(REDEEM_MANAGER_ADDRESS_SLOT);
+    }
+
+    /// @notice Sets the Redeem Manager Address
+    /// @param _newValue New Redeem Manager Address
+    function set(address _newValue) internal {
+        LibSanitize._notZeroAddress(_newValue);
+        LibUnstructuredStorage.setStorageAddress(REDEEM_MANAGER_ADDRESS_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/river/ReportBounds.sol contracts/src/state/river/ReportBounds.sol
--- src/contracts/src/state/river/ReportBounds.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/ReportBounds.sol	2024-01-16 15:06:39
@@ -0,0 +1,53 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Report Bounds Storage
+/// @notice Utility to manage the Report Bounds in storage
+library ReportBounds {
+    /// @notice Storage slot of the Report Bounds
+    bytes32 internal constant REPORT_BOUNDS_SLOT = bytes32(uint256(keccak256("river.state.reportBounds")) - 1);
+
+    /// @notice The Report Bounds structure
+    struct ReportBoundsStruct {
+        /// @custom:attribute The maximum allowed annual apr, checked before submitting a report to River
+        uint256 annualAprUpperBound;
+        /// @custom:attribute The maximum allowed balance decrease, also checked before submitting a report to River
+        uint256 relativeLowerBound;
+    }
+
+    /// @notice The structure in storage
+    struct Slot {
+        /// @custom:attribute The structure in storage
+        ReportBoundsStruct value;
+    }
+
+    /// @notice Retrieve the Report Bounds from storage
+    /// @return The Report Bounds
+    function get() internal view returns (ReportBoundsStruct memory) {
+        bytes32 slot = REPORT_BOUNDS_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        return r.value;
+    }
+
+    /// @notice Set the Report Bounds in storage
+    /// @param _newReportBounds The new Report Bounds value
+    function set(ReportBoundsStruct memory _newReportBounds) internal {
+        bytes32 slot = REPORT_BOUNDS_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        r.value = _newReportBounds;
+    }
+}
diff -ruN src/contracts/src/state/river/Shares.sol contracts/src/state/river/Shares.sol
--- src/contracts/src/state/river/Shares.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/Shares.sol	2024-01-16 15:06:39
@@ -0,0 +1,23 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+
+/// @title Shares Count Storage
+/// @notice Utility to manage the Shares Count in storage
+library Shares {
+    /// @notice Storage slot of the Shares Count
+    bytes32 internal constant SHARES_SLOT = bytes32(uint256(keccak256("river.state.shares")) - 1);
+
+    /// @notice Retrieve the Shares Count
+    /// @return The Shares Count
+    function get() internal view returns (uint256) {
+        return LibUnstructuredStorage.getStorageUint256(SHARES_SLOT);
+    }
+
+    /// @notice Sets the Shares Count
+    /// @param _newValue New Shares Count
+    function set(uint256 _newValue) internal {
+        LibUnstructuredStorage.setStorageUint256(SHARES_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/river/SharesPerOwner.sol contracts/src/state/river/SharesPerOwner.sol
--- src/contracts/src/state/river/SharesPerOwner.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/SharesPerOwner.sol	2024-01-16 15:06:39
@@ -0,0 +1,47 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Shares Per Owner Storage
+/// @notice Utility to manage the Shares Per Owner in storage
+library SharesPerOwner {
+    /// @notice Storage slot of the Shares Per Owner
+    bytes32 internal constant SHARES_PER_OWNER_SLOT = bytes32(uint256(keccak256("river.state.sharesPerOwner")) - 1);
+
+    /// @notice Structure in storage
+    struct Slot {
+        /// @custom:attribute The mapping from an owner to its share count
+        mapping(address => uint256) value;
+    }
+
+    /// @notice Retrieve the share count for given owner
+    /// @param _owner The address to get the balance of
+    /// @return The amount of shares
+    function get(address _owner) internal view returns (uint256) {
+        bytes32 slot = SHARES_PER_OWNER_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        return r.value[_owner];
+    }
+
+    /// @notice Set the amount of shares for an owner
+    /// @param _owner The owner of the shares to edit
+    /// @param _newValue The new shares value for the owner
+    function set(address _owner, uint256 _newValue) internal {
+        bytes32 slot = SHARES_PER_OWNER_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        r.value[_owner] = _newValue;
+    }
+}
diff -ruN src/contracts/src/state/river/WithdrawalCredentials.sol contracts/src/state/river/WithdrawalCredentials.sol
--- src/contracts/src/state/river/WithdrawalCredentials.sol	1970-01-01 01:00:00
+++ contracts/src/state/river/WithdrawalCredentials.sol	2024-01-16 15:06:39
@@ -0,0 +1,34 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibErrors.sol";
+import "../../libraries/LibUnstructuredStorage.sol";
+
+/// @title Withdrawal Credentials Storage
+/// @notice Utility to manage the Withdrawal Credentials in storage
+library WithdrawalCredentials {
+    /// @notice Storage slot of the Withdrawal Credentials
+    bytes32 internal constant WITHDRAWAL_CREDENTIALS_SLOT =
+        bytes32(uint256(keccak256("river.state.withdrawalCredentials")) - 1);
+
+    /// @notice Retrieve the Withdrawal Credentials
+    /// @return The Withdrawal Credentials
+    function get() internal view returns (bytes32) {
+        return LibUnstructuredStorage.getStorageBytes32(WITHDRAWAL_CREDENTIALS_SLOT);
+    }
+
+    /// @notice Retrieve the Withdrawal Credential under its address format
+    /// @return The Withdrawal Credentials in its address format
+    function getAddress() internal view returns (address) {
+        return LibUnstructuredStorage.getStorageAddress(WITHDRAWAL_CREDENTIALS_SLOT);
+    }
+
+    /// @notice Sets the Withdrawal Credentials
+    /// @param _newValue New Withdrawal Credentials
+    function set(bytes32 _newValue) internal {
+        if (_newValue == bytes32(0)) {
+            revert LibErrors.InvalidArgument();
+        }
+        LibUnstructuredStorage.setStorageBytes32(WITHDRAWAL_CREDENTIALS_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/shared/AdministratorAddress.sol contracts/src/state/shared/AdministratorAddress.sol
--- src/contracts/src/state/shared/AdministratorAddress.sol	1970-01-01 01:00:00
+++ contracts/src/state/shared/AdministratorAddress.sol	2024-01-16 15:06:39
@@ -0,0 +1,26 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+import "../../libraries/LibSanitize.sol";
+
+/// @title Administrator Address Storage
+/// @notice Utility to manage the Administrator Address in storage
+library AdministratorAddress {
+    /// @notice Storage slot of the Administrator Address
+    bytes32 public constant ADMINISTRATOR_ADDRESS_SLOT =
+        bytes32(uint256(keccak256("river.state.administratorAddress")) - 1);
+
+    /// @notice Retrieve the Administrator Address
+    /// @return The Administrator Address
+    function get() internal view returns (address) {
+        return LibUnstructuredStorage.getStorageAddress(ADMINISTRATOR_ADDRESS_SLOT);
+    }
+
+    /// @notice Sets the Administrator Address
+    /// @param _newValue New Administrator Address
+    function set(address _newValue) internal {
+        LibSanitize._notZeroAddress(_newValue);
+        LibUnstructuredStorage.setStorageAddress(ADMINISTRATOR_ADDRESS_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/shared/ApprovalsPerOwner.sol contracts/src/state/shared/ApprovalsPerOwner.sol
--- src/contracts/src/state/shared/ApprovalsPerOwner.sol	1970-01-01 01:00:00
+++ contracts/src/state/shared/ApprovalsPerOwner.sol	2024-01-16 15:06:39
@@ -0,0 +1,50 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Approvals Per Owner Storage
+/// @notice Utility to manage the Approvals Per Owner in storage
+library ApprovalsPerOwner {
+    /// @notice Storage slot of the Approvals Per Owner
+    bytes32 internal constant APPROVALS_PER_OWNER_SLOT =
+        bytes32(uint256(keccak256("river.state.approvalsPerOwner")) - 1);
+
+    /// @notice The structure in storage
+    struct Slot {
+        /// @custom:attribute The mapping from an owner to an operator to the approval amount
+        mapping(address => mapping(address => uint256)) value;
+    }
+
+    /// @notice Retrieve the approval for an owner to an operator
+    /// @param _owner The account that gave the approval
+    /// @param _operator The account receiving the approval
+    /// @return The value of the approval
+    function get(address _owner, address _operator) internal view returns (uint256) {
+        bytes32 slot = APPROVALS_PER_OWNER_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        return r.value[_owner][_operator];
+    }
+
+    /// @notice Set the approval value for an owner to an operator
+    /// @param _owner The account that gives the approval
+    /// @param _operator The account receiving the approval
+    /// @param _newValue The value of the approval
+    function set(address _owner, address _operator, uint256 _newValue) internal {
+        bytes32 slot = APPROVALS_PER_OWNER_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        r.value[_owner][_operator] = _newValue;
+    }
+}
diff -ruN src/contracts/src/state/shared/PendingAdministratorAddress.sol contracts/src/state/shared/PendingAdministratorAddress.sol
--- src/contracts/src/state/shared/PendingAdministratorAddress.sol	1970-01-01 01:00:00
+++ contracts/src/state/shared/PendingAdministratorAddress.sol	2024-01-16 15:06:39
@@ -0,0 +1,24 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+
+/// @title Pending Administrator Address Storage
+/// @notice Utility to manage the Pending Administrator Address in storage
+library PendingAdministratorAddress {
+    /// @notice Storage slot of the Pending Administrator Address
+    bytes32 public constant PENDING_ADMINISTRATOR_ADDRESS_SLOT =
+        bytes32(uint256(keccak256("river.state.pendingAdministratorAddress")) - 1);
+
+    /// @notice Retrieve the Pending Administrator Address
+    /// @return The Pending Administrator Address
+    function get() internal view returns (address) {
+        return LibUnstructuredStorage.getStorageAddress(PENDING_ADMINISTRATOR_ADDRESS_SLOT);
+    }
+
+    /// @notice Sets the Pending Administrator Address
+    /// @param _newValue New Pending Administrator Address
+    function set(address _newValue) internal {
+        LibUnstructuredStorage.setStorageAddress(PENDING_ADMINISTRATOR_ADDRESS_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/shared/RiverAddress.sol contracts/src/state/shared/RiverAddress.sol
--- src/contracts/src/state/shared/RiverAddress.sol	1970-01-01 01:00:00
+++ contracts/src/state/shared/RiverAddress.sol	2024-01-16 15:06:39
@@ -0,0 +1,25 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibSanitize.sol";
+import "../../libraries/LibUnstructuredStorage.sol";
+
+/// @title River Address Storage
+/// @notice Utility to manage the River Address in storage
+library RiverAddress {
+    /// @notice Storage slot of the River Address
+    bytes32 internal constant RIVER_ADDRESS_SLOT = bytes32(uint256(keccak256("river.state.riverAddress")) - 1);
+
+    /// @notice Retrieve the River Address
+    /// @return The River Address
+    function get() internal view returns (address) {
+        return LibUnstructuredStorage.getStorageAddress(RIVER_ADDRESS_SLOT);
+    }
+
+    /// @notice Sets the River Address
+    /// @param _newValue New River Address
+    function set(address _newValue) internal {
+        LibSanitize._notZeroAddress(_newValue);
+        LibUnstructuredStorage.setStorageAddress(RIVER_ADDRESS_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/shared/Version.sol contracts/src/state/shared/Version.sol
--- src/contracts/src/state/shared/Version.sol	1970-01-01 01:00:00
+++ contracts/src/state/shared/Version.sol	2024-01-16 15:06:39
@@ -0,0 +1,23 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+
+/// @title Version Storage
+/// @notice Utility to manage the Version in storage
+library Version {
+    /// @notice Storage slot of the Version
+    bytes32 public constant VERSION_SLOT = bytes32(uint256(keccak256("river.state.version")) - 1);
+
+    /// @notice Retrieve the Version
+    /// @return The Version
+    function get() internal view returns (uint256) {
+        return LibUnstructuredStorage.getStorageUint256(VERSION_SLOT);
+    }
+
+    /// @notice Sets the Version
+    /// @param _newValue New Version
+    function set(uint256 _newValue) internal {
+        LibUnstructuredStorage.setStorageUint256(VERSION_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/slashingCoverage/BalanceForCoverage.sol contracts/src/state/slashingCoverage/BalanceForCoverage.sol
--- src/contracts/src/state/slashingCoverage/BalanceForCoverage.sol	1970-01-01 01:00:00
+++ contracts/src/state/slashingCoverage/BalanceForCoverage.sol	2024-01-16 15:06:39
@@ -0,0 +1,24 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "../../libraries/LibUnstructuredStorage.sol";
+
+/// @title Balance For Coverage Value Storage
+/// @notice Utility to manage the Balance For Coverrage value in storage
+library BalanceForCoverage {
+    /// @notice Storage slot of the Balance For Coverage Address
+    bytes32 internal constant BALANCE_FOR_COVERAGE_SLOT =
+        bytes32(uint256(keccak256("river.state.balanceForCoverage")) - 1);
+
+    /// @notice Get the Balance for Coverage value
+    /// @return The balance for coverage value
+    function get() internal view returns (uint256) {
+        return LibUnstructuredStorage.getStorageUint256(BALANCE_FOR_COVERAGE_SLOT);
+    }
+
+    /// @notice Sets the Balance for Coverage value
+    /// @param _newValue New Balance for Coverage value
+    function set(uint256 _newValue) internal {
+        LibUnstructuredStorage.setStorageUint256(BALANCE_FOR_COVERAGE_SLOT, _newValue);
+    }
+}
diff -ruN src/contracts/src/state/tlc/IgnoreGlobalUnlockSchedule.sol contracts/src/state/tlc/IgnoreGlobalUnlockSchedule.sol
--- src/contracts/src/state/tlc/IgnoreGlobalUnlockSchedule.sol	1970-01-01 01:00:00
+++ contracts/src/state/tlc/IgnoreGlobalUnlockSchedule.sol	2024-01-16 15:06:39
@@ -0,0 +1,49 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Global unlock schedule activation storage
+/// @notice Utility to manage the global unlock schedule activation mapping in storage
+/// @notice The global unlock schedule releases 1/24th of the total scheduled amount every month after the local lock end
+library IgnoreGlobalUnlockSchedule {
+    /// @notice Storage slot of the global unlock schedule activation mapping
+    bytes32 internal constant GLOBAL_UNLOCK_ACTIVATION_SLOT =
+        bytes32(uint256(keccak256("tlc.state.globalUnlockScheduleActivation")) - 1);
+
+    /// @notice Structure stored in storage slot
+    struct Slot {
+        /// @custom:attribute Mapping keeping track of activation per schedule
+        mapping(uint256 => bool) value;
+    }
+
+    /// @notice Retrieve the global unlock schedule activation value of a schedule, true if the global lock should be ignored
+    /// @param _scheduleId The schedule id
+    /// @return The global unlock activation value
+    function get(uint256 _scheduleId) internal view returns (bool) {
+        bytes32 slot = GLOBAL_UNLOCK_ACTIVATION_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        return r.value[_scheduleId];
+    }
+
+    /// @notice Sets the global unlock schedule activation value of a schedule
+    /// @param _scheduleId The id of the schedule to modify
+    /// @param _ignoreGlobalUnlock The value to set, true if the global lock should be ignored
+    function set(uint256 _scheduleId, bool _ignoreGlobalUnlock) internal {
+        bytes32 slot = GLOBAL_UNLOCK_ACTIVATION_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        r.value[_scheduleId] = _ignoreGlobalUnlock;
+    }
+}
diff -ruN src/contracts/src/state/tlc/VestingSchedules.1.sol contracts/src/state/tlc/VestingSchedules.1.sol
--- src/contracts/src/state/tlc/VestingSchedules.1.sol	1970-01-01 01:00:00
+++ contracts/src/state/tlc/VestingSchedules.1.sol	2024-01-16 15:06:39
@@ -0,0 +1,97 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title VestingSchedulesV1 Storage
+/// @notice Utility to manage VestingSchedulesV1 in storage
+library VestingSchedulesV1 {
+    /// @notice Storage slot of the Vesting Schedules
+    bytes32 internal constant VESTING_SCHEDULES_SLOT =
+        bytes32(uint256(keccak256("erc20VestableVotes.state.schedules")) - 1);
+
+    struct VestingSchedule {
+        // start time of the vesting period
+        uint64 start;
+        // date at which the vesting is ended
+        // initially it is equal to start+duration then to revoke date in case of revoke
+        uint64 end;
+        // duration before which first tokens gets ownable
+        uint32 cliffDuration;
+        // duration before tokens gets unlocked. can exceed the duration of the vesting chedule
+        uint32 lockDuration;
+        // duration of the entire vesting (sum of all vesting period durations)
+        uint32 duration;
+        // duration of a single period of vesting
+        uint32 periodDuration;
+        // amount of tokens granted by the vesting schedule
+        uint256 amount;
+        // creator of the token vesting
+        address creator;
+        // beneficiary of tokens after they are releaseVestingScheduled
+        address beneficiary;
+        // whether the schedule can be revoked
+        bool revocable;
+    }
+
+    /// @notice The structure at the storage slot
+    struct SlotVestingSchedule {
+        /// @custom:attribute Array containing all the vesting schedules
+        VestingSchedule[] value;
+    }
+
+    /// @notice The VestingSchedule was not found
+    /// @param index vesting schedule index
+    error VestingScheduleNotFound(uint256 index);
+
+    /// @notice Retrieve the vesting schedule in storage
+    /// @param _index index of the vesting schedule
+    /// @return the vesting schedule
+    function get(uint256 _index) internal view returns (VestingSchedule storage) {
+        bytes32 slot = VESTING_SCHEDULES_SLOT;
+
+        SlotVestingSchedule storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        if (r.value.length <= _index) {
+            revert VestingScheduleNotFound(_index);
+        }
+
+        return r.value[_index];
+    }
+
+    /// @notice Get vesting schedule count in storage
+    /// @return The count of vesting schedule in storage
+    function getCount() internal view returns (uint256) {
+        bytes32 slot = VESTING_SCHEDULES_SLOT;
+
+        SlotVestingSchedule storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        return r.value.length;
+    }
+
+    /// @notice Add a new vesting schedule in storage
+    /// @param _newSchedule new vesting schedule to create
+    /// @return The size of the vesting schedule array after the operation
+    function push(VestingSchedule memory _newSchedule) internal returns (uint256) {
+        bytes32 slot = VESTING_SCHEDULES_SLOT;
+
+        SlotVestingSchedule storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        r.value.push(_newSchedule);
+
+        return r.value.length;
+    }
+}
diff -ruN src/contracts/src/state/tlc/VestingSchedules.2.sol contracts/src/state/tlc/VestingSchedules.2.sol
--- src/contracts/src/state/tlc/VestingSchedules.2.sol	1970-01-01 01:00:00
+++ contracts/src/state/tlc/VestingSchedules.2.sol	2024-01-16 15:06:39
@@ -0,0 +1,125 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+import "./VestingSchedules.1.sol";
+
+/// @title VestingSchedulesV2 Storage
+/// @notice Utility to manage VestingSchedulesV2 in storage
+library VestingSchedulesV2 {
+    /// @notice Storage slot of the Vesting Schedules (note the slot is different from v1)
+    bytes32 internal constant VESTING_SCHEDULES_SLOT =
+        bytes32(uint256(keccak256("erc20VestableVotes.state.v2.schedules")) - 1);
+
+    struct VestingSchedule {
+        // start time of the vesting period
+        uint64 start;
+        // date at which the vesting is ended
+        // initially it is equal to start+duration then to revoke date in case of revoke
+        uint64 end;
+        // duration before which first tokens gets ownable
+        uint32 cliffDuration;
+        // duration before tokens gets unlocked. can exceed the duration of the vesting chedule
+        uint32 lockDuration;
+        // duration of the entire vesting (sum of all vesting period durations)
+        uint32 duration;
+        // duration of a single period of vesting
+        uint32 periodDuration;
+        // amount of tokens granted by the vesting schedule
+        uint256 amount;
+        // creator of the token vesting
+        address creator;
+        // beneficiary of tokens after they are releaseVestingScheduled
+        address beneficiary;
+        // whether the schedule can be revoked
+        bool revocable;
+        // amount of released tokens
+        uint256 releasedAmount;
+    }
+
+    /// @notice The structure at the storage slot
+    struct SlotVestingSchedule {
+        /// @custom:attribute Array containing all the vesting schedules
+        VestingSchedule[] value;
+    }
+
+    /// @notice The VestingSchedule was not found
+    /// @param index vesting schedule index
+    error VestingScheduleNotFound(uint256 index);
+
+    /// @notice Retrieve the vesting schedule in storage
+    /// @param _index index of the vesting schedule
+    /// @return the vesting schedule
+    function get(uint256 _index) internal view returns (VestingSchedule storage) {
+        bytes32 slot = VESTING_SCHEDULES_SLOT;
+
+        SlotVestingSchedule storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        if (r.value.length <= _index) {
+            revert VestingScheduleNotFound(_index);
+        }
+
+        return r.value[_index];
+    }
+
+    /// @notice Get vesting schedule count in storage
+    /// @return The count of vesting schedule in storage
+    function getCount() internal view returns (uint256) {
+        bytes32 slot = VESTING_SCHEDULES_SLOT;
+
+        SlotVestingSchedule storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        return r.value.length;
+    }
+
+    /// @notice Add a new vesting schedule in storage
+    /// @param _newSchedule new vesting schedule to create
+    /// @return The size of the vesting schedule array after the operation
+    function push(VestingSchedule memory _newSchedule) internal returns (uint256) {
+        bytes32 slot = VESTING_SCHEDULES_SLOT;
+
+        SlotVestingSchedule storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        r.value.push(_newSchedule);
+
+        return r.value.length;
+    }
+
+    /// @notice Migrate a VestingSchedule from v1 to v2
+    /// @notice Takes a VestingSchedule in v1 format in stores it in v2 format
+    /// @param _index of the schedule in v1 to be migrated
+    /// @param _releasedAmount The released amount to keep in storage
+    /// @return The index of the created schedule in v2 format
+    function migrateVestingScheduleFromV1(uint256 _index, uint256 _releasedAmount) internal returns (uint256) {
+        VestingSchedulesV1.VestingSchedule memory scheduleV1 = VestingSchedulesV1.get(_index);
+        VestingSchedulesV2.VestingSchedule memory scheduleV2 = VestingSchedulesV2.VestingSchedule({
+            start: scheduleV1.start,
+            end: scheduleV1.end,
+            lockDuration: scheduleV1.lockDuration,
+            cliffDuration: scheduleV1.cliffDuration,
+            duration: scheduleV1.duration,
+            periodDuration: scheduleV1.periodDuration,
+            amount: scheduleV1.amount,
+            creator: scheduleV1.creator,
+            beneficiary: scheduleV1.beneficiary,
+            revocable: scheduleV1.revocable,
+            releasedAmount: _releasedAmount
+        });
+
+        return push(scheduleV2) - 1;
+    }
+}
diff -ruN src/contracts/src/state/wlseth/BalanceOf.sol contracts/src/state/wlseth/BalanceOf.sol
--- src/contracts/src/state/wlseth/BalanceOf.sol	1970-01-01 01:00:00
+++ contracts/src/state/wlseth/BalanceOf.sol	2024-01-16 15:06:39
@@ -0,0 +1,47 @@
+//SPDX-License-Identifier: BUSL-1.1
+pragma solidity 0.8.20;
+
+/// @title Balance Storage
+/// @notice Utility to manage the Balance in storage
+library BalanceOf {
+    /// @notice Storage slot of the Balance
+    bytes32 internal constant BALANCE_OF_SLOT = bytes32(uint256(keccak256("river.state.balanceOf")) - 1);
+
+    /// @notice The structure in storage
+    struct Slot {
+        /// @custom:attribute The mapping from an owner to its balance
+        mapping(address => uint256) value;
+    }
+
+    /// @notice Retrieve balance of an owner
+    /// @param _owner The owner of the balance
+    /// @return The balance of the owner
+    function get(address _owner) internal view returns (uint256) {
+        bytes32 slot = BALANCE_OF_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        return r.value[_owner];
+    }
+
+    /// @notice Set the balance of an owner
+    /// @param _owner The owner to change the balance of
+    /// @param _newValue New balance value for the owner
+    function set(address _owner, uint256 _newValue) internal {
+        bytes32 slot = BALANCE_OF_SLOT;
+
+        Slot storage r;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            r.slot := slot
+        }
+
+        r.value[_owner] = _newValue;
+    }
+}
diff -ruN src/interfaces/IAdministrable.sol interfaces/IAdministrable.sol
--- src/interfaces/IAdministrable.sol	2023-12-11 15:38:07
+++ interfaces/IAdministrable.sol	2024-01-16 15:06:39
@@ -1,34 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Administrable Interface
-/// @author Kiln
-/// @notice This interface exposes methods to handle the ownership of the contracts
-interface IAdministrable {
-    /// @notice The pending admin address changed
-    /// @param pendingAdmin New pending admin address
-    event SetPendingAdmin(address indexed pendingAdmin);
-
-    /// @notice The admin address changed
-    /// @param admin New admin address
-    event SetAdmin(address indexed admin);
-
-    /// @notice Retrieves the current admin address
-    /// @return The admin address
-    function getAdmin() external view returns (address);
-
-    /// @notice Retrieve the current pending admin address
-    /// @return The pending admin address
-    function getPendingAdmin() external view returns (address);
-
-    /// @notice Proposes a new address as admin
-    /// @dev This security prevents setting an invalid address as an admin. The pending
-    /// @dev admin has to claim its ownership of the contract, and prove that the new
-    /// @dev address is able to perform regular transactions.
-    /// @param _newAdmin New admin address
-    function proposeAdmin(address _newAdmin) external;
-
-    /// @notice Accept the transfer of ownership
-    /// @dev Only callable by the pending admin. Resets the pending admin if succesful.
-    function acceptAdmin() external;
-}
diff -ruN src/interfaces/IAllowlist.1.sol interfaces/IAllowlist.1.sol
--- src/interfaces/IAllowlist.1.sol	2023-12-11 15:38:07
+++ interfaces/IAllowlist.1.sol	2024-01-16 15:06:39
@@ -1,107 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Allowlist Interface (v1)
-/// @author Kiln
-/// @notice This interface exposes methods to handle the list of allowed recipients.
-interface IAllowlistV1 {
-    /// @notice The permissions of several accounts have changed
-    /// @param accounts List of accounts
-    /// @param permissions New permissions for each account at the same index
-    event SetAllowlistPermissions(address[] accounts, uint256[] permissions);
-
-    /// @notice The stored allower address has been changed
-    /// @param allower The new allower address
-    event SetAllower(address indexed allower);
-
-    /// @notice The stored denier address has been changed
-    /// @param denier The new denier address
-    event SetDenier(address indexed denier);
-
-    /// @notice The provided accounts list is empty
-    error InvalidCount();
-
-    /// @notice The account is denied access
-    /// @param _account The denied account
-    error Denied(address _account);
-
-    /// @notice The provided accounts and permissions list have different lengths
-    error MismatchedArrayLengths();
-
-    /// @notice Allower can't set deny permission
-    error AttemptToSetDenyPermission();
-
-    /// @notice Allower can't remove deny permission
-    error AttemptToRemoveDenyPermission();
-
-    /// @notice Initializes the allowlist
-    /// @param _admin Address of the Allowlist administrator
-    /// @param _allower Address of the allower
-    function initAllowlistV1(address _admin, address _allower) external;
-
-    /// @notice Initializes the allowlist denier
-    /// @param _denier Address of the denier
-    function initAllowlistV1_1(address _denier) external;
-
-    /// @notice Retrieves the allower address
-    /// @return The address of the allower
-    function getAllower() external view returns (address);
-
-    /// @notice Retrieves the denier address
-    /// @return The address of the denier
-    function getDenier() external view returns (address);
-
-    /// @notice This method returns true if the user has the expected permission and
-    ///         is not in the deny list
-    /// @param _account Recipient to verify
-    /// @param _mask Combination of permissions to verify
-    /// @return True if mask is respected and user is allowed
-    function isAllowed(address _account, uint256 _mask) external view returns (bool);
-
-    /// @notice This method returns true if the user is in the deny list
-    /// @param _account Recipient to verify
-    /// @return True if user is denied access
-    function isDenied(address _account) external view returns (bool);
-
-    /// @notice This method returns true if the user has the expected permission
-    ///         ignoring any deny list membership
-    /// @param _account Recipient to verify
-    /// @param _mask Combination of permissions to verify
-    /// @return True if mask is respected
-    function hasPermission(address _account, uint256 _mask) external view returns (bool);
-
-    /// @notice This method retrieves the raw permission value
-    /// @param _account Recipient to verify
-    /// @return The raw permissions value of the account
-    function getPermissions(address _account) external view returns (uint256);
-
-    /// @notice This method should be used as a modifier and is expected to revert
-    ///         if the user hasn't got the required permission or if the user is
-    ///         in the deny list.
-    /// @param _account Recipient to verify
-    /// @param _mask Combination of permissions to verify
-    function onlyAllowed(address _account, uint256 _mask) external view;
-
-    /// @notice Changes the allower address
-    /// @param _newAllowerAddress New address allowed to edit the allowlist
-    function setAllower(address _newAllowerAddress) external;
-
-    /// @notice Changes the denier address
-    /// @param _newDenierAddress New address allowed to edit the allowlist
-    function setDenier(address _newDenierAddress) external;
-
-    /// @notice Sets the allow permissions for one or more accounts
-    /// @dev This function is for allocating or removing deposit, redeem or donate permissions.
-    ///      This function could be used to give any permissions that we come up with in the future.
-    ///      An address which was denied has to be undenied first before they could be given any permission(s).
-    /// @param _accounts Accounts to update
-    /// @param _permissions New permission values
-    function setAllowPermissions(address[] calldata _accounts, uint256[] calldata _permissions) external;
-
-    /// @notice Sets the deny permissions for one or more accounts
-    /// @dev This function is for allocating or removing deny permissions.
-    ///      An address which is undenied has to be given permissions again for them to be able to deposit, donate or redeem.
-    /// @param _accounts Accounts to update
-    /// @param _permissions New permission values
-    function setDenyPermissions(address[] calldata _accounts, uint256[] calldata _permissions) external;
-}
diff -ruN src/interfaces/ICoverageFund.1.sol interfaces/ICoverageFund.1.sol
--- src/interfaces/ICoverageFund.1.sol	2023-12-11 15:38:07
+++ interfaces/ICoverageFund.1.sol	2024-01-16 15:06:39
@@ -1,40 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Coverage Fund Interface (v1)
-/// @author Kiln
-/// @notice This interface exposes methods to receive donations for the slashing coverage fund and pull the funds into river
-interface ICoverageFundV1 {
-    /// @notice The storage river address has changed
-    /// @param river The new river address
-    event SetRiver(address indexed river);
-
-    /// @notice A donation has been made to the coverage fund
-    /// @param donator Address that performed the donation
-    /// @param amount The amount donated
-    event Donate(address indexed donator, uint256 amount);
-
-    /// @notice The fallback or receive callback has been triggered
-    error InvalidCall();
-
-    /// @notice A donation with 0 ETH has been performed
-    error EmptyDonation();
-
-    /// @notice Initialize the coverage fund with the required arguments
-    /// @param _riverAddress Address of River
-    function initCoverageFundV1(address _riverAddress) external;
-
-    /// @notice Pulls ETH into the River contract
-    /// @dev Only callable by the River contract
-    /// @param _maxAmount The maximum amount to pull into the system
-    function pullCoverageFunds(uint256 _maxAmount) external;
-
-    /// @notice Donates ETH to the coverage fund contract
-    function donate() external payable;
-
-    /// @notice Ether receiver
-    receive() external payable;
-
-    /// @notice Invalid fallback detector
-    fallback() external payable;
-}
diff -ruN src/interfaces/IDepositContract.sol interfaces/IDepositContract.sol
--- src/interfaces/IDepositContract.sol	2023-12-11 15:38:07
+++ interfaces/IDepositContract.sol	2024-01-16 15:06:39
@@ -1,18 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Deposit Contract Interface
-/// @notice This interface exposes methods to perform validator deposits
-interface IDepositContract {
-    /// @notice Official deposit method to activate a validator on the consensus layer
-    /// @param pubkey The 48 bytes long BLS Public key representing the validator
-    /// @param withdrawalCredentials The 32 bytes long withdrawal credentials, configures the withdrawal recipient
-    /// @param signature The 96 bytes long BLS Signature performed by the pubkey's private key
-    /// @param depositDataRoot The root hash of the whole deposit data structure
-    function deposit(
-        bytes calldata pubkey,
-        bytes calldata withdrawalCredentials,
-        bytes calldata signature,
-        bytes32 depositDataRoot
-    ) external payable;
-}
diff -ruN src/interfaces/IELFeeRecipient.1.sol interfaces/IELFeeRecipient.1.sol
--- src/interfaces/IELFeeRecipient.1.sol	2023-12-11 15:38:07
+++ interfaces/IELFeeRecipient.1.sol	2024-01-16 15:06:39
@@ -1,29 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Execution Layer Fee Recipient Interface (v1)
-/// @author Kiln
-/// @notice This interface exposes methods to receive all the execution layer fees from the proposed blocks + bribes
-interface IELFeeRecipientV1 {
-    /// @notice The storage river address has changed
-    /// @param river The new river address
-    event SetRiver(address indexed river);
-
-    /// @notice The fallback has been triggered
-    error InvalidCall();
-
-    /// @notice Initialize the fee recipient with the required arguments
-    /// @param _riverAddress Address of River
-    function initELFeeRecipientV1(address _riverAddress) external;
-
-    /// @notice Pulls ETH to the River contract
-    /// @dev Only callable by the River contract
-    /// @param _maxAmount The maximum amount to pull into the system
-    function pullELFees(uint256 _maxAmount) external;
-
-    /// @notice Ether receiver
-    receive() external payable;
-
-    /// @notice Invalid fallback detector
-    fallback() external payable;
-}
diff -ruN src/interfaces/IFirewall.sol interfaces/IFirewall.sol
--- src/interfaces/IFirewall.sol	2023-12-11 15:38:07
+++ interfaces/IFirewall.sol	2024-01-16 15:06:39
@@ -1,48 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Firewall
-/// @author Figment
-/// @notice This interface exposes methods to accept calls to admin-level functions of an underlying contract.
-interface IFirewall {
-    /// @notice The stored executor address has been changed
-    /// @param executor The new executor address
-    event SetExecutor(address indexed executor);
-
-    /// @notice The stored destination address has been changed
-    /// @param destination The new destination address
-    event SetDestination(address indexed destination);
-
-    /// @notice The storage permission for a selector has been changed
-    /// @param selector The 4 bytes method selector
-    /// @param status True if executor is allowed
-    event SetExecutorPermissions(bytes4 selector, bool status);
-
-    /// @notice Retrieve the executor address
-    /// @return The executor address
-    function executor() external view returns (address);
-
-    /// @notice Retrieve the destination address
-    /// @return The destination address
-    function destination() external view returns (address);
-
-    /// @notice Returns true if the executor is allowed to perform a call on the given selector
-    /// @param _selector The selector to verify
-    /// @return True if executor is allowed to call
-    function executorCanCall(bytes4 _selector) external view returns (bool);
-
-    /// @notice Sets the executor address
-    /// @param _newExecutor New address for the executor
-    function setExecutor(address _newExecutor) external;
-
-    /// @notice Sets the permission for a function selector
-    /// @param _functionSelector Method signature on which the permission is changed
-    /// @param _executorCanCall True if selector is callable by the executor
-    function allowExecutor(bytes4 _functionSelector, bool _executorCanCall) external;
-
-    /// @notice Fallback method. All its parameters are forwarded to the destination if caller is authorized
-    fallback() external payable;
-
-    /// @notice Receive fallback method. All its parameters are forwarded to the destination if caller is authorized
-    receive() external payable;
-}
diff -ruN src/interfaces/IOperatorRegistry.1.sol interfaces/IOperatorRegistry.1.sol
--- src/interfaces/IOperatorRegistry.1.sol	2023-12-11 15:38:07
+++ interfaces/IOperatorRegistry.1.sol	2024-01-16 15:06:39
@@ -1,333 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../state/operatorsRegistry/Operators.2.sol";
-
-/// @title Operators Registry Interface (v1)
-/// @author Kiln
-/// @notice This interface exposes methods to handle the list of operators and their keys
-interface IOperatorsRegistryV1 {
-    /// @notice A new operator has been added to the registry
-    /// @param index The operator index
-    /// @param name The operator display name
-    /// @param operatorAddress The operator address
-    event AddedOperator(uint256 indexed index, string name, address indexed operatorAddress);
-
-    /// @notice The operator status has been changed
-    /// @param index The operator index
-    /// @param active True if the operator is active
-    event SetOperatorStatus(uint256 indexed index, bool active);
-
-    /// @notice The operator limit has been changed
-    /// @param index The operator index
-    /// @param newLimit The new operator staking limit
-    event SetOperatorLimit(uint256 indexed index, uint256 newLimit);
-
-    /// @notice The operator stopped validator count has been changed
-    /// @param index The operator index
-    /// @param newStoppedValidatorCount The new stopped validator count
-    event SetOperatorStoppedValidatorCount(uint256 indexed index, uint256 newStoppedValidatorCount);
-
-    /// @notice The operator address has been changed
-    /// @param index The operator index
-    /// @param newOperatorAddress The new operator address
-    event SetOperatorAddress(uint256 indexed index, address indexed newOperatorAddress);
-
-    /// @notice The operator display name has been changed
-    /// @param index The operator index
-    /// @param newName The new display name
-    event SetOperatorName(uint256 indexed index, string newName);
-
-    /// @notice The operator or the admin added new validator keys and signatures
-    /// @dev The public keys and signatures are concatenated
-    /// @dev A public key is 48 bytes long
-    /// @dev A signature is 96 bytes long
-    /// @dev [P1, S1, P2, S2, ..., PN, SN] where N is the bytes length divided by (96 + 48)
-    /// @param index The operator index
-    /// @param publicKeysAndSignatures The concatenated public keys and signatures
-    event AddedValidatorKeys(uint256 indexed index, bytes publicKeysAndSignatures);
-
-    /// @notice The operator or the admin removed a public key and its signature from the registry
-    /// @param index The operator index
-    /// @param publicKey The BLS public key that has been removed
-    event RemovedValidatorKey(uint256 indexed index, bytes publicKey);
-
-    /// @notice The stored river address has been changed
-    /// @param river The new river address
-    event SetRiver(address indexed river);
-
-    /// @notice The operator edited its keys after the snapshot block
-    /// @dev This means that we cannot assume that its key set is checked by the snapshot
-    /// @dev This happens only if the limit was meant to be increased
-    /// @param index The operator index
-    /// @param currentLimit The current operator limit
-    /// @param newLimit The new operator limit that was attempted to be set
-    /// @param latestKeysEditBlockNumber The last block number at which the operator changed its keys
-    /// @param snapshotBlock The block number of the snapshot
-    event OperatorEditsAfterSnapshot(
-        uint256 indexed index,
-        uint256 currentLimit,
-        uint256 newLimit,
-        uint256 indexed latestKeysEditBlockNumber,
-        uint256 indexed snapshotBlock
-    );
-
-    /// @notice The call didn't alter the limit of the operator
-    /// @param index The operator index
-    /// @param limit The limit of the operator
-    event OperatorLimitUnchanged(uint256 indexed index, uint256 limit);
-
-    /// @notice The stopped validator array has been changed
-    /// @notice A validator is considered stopped if exiting, exited or slashed
-    /// @notice This event is emitted when the oracle reports new stopped validators counts
-    /// @param stoppedValidatorCounts The new stopped validator counts
-    event UpdatedStoppedValidators(uint32[] stoppedValidatorCounts);
-
-    /// @notice The requested exit count has been updated
-    /// @param index The operator index
-    /// @param count The count of requested exits
-    event RequestedValidatorExits(uint256 indexed index, uint256 count);
-
-    /// @notice The exit request demand has been updated
-    /// @param previousValidatorExitsDemand The previous exit request demand
-    /// @param nextValidatorExitsDemand The new exit request demand
-    event SetCurrentValidatorExitsDemand(uint256 previousValidatorExitsDemand, uint256 nextValidatorExitsDemand);
-
-    /// @notice The total requested exit has been updated
-    /// @param previousTotalValidatorExitsRequested The previous total requested exit
-    /// @param newTotalValidatorExitsRequested The new total requested exit
-    event SetTotalValidatorExitsRequested(
-        uint256 previousTotalValidatorExitsRequested, uint256 newTotalValidatorExitsRequested
-    );
-
-    /// @notice A validator key got funded on the deposit contract
-    /// @notice This event was introduced during a contract upgrade, in order to cover all possible public keys, this event
-    /// @notice will be replayed for past funded keys in order to have a complete coverage of all the funded public keys.
-    /// @notice In this particuliar scenario, the deferred value will be set to true, to indicate that we are not going to have
-    /// @notice the expected additional events and side effects in the same transaction (deposit to official DepositContract etc ...) because
-    /// @notice the event was synthetically crafted.
-    /// @param index The operator index
-    /// @param publicKeys BLS Public key that got funded
-    /// @param deferred True if event has been replayed in the context of a migration
-    event FundedValidatorKeys(uint256 indexed index, bytes[] publicKeys, bool deferred);
-
-    /// @notice The requested exit count has been update to fill the gap with the reported stopped count
-    /// @param index The operator index
-    /// @param oldRequestedExits The old requested exit count
-    /// @param newRequestedExits The new requested exit count
-    event UpdatedRequestedValidatorExitsUponStopped(
-        uint256 indexed index, uint32 oldRequestedExits, uint32 newRequestedExits
-    );
-
-    /// @notice The calling operator is inactive
-    /// @param index The operator index
-    error InactiveOperator(uint256 index);
-
-    /// @notice A funded key deletion has been attempted
-    error InvalidFundedKeyDeletionAttempt();
-
-    /// @notice The index provided are not sorted properly (descending order)
-    error InvalidUnsortedIndexes();
-
-    /// @notice The provided operator and limits array have different lengths
-    error InvalidArrayLengths();
-
-    /// @notice The provided operator and limits array are empty
-    error InvalidEmptyArray();
-
-    /// @notice The provided key count is 0
-    error InvalidKeyCount();
-
-    /// @notice The provided concatenated keys do not have the expected length
-    error InvalidKeysLength();
-
-    /// @notice The index that is removed is out of bounds
-    error InvalidIndexOutOfBounds();
-
-    /// @notice The value for the operator limit is too high
-    /// @param index The operator index
-    /// @param limit The new limit provided
-    /// @param keyCount The operator key count
-    error OperatorLimitTooHigh(uint256 index, uint256 limit, uint256 keyCount);
-
-    /// @notice The value for the limit is too low
-    /// @param index The operator index
-    /// @param limit The new limit provided
-    /// @param fundedKeyCount The operator funded key count
-    error OperatorLimitTooLow(uint256 index, uint256 limit, uint256 fundedKeyCount);
-
-    /// @notice The provided list of operators is not in increasing order
-    error UnorderedOperatorList();
-
-    /// @notice Thrown when an invalid empty stopped validator array is provided
-    error InvalidEmptyStoppedValidatorCountsArray();
-
-    /// @notice Thrown when the sum of stopped validators is invalid
-    error InvalidStoppedValidatorCountsSum();
-
-    /// @notice Throw when an element in the stopped validator array is decreasing
-    error StoppedValidatorCountsDecreased();
-
-    /// @notice Thrown when the number of elements in the array is too high compared to operator count
-    error StoppedValidatorCountsTooHigh();
-
-    /// @notice Thrown when no exit requests can be performed
-    error NoExitRequestsToPerform();
-
-    /// @notice The provided stopped validator count array is shrinking
-    error StoppedValidatorCountArrayShrinking();
-
-    /// @notice The provided stopped validator count of an operator is above its funded validator count
-    error StoppedValidatorCountAboveFundedCount(uint256 operatorIndex, uint32 stoppedCount, uint32 fundedCount);
-
-    /// @notice Initializes the operators registry
-    /// @param _admin Admin in charge of managing operators
-    /// @param _river Address of River system
-    function initOperatorsRegistryV1(address _admin, address _river) external;
-
-    /// @notice Initializes the operators registry for V1_1
-    function initOperatorsRegistryV1_1() external;
-
-    /// @notice Retrieve the River address
-    /// @return The address of River
-    function getRiver() external view returns (address);
-
-    /// @notice Get operator details
-    /// @param _index The index of the operator
-    /// @return The details of the operator
-    function getOperator(uint256 _index) external view returns (OperatorsV2.Operator memory);
-
-    /// @notice Get operator count
-    /// @return The operator count
-    function getOperatorCount() external view returns (uint256);
-
-    /// @notice Retrieve the stopped validator count for an operator index
-    /// @param _idx The index of the operator
-    /// @return The stopped validator count of the operator
-    function getOperatorStoppedValidatorCount(uint256 _idx) external view returns (uint32);
-
-    /// @notice Retrieve the total stopped validator count
-    /// @return The total stopped validator count
-    function getTotalStoppedValidatorCount() external view returns (uint32);
-
-    /// @notice Retrieve the total requested exit count
-    /// @notice This value is the amount of exit requests that have been performed, emitting an event for operators to catch
-    /// @return The total requested exit count
-    function getTotalValidatorExitsRequested() external view returns (uint256);
-
-    /// @notice Get the current exit request demand waiting to be triggered
-    /// @notice This value is the amount of exit requests that are demanded and not yet performed by the contract
-    /// @return The current exit request demand
-    function getCurrentValidatorExitsDemand() external view returns (uint256);
-
-    /// @notice Retrieve the total stopped and requested exit count
-    /// @return The total stopped count
-    /// @return The total requested exit count
-    function getStoppedAndRequestedExitCounts() external view returns (uint32, uint256);
-
-    /// @notice Retrieve the raw stopped validators array from storage
-    /// @return The stopped validator array
-    function getStoppedValidatorCountPerOperator() external view returns (uint32[] memory);
-
-    /// @notice Get the details of a validator
-    /// @param _operatorIndex The index of the operator
-    /// @param _validatorIndex The index of the validator
-    /// @return publicKey The public key of the validator
-    /// @return signature The signature used during deposit
-    /// @return funded True if validator has been funded
-    function getValidator(uint256 _operatorIndex, uint256 _validatorIndex)
-        external
-        view
-        returns (bytes memory publicKey, bytes memory signature, bool funded);
-
-    /// @notice Retrieve the active operator set
-    /// @return The list of active operators and their details
-    function listActiveOperators() external view returns (OperatorsV2.Operator[] memory);
-
-    /// @notice Allows river to override the stopped validators array
-    /// @notice This actions happens during the Oracle report processing
-    /// @param _stoppedValidatorCounts The new stopped validators array
-    /// @param _depositedValidatorCount The total deposited validator count
-    function reportStoppedValidatorCounts(uint32[] calldata _stoppedValidatorCounts, uint256 _depositedValidatorCount)
-        external;
-
-    /// @notice Adds an operator to the registry
-    /// @dev Only callable by the administrator
-    /// @param _name The name identifying the operator
-    /// @param _operator The address representing the operator, receiving the rewards
-    /// @return The index of the new operator
-    function addOperator(string calldata _name, address _operator) external returns (uint256);
-
-    /// @notice Changes the operator address of an operator
-    /// @dev Only callable by the administrator or the previous operator address
-    /// @param _index The operator index
-    /// @param _newOperatorAddress The new address of the operator
-    function setOperatorAddress(uint256 _index, address _newOperatorAddress) external;
-
-    /// @notice Changes the operator name
-    /// @dev Only callable by the administrator or the operator
-    /// @param _index The operator index
-    /// @param _newName The new operator name
-    function setOperatorName(uint256 _index, string calldata _newName) external;
-
-    /// @notice Changes the operator status
-    /// @dev Only callable by the administrator
-    /// @param _index The operator index
-    /// @param _newStatus The new status of the operator
-    function setOperatorStatus(uint256 _index, bool _newStatus) external;
-
-    /// @notice Changes the operator staking limit
-    /// @dev Only callable by the administrator
-    /// @dev The operator indexes must be in increasing order and contain no duplicate
-    /// @dev The limit cannot exceed the total key count of the operator
-    /// @dev The _indexes and _newLimits must have the same length.
-    /// @dev Each limit value is applied to the operator index at the same index in the _indexes array.
-    /// @param _operatorIndexes The operator indexes, in increasing order and duplicate free
-    /// @param _newLimits The new staking limit of the operators
-    /// @param _snapshotBlock The block number at which the snapshot was computed
-    function setOperatorLimits(
-        uint256[] calldata _operatorIndexes,
-        uint32[] calldata _newLimits,
-        uint256 _snapshotBlock
-    ) external;
-
-    /// @notice Adds new keys for an operator
-    /// @dev Only callable by the administrator or the operator address
-    /// @param _index The operator index
-    /// @param _keyCount The amount of keys provided
-    /// @param _publicKeysAndSignatures Public keys of the validator, concatenated
-    function addValidators(uint256 _index, uint32 _keyCount, bytes calldata _publicKeysAndSignatures) external;
-
-    /// @notice Remove validator keys
-    /// @dev Only callable by the administrator or the operator address
-    /// @dev The indexes must be provided sorted in decreasing order and duplicate-free, otherwise the method will revert
-    /// @dev The operator limit will be set to the lowest deleted key index if the operator's limit wasn't equal to its total key count
-    /// @dev The operator or the admin cannot remove funded keys
-    /// @dev When removing validators, the indexes of specific unfunded keys can be changed in order to properly
-    /// @dev remove the keys from the storage array. Beware of this specific behavior when chaining calls as the
-    /// @dev targeted public key indexes can point to a different key after a first call was made and performed
-    /// @dev some swaps
-    /// @param _index The operator index
-    /// @param _indexes The indexes of the keys to remove
-    function removeValidators(uint256 _index, uint256[] calldata _indexes) external;
-
-    /// @notice Retrieve validator keys based on operator statuses
-    /// @param _count Max amount of keys requested
-    /// @return publicKeys An array of public keys
-    /// @return signatures An array of signatures linked to the public keys
-    function pickNextValidatorsToDeposit(uint256 _count)
-        external
-        returns (bytes[] memory publicKeys, bytes[] memory signatures);
-
-    /// @notice Public endpoint to consume the exit request demand and perform the actual exit requests
-    /// @notice The selection algorithm will pick validators based on their active validator counts
-    /// @notice This value is computed by using the count of funded keys and taking into account the stopped validator counts and exit requests
-    /// @param _count Max amount of exits to request
-    function requestValidatorExits(uint256 _count) external;
-
-    /// @notice Increases the exit request demand
-    /// @dev This method is only callable by the river contract, and to actually forward the information to the node operators via event emission, the unprotected requestValidatorExits method must be called
-    /// @param _count The amount of exit requests to add to the demand
-    /// @param _depositedValidatorCount The total deposited validator count
-    function demandValidatorExits(uint256 _count, uint256 _depositedValidatorCount) external;
-}
diff -ruN src/interfaces/IOracle.1.sol interfaces/IOracle.1.sol
--- src/interfaces/IOracle.1.sol	2023-12-11 15:38:07
+++ interfaces/IOracle.1.sol	2024-01-16 15:06:39
@@ -1,184 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "./IRiver.1.sol";
-import "../state/oracle/ReportsVariants.sol";
-
-/// @title Oracle Interface (v1)
-/// @author Kiln
-/// @notice This interface exposes methods to handle the input from the allowed oracle members.
-/// @notice Highly inspired by Lido's implementation.
-interface IOracleV1 {
-    /// @notice The storage quorum value has been changed
-    /// @param newQuorum The new quorum value
-    event SetQuorum(uint256 newQuorum);
-
-    /// @notice A member has been added to the oracle member list
-    /// @param member The address of the member
-    event AddMember(address indexed member);
-
-    /// @notice A member has been removed from the oracle member list
-    /// @param member The address of the member
-    event RemoveMember(address indexed member);
-
-    /// @notice A member address has been edited
-    /// @param oldAddress The previous member address
-    /// @param newAddress The new member address
-    event SetMember(address indexed oldAddress, address indexed newAddress);
-
-    /// @notice The storage river address value has been changed
-    /// @param _river The new river address
-    event SetRiver(address _river);
-
-    /// @notice The consensus layer spec has been changed
-    /// @param epochsPerFrame The number of epochs inside a frame (225 = 24 hours)
-    /// @param slotsPerEpoch The number of slots inside an epoch (32 on ethereum mainnet)
-    /// @param secondsPerSlot The time between two slots (12 seconds on ethereum mainnet)
-    /// @param genesisTime The timestamp of block #0
-    event SetSpec(uint64 epochsPerFrame, uint64 slotsPerEpoch, uint64 secondsPerSlot, uint64 genesisTime);
-
-    /// @notice The report bounds have been changed
-    /// @param annualAprUpperBound The maximum allowed apr. 10% means increases in balance extrapolated to a year should not exceed 10%.
-    /// @param relativeLowerBound The maximum allowed balance decrease as a relative % of the total balance
-    event SetBounds(uint256 annualAprUpperBound, uint256 relativeLowerBound);
-
-    /// @notice An oracle member performed a report
-    /// @param member The oracle member
-    /// @param variant The variant of the report
-    /// @param report The raw report structure
-    /// @param voteCount The vote count
-    event ReportedConsensusLayerData(
-        address indexed member,
-        bytes32 indexed variant,
-        IRiverV1.ConsensusLayerReport report,
-        uint256 voteCount,
-        uint256 quorum
-    );
-
-    /// @notice The last reported epoch has changed
-    event SetLastReportedEpoch(uint256 lastReportedEpoch);
-
-    /// @notice Cleared reporting data
-    event ClearedReporting();
-
-    /// @notice The provided epoch is too old compared to the expected epoch id
-    /// @param providedEpochId The epoch id provided as input
-    /// @param minExpectedEpochId The minimum epoch id expected
-    error EpochTooOld(uint256 providedEpochId, uint256 minExpectedEpochId);
-
-    /// @notice Thrown when the reported epoch is invalid
-    /// @param epoch The invalid epoch
-    error InvalidEpoch(uint256 epoch);
-
-    /// @notice Thrown when the report indexs fetched is out of bounds
-    /// @param index Requested index
-    /// @param length Size of the variant array
-    error ReportIndexOutOfBounds(uint256 index, uint256 length);
-
-    /// @notice The member already reported on the given epoch id
-    /// @param epochId The epoch id provided as input
-    /// @param member The oracle member
-    error AlreadyReported(uint256 epochId, address member);
-
-    /// @notice The address is already in use by an oracle member
-    /// @param newAddress The address already in use
-    error AddressAlreadyInUse(address newAddress);
-
-    /// @notice Initializes the oracle
-    /// @param _river Address of the River contract, able to receive oracle input data after quorum is met
-    /// @param _administratorAddress Address able to call administrative methods
-    /// @param _epochsPerFrame CL spec parameter. Number of epochs in a frame.
-    /// @param _slotsPerEpoch CL spec parameter. Number of slots in one epoch.
-    /// @param _secondsPerSlot CL spec parameter. Number of seconds between slots.
-    /// @param _genesisTime CL spec parameter. Timestamp of the genesis slot.
-    /// @param _annualAprUpperBound CL bound parameter. Maximum apr allowed for balance increase. Delta between updates is extrapolated on a year time frame.
-    /// @param _relativeLowerBound CL bound parameter. Maximum relative balance decrease.
-    function initOracleV1(
-        address _river,
-        address _administratorAddress,
-        uint64 _epochsPerFrame,
-        uint64 _slotsPerEpoch,
-        uint64 _secondsPerSlot,
-        uint64 _genesisTime,
-        uint256 _annualAprUpperBound,
-        uint256 _relativeLowerBound
-    ) external;
-
-    /// @notice Initializes the oracle
-    function initOracleV1_1() external;
-
-    /// @notice Retrieve River address
-    /// @return The address of River
-    function getRiver() external view returns (address);
-
-    /// @notice Retrieve member report status
-    /// @param _oracleMember Address of member to check
-    /// @return True if member has reported
-    function getMemberReportStatus(address _oracleMember) external view returns (bool);
-
-    /// @notice Retrieve member report status
-    /// @return The raw report status value
-    function getGlobalReportStatus() external view returns (uint256);
-
-    /// @notice Retrieve report variants count
-    /// @return The count of report variants
-    function getReportVariantsCount() external view returns (uint256);
-
-    /// @notice Retrieve the details of a report variant
-    /// @param _idx The index of the report variant
-    /// @return The report variant details
-    function getReportVariantDetails(uint256 _idx)
-        external
-        view
-        returns (ReportsVariants.ReportVariantDetails memory);
-
-    /// @notice Retrieve the current quorum
-    /// @return The current quorum
-    function getQuorum() external view returns (uint256);
-
-    /// @notice Retrieve the list of oracle members
-    /// @return The oracle members
-    function getOracleMembers() external view returns (address[] memory);
-
-    /// @notice Returns true if address is member
-    /// @dev Performs a naive search, do not call this on-chain, used as an off-chain helper
-    /// @param _memberAddress Address of the member
-    /// @return True if address is a member
-    function isMember(address _memberAddress) external view returns (bool);
-
-    /// @notice Retrieve the last reported epoch id
-    /// @dev The Oracle contracts expects reports on an epoch id >= that the returned value
-    /// @return The last reported epoch id
-    function getLastReportedEpochId() external view returns (uint256);
-
-    /// @notice Adds new address as oracle member, giving the ability to push cl reports.
-    /// @dev Only callable by the adminstrator
-    /// @dev Modifying the quorum clears all the reporting data
-    /// @param _newOracleMember Address of the new member
-    /// @param _newQuorum New quorum value
-    function addMember(address _newOracleMember, uint256 _newQuorum) external;
-
-    /// @notice Removes an address from the oracle members.
-    /// @dev Only callable by the adminstrator
-    /// @dev Modifying the quorum clears all the reporting data
-    /// @dev Remaining members that have already voted should vote again for the same frame.
-    /// @param _oracleMember Address to remove
-    /// @param _newQuorum New quorum value
-    function removeMember(address _oracleMember, uint256 _newQuorum) external;
-
-    /// @notice Changes the address of an oracle member
-    /// @dev Only callable by the adminitrator or the member itself
-    /// @dev Cannot use an address already in use
-    /// @param _oracleMember Address to change
-    /// @param _newAddress New address for the member
-    function setMember(address _oracleMember, address _newAddress) external;
-
-    /// @notice Edits the quorum required to forward cl data to River
-    /// @dev Modifying the quorum clears all the reporting data
-    /// @param _newQuorum New quorum parameter
-    function setQuorum(uint256 _newQuorum) external;
-
-    /// @notice Submit a report as an oracle member
-    /// @param _report The report structure
-    function reportConsensusLayerData(IRiverV1.ConsensusLayerReport calldata _report) external;
-}
diff -ruN src/interfaces/IRedeemManager.1.sol interfaces/IRedeemManager.1.sol
--- src/interfaces/IRedeemManager.1.sol	2023-12-11 15:38:07
+++ interfaces/IRedeemManager.1.sol	2024-01-16 15:06:39
@@ -1,190 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../state/redeemManager/RedeemQueue.sol";
-import "../state/redeemManager/WithdrawalStack.sol";
-
-/// @title Redeem Manager Interface (v1)
-/// @author Kiln
-/// @notice This contract handles the redeem requests of all users
-interface IRedeemManagerV1 {
-    /// @notice Emitted when a redeem request is created
-    /// @param owner The owner of the redeem request
-    /// @param height The height of the redeem request in LsETH
-    /// @param amount The amount of the redeem request in LsETH
-    /// @param maxRedeemableEth The maximum amount of eth that can be redeemed from this request
-    /// @param id The id of the new redeem request
-    event RequestedRedeem(address indexed owner, uint256 height, uint256 amount, uint256 maxRedeemableEth, uint32 id);
-
-    /// @notice Emitted when a withdrawal event is created
-    /// @param height The height of the withdrawal event in LsETH
-    /// @param amount The amount of the withdrawal event in LsETH
-    /// @param ethAmount The amount of eth to distrubute to claimers
-    /// @param id The id of the withdrawal event
-    event ReportedWithdrawal(uint256 height, uint256 amount, uint256 ethAmount, uint32 id);
-
-    /// @notice Emitted when a redeem request has been satisfied and filled (even partially) from a withdrawal event
-    /// @param redeemRequestId The id of the redeem request
-    /// @param withdrawalEventId The id of the withdrawal event used to fill the request
-    /// @param lsEthAmountSatisfied The amount of LsETH filled
-    /// @param ethAmountSatisfied The amount of ETH filled
-    /// @param lsEthAmountRemaining The amount of LsETH remaining
-    /// @param ethAmountExceeding The amount of eth added to the exceeding buffer
-    event SatisfiedRedeemRequest(
-        uint32 indexed redeemRequestId,
-        uint32 indexed withdrawalEventId,
-        uint256 lsEthAmountSatisfied,
-        uint256 ethAmountSatisfied,
-        uint256 lsEthAmountRemaining,
-        uint256 ethAmountExceeding
-    );
-
-    /// @notice Emitted when a redeem request claim has been processed and matched at least once and funds are sent to the recipient
-    /// @param redeemRequestId The id of the redeem request
-    /// @param recipient The address receiving the redeem request funds
-    /// @param ethAmount The amount of eth retrieved
-    /// @param lsEthAmount The total amount of LsETH used to redeem the eth
-    /// @param remainingLsEthAmount The amount of LsETH remaining
-    event ClaimedRedeemRequest(
-        uint32 indexed redeemRequestId,
-        address indexed recipient,
-        uint256 ethAmount,
-        uint256 lsEthAmount,
-        uint256 remainingLsEthAmount
-    );
-
-    /// @notice Emitted when the redeem demand is set
-    /// @param oldRedeemDemand The old redeem demand
-    /// @param newRedeemDemand The new redeem demand
-    event SetRedeemDemand(uint256 oldRedeemDemand, uint256 newRedeemDemand);
-
-    /// @notice Emitted when the River address is set
-    /// @param river The new river address
-    event SetRiver(address river);
-
-    /// @notice Thrown When a zero value is provided
-    error InvalidZeroAmount();
-
-    /// @notice Thrown when a transfer error occured with LsETH
-    error TransferError();
-
-    /// @notice Thrown when the provided arrays don't have matching lengths
-    error IncompatibleArrayLengths();
-
-    /// @notice Thrown when the provided redeem request id is out of bounds
-    /// @param id The redeem request id
-    error RedeemRequestOutOfBounds(uint256 id);
-
-    /// @notice Thrown when the withdrawal request id if out of bounds
-    /// @param id The withdrawal event id
-    error WithdrawalEventOutOfBounds(uint256 id);
-
-    /// @notice Thrown when	the redeem request id is already claimed
-    /// @param id The redeem request id
-    error RedeemRequestAlreadyClaimed(uint256 id);
-
-    /// @notice Thrown when the redeem request and withdrawal event are not matching during claim
-    /// @param redeemRequestId The provided redeem request id
-    /// @param withdrawalEventId The provided associated withdrawal event id
-    error DoesNotMatch(uint256 redeemRequestId, uint256 withdrawalEventId);
-
-    /// @notice Thrown when the provided withdrawal event exceeds the redeem demand
-    /// @param withdrawalAmount The amount of the withdrawal event
-    /// @param redeemDemand The current redeem demand
-    error WithdrawalExceedsRedeemDemand(uint256 withdrawalAmount, uint256 redeemDemand);
-
-    /// @notice Thrown when the payment after a claim failed
-    /// @param recipient The recipient of the payment
-    /// @param rdata The revert data
-    error ClaimRedeemFailed(address recipient, bytes rdata);
-
-    /// @param _river The address of the River contract
-    function initializeRedeemManagerV1(address _river) external;
-
-    /// @notice Retrieve River address
-    /// @return The address of River
-    function getRiver() external view returns (address);
-
-    /// @notice Retrieve the global count of redeem requests
-    function getRedeemRequestCount() external view returns (uint256);
-
-    /// @notice Retrieve the details of a specific redeem request
-    /// @param _redeemRequestId The id of the request
-    /// @return The redeem request details
-    function getRedeemRequestDetails(uint32 _redeemRequestId)
-        external
-        view
-        returns (RedeemQueue.RedeemRequest memory);
-
-    /// @notice Retrieve the global count of withdrawal events
-    function getWithdrawalEventCount() external view returns (uint256);
-
-    /// @notice Retrieve the details of a specific withdrawal event
-    /// @param _withdrawalEventId The id of the withdrawal event
-    /// @return The withdrawal event details
-    function getWithdrawalEventDetails(uint32 _withdrawalEventId)
-        external
-        view
-        returns (WithdrawalStack.WithdrawalEvent memory);
-
-    /// @notice Retrieve the amount of redeemed LsETH pending to be supplied with withdrawn ETH
-    /// @return The amount of eth in the buffer
-    function getBufferedExceedingEth() external view returns (uint256);
-
-    /// @notice Retrieve the amount of LsETH waiting to be exited
-    /// @return The amount of LsETH waiting to be exited
-    function getRedeemDemand() external view returns (uint256);
-
-    /// @notice Resolves the provided list of redeem request ids
-    /// @dev The result is an array of equal length with ids or error code
-    /// @dev -1 means that the request is not satisfied yet
-    /// @dev -2 means that the request is out of bounds
-    /// @dev -3 means that the request has already been claimed
-    /// @dev This call was created to be called by an off-chain interface, the output could then be used to perform the claimRewards call in a regular transaction
-    /// @param _redeemRequestIds The list of redeem requests to resolve
-    /// @return withdrawalEventIds The list of withdrawal events matching every redeem request (or error codes)
-    function resolveRedeemRequests(uint32[] calldata _redeemRequestIds)
-        external
-        view
-        returns (int64[] memory withdrawalEventIds);
-
-    /// @notice Creates a redeem request
-    /// @param _lsETHAmount The amount of LsETH to redeem
-    /// @param _recipient The recipient owning the redeem request
-    /// @return redeemRequestId The id of the redeem request
-    function requestRedeem(uint256 _lsETHAmount, address _recipient) external returns (uint32 redeemRequestId);
-
-    /// @notice Creates a redeem request using msg.sender as recipient
-    /// @param _lsETHAmount The amount of LsETH to redeem
-    /// @return redeemRequestId The id of the redeem request
-    function requestRedeem(uint256 _lsETHAmount) external returns (uint32 redeemRequestId);
-
-    /// @notice Claims the rewards of the provided redeem request ids
-    /// @param _redeemRequestIds The list of redeem requests to claim
-    /// @param _withdrawalEventIds The list of withdrawal events to use for every redeem request claim
-    /// @param _skipAlreadyClaimed True if the call should not revert on claiming of already claimed requests
-    /// @param _depth The maximum recursive depth for the resolution of the redeem requests
-    /// @return claimStatuses The list of claim statuses. 0 for fully claimed, 1 for partially claimed, 2 for skipped
-    function claimRedeemRequests(
-        uint32[] calldata _redeemRequestIds,
-        uint32[] calldata _withdrawalEventIds,
-        bool _skipAlreadyClaimed,
-        uint16 _depth
-    ) external returns (uint8[] memory claimStatuses);
-
-    /// @notice Claims the rewards of the provided redeem request ids
-    /// @param _redeemRequestIds The list of redeem requests to claim
-    /// @param _withdrawalEventIds The list of withdrawal events to use for every redeem request claim
-    /// @return claimStatuses The list of claim statuses. 0 for fully claimed, 1 for partially claimed, 2 for skipped
-    function claimRedeemRequests(uint32[] calldata _redeemRequestIds, uint32[] calldata _withdrawalEventIds)
-        external
-        returns (uint8[] memory claimStatuses);
-
-    /// @notice Reports a withdraw event from River
-    /// @param _lsETHWithdrawable The amount of LsETH that can be redeemed due to this new withdraw event
-    function reportWithdraw(uint256 _lsETHWithdrawable) external payable;
-
-    /// @notice Pulls exceeding buffer eth
-    /// @param _max The maximum amount that should be pulled
-    function pullExceedingEth(uint256 _max) external;
-}
diff -ruN src/interfaces/IRiver.1.sol interfaces/IRiver.1.sol
--- src/interfaces/IRiver.1.sol	2023-12-11 15:38:07
+++ interfaces/IRiver.1.sol	2024-01-16 15:06:39
@@ -1,271 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../state/river/DailyCommittableLimits.sol";
-
-import "./components/IConsensusLayerDepositManager.1.sol";
-import "./components/IOracleManager.1.sol";
-import "./components/ISharesManager.1.sol";
-import "./components/IUserDepositManager.1.sol";
-
-/// @title River Interface (v1)
-/// @author Kiln
-/// @notice The main system interface
-interface IRiverV1 is IConsensusLayerDepositManagerV1, IUserDepositManagerV1, ISharesManagerV1, IOracleManagerV1 {
-    /// @notice Funds have been pulled from the Execution Layer Fee Recipient
-    /// @param amount The amount pulled
-    event PulledELFees(uint256 amount);
-
-    /// @notice Funds have been pulled from the Coverage Fund
-    /// @param amount The amount pulled
-    event PulledCoverageFunds(uint256 amount);
-
-    /// @notice Emitted when funds are pulled from the redeem manager
-    /// @param amount The amount pulled
-    event PulledRedeemManagerExceedingEth(uint256 amount);
-
-    /// @notice Emitted when funds are pulled from the CL recipient
-    /// @param pulledSkimmedEthAmount The amount of skimmed ETH pulled
-    /// @param pullExitedEthAmount The amount of exited ETH pulled
-    event PulledCLFunds(uint256 pulledSkimmedEthAmount, uint256 pullExitedEthAmount);
-
-    /// @notice The stored Execution Layer Fee Recipient has been changed
-    /// @param elFeeRecipient The new Execution Layer Fee Recipient
-    event SetELFeeRecipient(address indexed elFeeRecipient);
-
-    /// @notice The stored Coverage Fund has been changed
-    /// @param coverageFund The new Coverage Fund
-    event SetCoverageFund(address indexed coverageFund);
-
-    /// @notice The stored Collector has been changed
-    /// @param collector The new Collector
-    event SetCollector(address indexed collector);
-
-    /// @notice The stored Allowlist has been changed
-    /// @param allowlist The new Allowlist
-    event SetAllowlist(address indexed allowlist);
-
-    /// @notice The stored Global Fee has been changed
-    /// @param fee The new Global Fee
-    event SetGlobalFee(uint256 fee);
-
-    /// @notice The stored Operators Registry has been changed
-    /// @param operatorRegistry The new Operators Registry
-    event SetOperatorsRegistry(address indexed operatorRegistry);
-
-    /// @notice The stored Metadata URI string has been changed
-    /// @param metadataURI The new Metadata URI string
-    event SetMetadataURI(string metadataURI);
-
-    /// @notice The system underlying supply increased. This is a snapshot of the balances for accounting purposes
-    /// @param _collector The address of the collector during this event
-    /// @param _oldTotalUnderlyingBalance Old total ETH balance under management by River
-    /// @param _oldTotalSupply Old total supply in shares
-    /// @param _newTotalUnderlyingBalance New total ETH balance under management by River
-    /// @param _newTotalSupply New total supply in shares
-    event RewardsEarned(
-        address indexed _collector,
-        uint256 _oldTotalUnderlyingBalance,
-        uint256 _oldTotalSupply,
-        uint256 _newTotalUnderlyingBalance,
-        uint256 _newTotalSupply
-    );
-
-    /// @notice Emitted when the daily committable limits are changed
-    /// @param minNetAmount The minimum amount that must be used as the daily committable amount
-    /// @param maxRelativeAmount The maximum amount that can be used as the daily committable amount, relative to the total underlying supply
-    event SetMaxDailyCommittableAmounts(uint256 minNetAmount, uint256 maxRelativeAmount);
-
-    /// @notice Emitted when the redeem manager address is changed
-    /// @param redeemManager The address of the redeem manager
-    event SetRedeemManager(address redeemManager);
-
-    /// @notice Emitted when the balance to deposit is updated
-    /// @param oldAmount The old balance to deposit
-    /// @param newAmount The new balance to deposit
-    event SetBalanceToDeposit(uint256 oldAmount, uint256 newAmount);
-
-    /// @notice Emitted when the balance to redeem is updated
-    /// @param oldAmount The old balance to redeem
-    /// @param newAmount The new balance to redeem
-    event SetBalanceToRedeem(uint256 oldAmount, uint256 newAmount);
-
-    /// @notice Emitted when the balance committed to deposit
-    /// @param oldAmount The old balance committed to deposit
-    /// @param newAmount The new balance committed to deposit
-    event SetBalanceCommittedToDeposit(uint256 oldAmount, uint256 newAmount);
-
-    /// @notice Emitted when the redeem manager received a withdraw event report
-    /// @param redeemManagerDemand The total demand in LsETH of the redeem manager
-    /// @param suppliedRedeemManagerDemand The amount of LsETH demand actually supplied
-    /// @param suppliedRedeemManagerDemandInEth The amount in ETH of the supplied demand
-    event ReportedRedeemManager(
-        uint256 redeemManagerDemand, uint256 suppliedRedeemManagerDemand, uint256 suppliedRedeemManagerDemandInEth
-    );
-
-    /// @notice Thrown when the amount received from the Withdraw contract doe not match the requested amount
-    /// @param requested The amount that was requested
-    /// @param received The amount that was received
-    error InvalidPulledClFundsAmount(uint256 requested, uint256 received);
-
-    /// @notice The computed amount of shares to mint is 0
-    error ZeroMintedShares();
-
-    /// @notice The access was denied
-    /// @param account The account that was denied
-    error Denied(address account);
-
-    /// @notice Initializes the River system
-    /// @param _depositContractAddress Address to make Consensus Layer deposits
-    /// @param _elFeeRecipientAddress Address that receives the execution layer fees
-    /// @param _withdrawalCredentials Credentials to use for every validator deposit
-    /// @param _oracleAddress The address of the Oracle contract
-    /// @param _systemAdministratorAddress Administrator address
-    /// @param _allowlistAddress Address of the allowlist contract
-    /// @param _operatorRegistryAddress Address of the operator registry
-    /// @param _collectorAddress Address receiving the the global fee on revenue
-    /// @param _globalFee Amount retained when the ETH balance increases and sent to the collector
-    function initRiverV1(
-        address _depositContractAddress,
-        address _elFeeRecipientAddress,
-        bytes32 _withdrawalCredentials,
-        address _oracleAddress,
-        address _systemAdministratorAddress,
-        address _allowlistAddress,
-        address _operatorRegistryAddress,
-        address _collectorAddress,
-        uint256 _globalFee
-    ) external;
-
-    /// @notice Initialized version 1.1 of the River System
-    /// @param _redeemManager The redeem manager address
-    /// @param _epochsPerFrame The amounts of epochs in a frame
-    /// @param _slotsPerEpoch The slots inside an epoch
-    /// @param _secondsPerSlot The seconds inside a slot
-    /// @param _genesisTime The genesis timestamp
-    /// @param _epochsToAssumedFinality The number of epochs before an epoch is considered final on-chain
-    /// @param _annualAprUpperBound The reporting upper bound
-    /// @param _relativeLowerBound The reporting lower bound
-    /// @param _maxDailyNetCommittableAmount_ The net daily committable limit
-    /// @param _maxDailyRelativeCommittableAmount_ The relative daily committable limit
-    function initRiverV1_1(
-        address _redeemManager,
-        uint64 _epochsPerFrame,
-        uint64 _slotsPerEpoch,
-        uint64 _secondsPerSlot,
-        uint64 _genesisTime,
-        uint64 _epochsToAssumedFinality,
-        uint256 _annualAprUpperBound,
-        uint256 _relativeLowerBound,
-        uint128 _maxDailyNetCommittableAmount_,
-        uint128 _maxDailyRelativeCommittableAmount_
-    ) external;
-
-    /// @notice Initializes version 1.2 of the River System
-    function initRiverV1_2() external;
-
-    /// @notice Get the current global fee
-    /// @return The global fee
-    function getGlobalFee() external view returns (uint256);
-
-    /// @notice Retrieve the allowlist address
-    /// @return The allowlist address
-    function getAllowlist() external view returns (address);
-
-    /// @notice Retrieve the collector address
-    /// @return The collector address
-    function getCollector() external view returns (address);
-
-    /// @notice Retrieve the execution layer fee recipient
-    /// @return The execution layer fee recipient address
-    function getELFeeRecipient() external view returns (address);
-
-    /// @notice Retrieve the coverage fund
-    /// @return The coverage fund address
-    function getCoverageFund() external view returns (address);
-
-    /// @notice Retrieve the redeem manager
-    /// @return The redeem manager address
-    function getRedeemManager() external view returns (address);
-
-    /// @notice Retrieve the operators registry
-    /// @return The operators registry address
-    function getOperatorsRegistry() external view returns (address);
-
-    /// @notice Retrieve the metadata uri string value
-    /// @return The metadata uri string value
-    function getMetadataURI() external view returns (string memory);
-
-    /// @notice Retrieve the configured daily committable limits
-    /// @return The daily committable limits structure
-    function getDailyCommittableLimits()
-        external
-        view
-        returns (DailyCommittableLimits.DailyCommittableLimitsStruct memory);
-
-    /// @notice Resolves the provided redeem requests by calling the redeem manager
-    /// @param _redeemRequestIds The list of redeem requests to resolve
-    /// @return withdrawalEventIds The list of matching withdrawal events, or error codes
-    function resolveRedeemRequests(uint32[] calldata _redeemRequestIds)
-        external
-        view
-        returns (int64[] memory withdrawalEventIds);
-
-    /// @notice Set the daily committable limits
-    /// @param _dcl The Daily Committable Limits structure
-    function setDailyCommittableLimits(DailyCommittableLimits.DailyCommittableLimitsStruct memory _dcl) external;
-
-    /// @notice Retrieve the current balance to redeem
-    /// @return The current balance to redeem
-    function getBalanceToRedeem() external view returns (uint256);
-
-    /// @notice Performs a redeem request on the redeem manager
-    /// @param _lsETHAmount The amount of LsETH to redeem
-    /// @param _recipient The address that will own the redeem request
-    /// @return redeemRequestId The ID of the newly created redeem request
-    function requestRedeem(uint256 _lsETHAmount, address _recipient) external returns (uint32 redeemRequestId);
-
-    /// @notice Claims several redeem requests
-    /// @param _redeemRequestIds The list of redeem requests to claim
-    /// @param _withdrawalEventIds The list of resolved withdrawal event ids
-    /// @return claimStatuses The operation status results
-    function claimRedeemRequests(uint32[] calldata _redeemRequestIds, uint32[] calldata _withdrawalEventIds)
-        external
-        returns (uint8[] memory claimStatuses);
-
-    /// @notice Changes the global fee parameter
-    /// @param _newFee New fee value
-    function setGlobalFee(uint256 _newFee) external;
-
-    /// @notice Changes the allowlist address
-    /// @param _newAllowlist New address for the allowlist
-    function setAllowlist(address _newAllowlist) external;
-
-    /// @notice Changes the collector address
-    /// @param _newCollector New address for the collector
-    function setCollector(address _newCollector) external;
-
-    /// @notice Changes the execution layer fee recipient
-    /// @param _newELFeeRecipient New address for the recipient
-    function setELFeeRecipient(address _newELFeeRecipient) external;
-
-    /// @notice Changes the coverage fund
-    /// @param _newCoverageFund New address for the fund
-    function setCoverageFund(address _newCoverageFund) external;
-
-    /// @notice Sets the metadata uri string value
-    /// @param _metadataURI The new metadata uri string value
-    function setMetadataURI(string memory _metadataURI) external;
-
-    /// @notice Input for execution layer fee earnings
-    function sendELFees() external payable;
-
-    /// @notice Input for consensus layer funds, containing both exit and skimming
-    function sendCLFunds() external payable;
-
-    /// @notice Input for coverage funds
-    function sendCoverageFunds() external payable;
-
-    /// @notice Input for the redeem manager funds
-    function sendRedeemManagerExceedingFunds() external payable;
-}
diff -ruN src/interfaces/ITLC.1.sol interfaces/ITLC.1.sol
--- src/interfaces/ITLC.1.sol	2023-12-11 15:38:07
+++ interfaces/ITLC.1.sol	2024-01-16 15:06:39
@@ -1,19 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol";
-import "openzeppelin-contracts-upgradeable/contracts/governance/utils/IVotesUpgradeable.sol";
-
-import "./components/IERC20VestableVotesUpgradeable.1.sol";
-
-/// @title TLC Interface (v1)
-/// @author Alluvial
-/// @notice TLC token interface
-interface ITLCV1 is IERC20Upgradeable, IVotesUpgradeable, IERC20VestableVotesUpgradeableV1 {
-    /// @notice Initializes the TLC Token
-    /// @param _account The initial account to grant all the minted tokens
-    function initTLCV1(address _account) external;
-
-    /// @notice Migrates the vesting schedule state structures
-    function migrateVestingSchedules() external;
-}
diff -ruN src/interfaces/IWLSETH.1.sol interfaces/IWLSETH.1.sol
--- src/interfaces/IWLSETH.1.sol	2023-12-11 15:38:07
+++ interfaces/IWLSETH.1.sol	2024-01-16 15:06:39
@@ -1,138 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Wrapped LsETH Interface (v1)
-/// @author Kiln
-/// @notice This interface exposes methods to wrap the LsETH token into a rebase token.
-interface IWLSETHV1 {
-    /// @notice A transfer has been made
-    /// @param from The transfer sender
-    /// @param to The transfer recipient
-    /// @param value The amount transfered
-    event Transfer(address indexed from, address indexed to, uint256 value);
-
-    /// @notice An approval has been made
-    /// @param owner The token owner
-    /// @param spender The account allowed by the owner
-    /// @param value The amount allowed
-    event Approval(address indexed owner, address indexed spender, uint256 value);
-
-    /// @notice Tokens have been minted
-    /// @param recipient The account receiving the new tokens
-    /// @param shares The amount of LsETH provided
-    event Mint(address indexed recipient, uint256 shares);
-
-    /// @notice Tokens have been burned
-    /// @param recipient The account that receive the underlying LsETH
-    /// @param shares The amount of LsETH that got sent back
-    event Burn(address indexed recipient, uint256 shares);
-
-    /// @notice The stored value of river has been changed
-    /// @param river The new address of river
-    event SetRiver(address indexed river);
-
-    /// @notice The token transfer failed during the minting or burning process
-    error TokenTransferError();
-
-    /// @notice Balance too low to perform operation
-    error BalanceTooLow();
-
-    /// @notice Allowance too low to perform operation
-    /// @param _from Account where funds are sent from
-    /// @param _operator Account attempting the transfer
-    /// @param _allowance Current allowance
-    /// @param _value Requested transfer value
-    error AllowanceTooLow(address _from, address _operator, uint256 _allowance, uint256 _value);
-
-    /// @notice Invalid empty transfer
-    error NullTransfer();
-
-    /// @notice Invalid transfer recipients
-    /// @param _from Account sending the funds in the invalid transfer
-    /// @param _to Account receiving the funds in the invalid transfer
-    error UnauthorizedTransfer(address _from, address _to);
-
-    /// @notice Initializes the wrapped token contract
-    /// @param _river Address of the River contract
-    function initWLSETHV1(address _river) external;
-
-    /// @notice Retrieves the token full name
-    /// @return The name of the token
-    function name() external pure returns (string memory);
-
-    /// @notice Retrieves the token symbol
-    /// @return The symbol of the token
-    function symbol() external pure returns (string memory);
-
-    /// @notice Retrieves the token decimal count
-    /// @return The decimal count
-    function decimals() external pure returns (uint8);
-
-    /// @notice Retrieves the token total supply
-    /// @return The total supply
-    function totalSupply() external view returns (uint256);
-
-    /// @notice Retrieves the token balance of the specified user
-    /// @param _owner Owner to check the balance
-    /// @return The balance of the owner
-    function balanceOf(address _owner) external view returns (uint256);
-
-    /// @notice Retrieves the raw shares count of the user
-    /// @param _owner Owner to check the shares balance
-    /// @return The shares of the owner
-    function sharesOf(address _owner) external view returns (uint256);
-
-    /// @notice Retrieves the token allowance given from one address to another
-    /// @param _owner Owner that gave the allowance
-    /// @param _spender Spender that received the allowance
-    /// @return The allowance of the owner to the spender
-    function allowance(address _owner, address _spender) external view returns (uint256);
-
-    /// @notice Transfers tokens between the message sender and a recipient
-    /// @param _to Recipient of the transfer
-    /// @param _value Amount to transfer
-    /// @return True if success
-    function transfer(address _to, uint256 _value) external returns (bool);
-
-    /// @notice Transfers tokens between two accounts
-    /// @dev It is expected that _from has given at least _value allowance to msg.sender
-    /// @param _from Sender account
-    /// @param _to Recipient of the transfer
-    /// @param _value Amount to transfer
-    /// @return True if success
-    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);
-
-    /// @notice Approves another account to transfer tokens
-    /// @param _spender Spender that receives the allowance
-    /// @param _value Amount to allow
-    /// @return True if success
-    function approve(address _spender, uint256 _value) external returns (bool);
-
-    /// @notice Increase allowance to another account
-    /// @param _spender Spender that receives the allowance
-    /// @param _additionalValue Amount to add
-    /// @return True if success
-    function increaseAllowance(address _spender, uint256 _additionalValue) external returns (bool);
-
-    /// @notice Decrease allowance to another account
-    /// @param _spender Spender that receives the allowance
-    /// @param _subtractableValue Amount to subtract
-    /// @return True if success
-    function decreaseAllowance(address _spender, uint256 _subtractableValue) external returns (bool);
-
-    /// @notice Mint tokens by providing LsETH tokens
-    /// @dev The message sender locks LsETH tokens and received wrapped LsETH tokens in exchange
-    /// @dev The message sender needs to approve the contract to mint the wrapped tokens
-    /// @dev The minted wrapped LsETH is sent to the specified recipient
-    /// @param _recipient The account receiving the new minted wrapped LsETH
-    /// @param _shares The amount of LsETH to wrap
-    function mint(address _recipient, uint256 _shares) external;
-
-    /// @notice Burn tokens and retrieve underlying LsETH tokens
-    /// @dev The message sender burns shares from its balance for the LsETH equivalent value
-    /// @dev The message sender doesn't need to approve the contract to burn the shares
-    /// @dev The freed LsETH is sent to the specified recipient
-    /// @param _recipient The account receiving the underlying LsETH tokens after shares are burned
-    /// @param _shares Amount of LsETH to free by burning wrapped LsETH
-    function burn(address _recipient, uint256 _shares) external;
-}
diff -ruN src/interfaces/IWithdraw.1.sol interfaces/IWithdraw.1.sol
--- src/interfaces/IWithdraw.1.sol	2023-12-11 15:38:07
+++ interfaces/IWithdraw.1.sol	2024-01-16 15:06:39
@@ -1,26 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Withdraw Interface (V1)
-/// @author Kiln
-/// @notice This contract is in charge of holding the exit and skimming funds and allow river to pull these funds
-interface IWithdrawV1 {
-    /// @notice Emitted when the linked River address is changed
-    /// @param river The new River address
-    event SetRiver(address river);
-
-    /// @param _river The address of the River contract
-    function initializeWithdrawV1(address _river) external;
-
-    /// @notice Retrieve the withdrawal credentials to use
-    /// @return The withdrawal credentials
-    function getCredentials() external view returns (bytes32);
-
-    /// @notice Retrieve the linked River address
-    /// @return The River address
-    function getRiver() external view returns (address);
-
-    /// @notice Callable by River, sends the specified amount of ETH to River
-    /// @param _amount The amount to pull
-    function pullEth(uint256 _amount) external;
-}
diff -ruN src/interfaces/components/IConsensusLayerDepositManager.1.sol interfaces/components/IConsensusLayerDepositManager.1.sol
--- src/interfaces/components/IConsensusLayerDepositManager.1.sol	2023-12-11 15:38:07
+++ interfaces/components/IConsensusLayerDepositManager.1.sol	2024-01-16 15:06:39
@@ -1,64 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Consensys Layer Deposit Manager Interface (v1)
-/// @author Kiln
-/// @notice This interface exposes methods to handle the interactions with the official deposit contract
-interface IConsensusLayerDepositManagerV1 {
-    /// @notice The stored deposit contract address changed
-    /// @param depositContract Address of the deposit contract
-    event SetDepositContractAddress(address indexed depositContract);
-
-    /// @notice The stored withdrawal credentials changed
-    /// @param withdrawalCredentials The withdrawal credentials to use for deposits
-    event SetWithdrawalCredentials(bytes32 withdrawalCredentials);
-
-    /// @notice Emitted when the deposited validator count is updated
-    /// @param oldDepositedValidatorCount The old deposited validator count value
-    /// @param newDepositedValidatorCount The new deposited validator count value
-    event SetDepositedValidatorCount(uint256 oldDepositedValidatorCount, uint256 newDepositedValidatorCount);
-
-    /// @notice Not enough funds to deposit one validator
-    error NotEnoughFunds();
-
-    /// @notice The length of the BLS Public key is invalid during deposit
-    error InconsistentPublicKeys();
-
-    /// @notice The length of the BLS Signature is invalid during deposit
-    error InconsistentSignatures();
-
-    /// @notice The internal key retrieval returned no keys
-    error NoAvailableValidatorKeys();
-
-    /// @notice The received count of public keys to deposit is invalid
-    error InvalidPublicKeyCount();
-
-    /// @notice The received count of signatures to deposit is invalid
-    error InvalidSignatureCount();
-
-    /// @notice The withdrawal credentials value is null
-    error InvalidWithdrawalCredentials();
-
-    /// @notice An error occured during the deposit
-    error ErrorOnDeposit();
-
-    /// @notice Returns the amount of ETH not yet committed for deposit
-    /// @return The amount of ETH not yet committed for deposit
-    function getBalanceToDeposit() external view returns (uint256);
-
-    /// @notice Returns the amount of ETH committed for deposit
-    /// @return The amount of ETH committed for deposit
-    function getCommittedBalance() external view returns (uint256);
-
-    /// @notice Retrieve the withdrawal credentials
-    /// @return The withdrawal credentials
-    function getWithdrawalCredentials() external view returns (bytes32);
-
-    /// @notice Get the deposited validator count (the count of deposits made by the contract)
-    /// @return The deposited validator count
-    function getDepositedValidatorCount() external view returns (uint256);
-
-    /// @notice Deposits current balance to the Consensus Layer by batches of 32 ETH
-    /// @param _maxCount The maximum amount of validator keys to fund
-    function depositToConsensusLayer(uint256 _maxCount) external;
-}
diff -ruN src/interfaces/components/IERC20VestableVotesUpgradeable.1.sol interfaces/components/IERC20VestableVotesUpgradeable.1.sol
--- src/interfaces/components/IERC20VestableVotesUpgradeable.1.sol	2023-12-11 15:38:07
+++ interfaces/components/IERC20VestableVotesUpgradeable.1.sol	2024-01-16 15:06:39
@@ -1,140 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../state/tlc/VestingSchedules.2.sol";
-
-/// @title ERC20 Vestable Votes Upgradeable Interface(v1)
-/// @author Alluvial
-/// @notice This interface exposes methods to manage vestings
-interface IERC20VestableVotesUpgradeableV1 {
-    /// @notice A new vesting schedule has been created
-    /// @param index Vesting schedule index
-    /// @param creator Creator of the vesting schedule
-    /// @param beneficiary Vesting beneficiary address
-    /// @param amount Vesting schedule amount
-    event CreatedVestingSchedule(uint256 index, address indexed creator, address indexed beneficiary, uint256 amount);
-
-    /// @notice Vesting schedule has been released
-    /// @param index Vesting schedule index
-    /// @param releasedAmount Amount of tokens released to the beneficiary
-    event ReleasedVestingSchedule(uint256 index, uint256 releasedAmount);
-
-    /// @notice Vesting schedule has been revoked
-    /// @param index Vesting schedule index
-    /// @param returnedAmount Amount of tokens returned to the creator
-    /// @param newEnd New end timestamp after revoke action
-    event RevokedVestingSchedule(uint256 index, uint256 returnedAmount, uint256 newEnd);
-
-    /// @notice Vesting escrow has been delegated
-    /// @param index Vesting schedule index
-    /// @param oldDelegatee old delegatee
-    /// @param newDelegatee new delegatee
-    /// @param beneficiary vesting schedule beneficiary
-    event DelegatedVestingEscrow(
-        uint256 index, address indexed oldDelegatee, address indexed newDelegatee, address indexed beneficiary
-    );
-
-    /// @notice Vesting schedule creator has unsufficient balance to create vesting schedule
-    error UnsufficientVestingScheduleCreatorBalance();
-
-    /// @notice Invalid parameter for a vesting schedule
-    error InvalidVestingScheduleParameter(string msg);
-
-    /// @notice Attempt to revoke a schedule in the past
-    error VestingScheduleNotRevocableInPast();
-
-    /// @notice The vesting schedule is not revocable
-    error VestingScheduleNotRevocable();
-
-    /// @notice The vesting schedule is locked
-    error VestingScheduleIsLocked();
-
-    /// @notice Attempt to revoke a vesting schedule with an invalid end parameter
-    error InvalidRevokedVestingScheduleEnd();
-
-    /// @notice No token to release
-    error ZeroReleasableAmount();
-
-    /// @notice Underflow in global unlock logic (should never happen)
-    error GlobalUnlockUnderlfow();
-
-    /// @notice Get vesting schedule
-    /// @dev The vesting schedule structure represents a static configuration used to compute the desired
-    /// @dev vesting details of a beneficiary at all times. The values won't change even after tokens are released.
-    /// @dev The only dynamic field of the structure is end, and is updated whenever a vesting schedule is revoked
-    /// @param _index Index of the vesting schedule
-    function getVestingSchedule(uint256 _index) external view returns (VestingSchedulesV2.VestingSchedule memory);
-
-    /// @notice Get vesting global unlock schedule activation status for a vesting schedule
-    /// @param _index Index of the vesting schedule
-    /// @return true if the vesting schedule should ignore the global unlock schedule
-    function isGlobalUnlockedScheduleIgnored(uint256 _index) external view returns (bool);
-
-    /// @notice Get count of vesting schedules
-    /// @return count of vesting schedules
-    function getVestingScheduleCount() external view returns (uint256);
-
-    /// @notice Get the address of the escrow for a vesting schedule
-    /// @param _index Index of the vesting schedule
-    /// @return address of the escrow
-    function vestingEscrow(uint256 _index) external view returns (address);
-
-    /// @notice Computes the releasable amount of tokens for a vesting schedule.
-    /// @param _index index of the vesting schedule
-    /// @return amount of releasable tokens
-    function computeVestingReleasableAmount(uint256 _index) external view returns (uint256);
-
-    /// @notice Computes the vested amount of tokens for a vesting schedule.
-    /// @param _index index of the vesting schedule
-    /// @return amount of vested tokens
-    function computeVestingVestedAmount(uint256 _index) external view returns (uint256);
-
-    /// @notice Creates a new vesting schedule
-    /// @notice There may delay between the time a user should start vesting tokens and the time the vesting schedule is actually created on the contract.
-    /// @notice Typically a user joins the Liquid Collective but some weeks pass before the user gets all legal agreements in place and signed for the
-    /// @notice token grant emission to happen. In this case, the vesting schedule created for the token grant would start on the join date which is in the past.
-    /// @dev As vesting schedules can be created in the past, this means that you should be careful when creating a vesting schedule and what duration parameters
-    /// @dev you use as this contract would allow creating a vesting schedule in the past and even a vesting schedule that has already ended.
-    /// @param _start start time of the vesting
-    /// @param _cliffDuration duration to vesting cliff (in seconds)
-    /// @param _duration total vesting schedule duration after which all tokens are vested (in seconds)
-    /// @param _periodDuration duration of a period after which new tokens unlock (in seconds)
-    /// @param _lockDuration duration during which tokens are locked (in seconds)
-    /// @param _revocable whether the vesting schedule is revocable or not
-    /// @param _amount amount of token attributed by the vesting schedule
-    /// @param _beneficiary address of the beneficiary of the tokens
-    /// @param _delegatee address to delegate escrow voting power to
-    /// @param _ignoreGlobalUnlockSchedule whether the vesting schedule should ignore the global lock
-    /// @return index of the created vesting schedule
-    function createVestingSchedule(
-        uint64 _start,
-        uint32 _cliffDuration,
-        uint32 _duration,
-        uint32 _periodDuration,
-        uint32 _lockDuration,
-        bool _revocable,
-        uint256 _amount,
-        address _beneficiary,
-        address _delegatee,
-        bool _ignoreGlobalUnlockSchedule
-    ) external returns (uint256);
-
-    /// @notice Revoke vesting schedule
-    /// @param _index Index of the vesting schedule to revoke
-    /// @param _end End date for the schedule
-    /// @return returnedAmount amount returned to the vesting schedule creator
-    function revokeVestingSchedule(uint256 _index, uint64 _end) external returns (uint256 returnedAmount);
-
-    /// @notice Release vesting schedule
-    /// @notice When tokens are released from the escrow, the delegated address of the escrow will see its voting power decrease.
-    /// @notice The beneficiary has to make sure its delegation parameters are set properly to be able to use/delegate the voting power of its balance.
-    /// @param _index Index of the vesting schedule to release
-    /// @return released amount
-    function releaseVestingSchedule(uint256 _index) external returns (uint256);
-
-    /// @notice Delegate vesting escrowed tokens
-    /// @param _index index of the vesting schedule
-    /// @param _delegatee address to delegate the token to
-    /// @return True on success
-    function delegateVestingEscrow(uint256 _index, address _delegatee) external returns (bool);
-}
diff -ruN src/interfaces/components/IOracleManager.1.sol interfaces/components/IOracleManager.1.sol
--- src/interfaces/components/IOracleManager.1.sol	2023-12-11 15:38:07
+++ interfaces/components/IOracleManager.1.sol	2024-01-16 15:06:39
@@ -1,237 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../state/river/CLSpec.sol";
-import "../../state/river/ReportBounds.sol";
-
-/// @title Oracle Manager (v1)
-/// @author Kiln
-/// @notice This interface exposes methods to handle the inputs provided by the oracle
-interface IOracleManagerV1 {
-    /// @notice The stored oracle address changed
-    /// @param oracleAddress The new oracle address
-    event SetOracle(address indexed oracleAddress);
-
-    /// @notice The consensus layer data provided by the oracle has been updated
-    /// @param validatorCount The new count of validators running on the consensus layer
-    /// @param validatorTotalBalance The new total balance sum of all validators
-    /// @param roundId Round identifier
-    event ConsensusLayerDataUpdate(uint256 validatorCount, uint256 validatorTotalBalance, bytes32 roundId);
-
-    /// @notice The Consensus Layer Spec is changed
-    /// @param epochsPerFrame The number of epochs inside a frame
-    /// @param slotsPerEpoch The number of slots inside an epoch
-    /// @param secondsPerSlot The number of seconds inside a slot
-    /// @param genesisTime The genesis timestamp
-    /// @param epochsToAssumedFinality The number of epochs before an epoch is considered final
-    event SetSpec(
-        uint64 epochsPerFrame,
-        uint64 slotsPerEpoch,
-        uint64 secondsPerSlot,
-        uint64 genesisTime,
-        uint64 epochsToAssumedFinality
-    );
-
-    /// @notice The Report Bounds are changed
-    /// @param annualAprUpperBound The reporting upper bound
-    /// @param relativeLowerBound The reporting lower bound
-    event SetBounds(uint256 annualAprUpperBound, uint256 relativeLowerBound);
-
-    /// @notice The provided report has beend processed
-    /// @param report The report that was provided
-    /// @param trace The trace structure providing more insights on internals
-    event ProcessedConsensusLayerReport(
-        IOracleManagerV1.ConsensusLayerReport report, ConsensusLayerDataReportingTrace trace
-    );
-
-    /// @notice The reported validator count is invalid
-    /// @param providedValidatorCount The received validator count value
-    /// @param depositedValidatorCount The number of deposits performed by the system
-    /// @param lastReportedValidatorCount The last reported validator count
-    error InvalidValidatorCountReport(
-        uint256 providedValidatorCount, uint256 depositedValidatorCount, uint256 lastReportedValidatorCount
-    );
-
-    /// @notice Thrown when an invalid epoch was reported
-    /// @param epoch Invalid epoch
-    error InvalidEpoch(uint256 epoch);
-
-    /// @notice The balance increase is higher than the maximum allowed by the upper bound
-    /// @param prevTotalEthIncludingExited The previous total balance, including all exited balance
-    /// @param postTotalEthIncludingExited The post-report total balance, including all exited balance
-    /// @param timeElapsed The time in seconds since last report
-    /// @param annualAprUpperBound The upper bound value that was used
-    error TotalValidatorBalanceIncreaseOutOfBound(
-        uint256 prevTotalEthIncludingExited,
-        uint256 postTotalEthIncludingExited,
-        uint256 timeElapsed,
-        uint256 annualAprUpperBound
-    );
-
-    /// @notice The balance decrease is higher than the maximum allowed by the lower bound
-    /// @param prevTotalEthIncludingExited The previous total balance, including all exited balance
-    /// @param postTotalEthIncludingExited The post-report total balance, including all exited balance
-    /// @param timeElapsed The time in seconds since last report
-    /// @param relativeLowerBound The lower bound value that was used
-    error TotalValidatorBalanceDecreaseOutOfBound(
-        uint256 prevTotalEthIncludingExited,
-        uint256 postTotalEthIncludingExited,
-        uint256 timeElapsed,
-        uint256 relativeLowerBound
-    );
-
-    /// @notice The total exited balance decreased
-    /// @param currentValidatorsExitedBalance The current exited balance
-    /// @param newValidatorsExitedBalance The new exited balance
-    error InvalidDecreasingValidatorsExitedBalance(
-        uint256 currentValidatorsExitedBalance, uint256 newValidatorsExitedBalance
-    );
-
-    /// @notice The total skimmed balance decreased
-    /// @param currentValidatorsSkimmedBalance The current exited balance
-    /// @param newValidatorsSkimmedBalance The new exited balance
-    error InvalidDecreasingValidatorsSkimmedBalance(
-        uint256 currentValidatorsSkimmedBalance, uint256 newValidatorsSkimmedBalance
-    );
-
-    /// @notice Trace structure emitted via logs during reporting
-    struct ConsensusLayerDataReportingTrace {
-        uint256 rewards;
-        uint256 pulledELFees;
-        uint256 pulledRedeemManagerExceedingEthBuffer;
-        uint256 pulledCoverageFunds;
-    }
-
-    /// @notice The format of the oracle report
-    struct ConsensusLayerReport {
-        // this is the epoch at which the report was performed
-        // data should be fetched up to the state of this epoch by the oracles
-        uint256 epoch;
-        // the sum of all the validator balances on the consensus layer
-        // when a validator enters the exit queue, the validator is considered stopped, its balance is accounted in both validatorsExitingBalance and validatorsBalance
-        // when a validator leaves the exit queue and the funds are sweeped onto the execution layer, the balance is only accounted in validatorsExitedBalance and not in validatorsBalance
-        // this value can decrease between reports
-        uint256 validatorsBalance;
-        // the sum of all the skimmings performed on the validators
-        // these values can be found in the execution layer block bodies under the withdrawals field
-        // a withdrawal is considered skimming if
-        // - the epoch at which it happened is < validator.withdrawableEpoch
-        // - the epoch at which it happened is >= validator.withdrawableEpoch and in that case we only account for what would be above 32 eth as skimming
-        // this value cannot decrease over reports
-        uint256 validatorsSkimmedBalance;
-        // the sum of all the exits performed on the validators
-        // these values can be found in the execution layer block bodies under the withdrawals field
-        // a withdrawal is considered exit if
-        // - the epoch at which it happened is >= validator.withdrawableEpoch and in that case we only account for what would be <= 32 eth as exit
-        // this value cannot decrease over reports
-        uint256 validatorsExitedBalance;
-        // the sum of all the exiting balance, which is all the validators on their way to get sweeped and exited
-        // this includes voluntary exits and slashings
-        // this value can decrease between reports
-        uint256 validatorsExitingBalance;
-        // the count of activated validators
-        // even validators that are exited are still accounted
-        // this value cannot decrease over reports
-        uint32 validatorsCount;
-        // an array containing the count of stopped validators per operator
-        // the first element of the array is the sum of all stopped validators
-        // then index 1 would be operator 0
-        // these values cannot decrease over reports
-        uint32[] stoppedValidatorCountPerOperator;
-        // flag enabled by the oracles when the buffer rebalancing is activated
-        // the activation logic is written in the oracle specification and all oracle members must agree on the activation
-        // when active, the eth in the deposit buffer can be used to pay for exits in the redeem manager
-        bool rebalanceDepositToRedeemMode;
-        // flag enabled by the oracles when the slashing containment is activated
-        // the activation logic is written in the oracle specification and all oracle members must agree on the activation
-        // This flag is activated when a pre-defined threshold of slashed validators in our set of validators is reached
-        // This flag is deactivated when a bottom threshold is met, this means that when we reach the upper threshold and activate the flag, we will deactivate it when we reach the bottom threshold and not before
-        // when active, no more validator exits can be requested by the protocol
-        bool slashingContainmentMode;
-    }
-
-    /// @notice The format of the oracle report in storage
-    /// @notice These fields have the exact same function as the ones in ConsensusLayerReport, but this struct is optimized for storage
-    struct StoredConsensusLayerReport {
-        uint256 epoch;
-        uint256 validatorsBalance;
-        uint256 validatorsSkimmedBalance;
-        uint256 validatorsExitedBalance;
-        uint256 validatorsExitingBalance;
-        uint32 validatorsCount;
-        bool rebalanceDepositToRedeemMode;
-        bool slashingContainmentMode;
-    }
-
-    /// @notice Get oracle address
-    /// @return The oracle address
-    function getOracle() external view returns (address);
-
-    /// @notice Get CL validator total balance
-    /// @return The CL Validator total balance
-    function getCLValidatorTotalBalance() external view returns (uint256);
-
-    /// @notice Get CL validator count (the amount of validator reported by the oracles)
-    /// @return The CL validator count
-    function getCLValidatorCount() external view returns (uint256);
-
-    /// @notice Verifies if the provided epoch is valid
-    /// @param epoch The epoch to lookup
-    /// @return True if valid
-    function isValidEpoch(uint256 epoch) external view returns (bool);
-
-    /// @notice Retrieve the block timestamp
-    /// @return The current timestamp from the EVM context
-    function getTime() external view returns (uint256);
-
-    /// @notice Retrieve expected epoch id
-    /// @return The current expected epoch id
-    function getExpectedEpochId() external view returns (uint256);
-
-    /// @notice Retrieve the last completed epoch id
-    /// @return The last completed epoch id
-    function getLastCompletedEpochId() external view returns (uint256);
-
-    /// @notice Retrieve the current epoch id based on block timestamp
-    /// @return The current epoch id
-    function getCurrentEpochId() external view returns (uint256);
-
-    /// @notice Retrieve the current cl spec
-    /// @return The Consensus Layer Specification
-    function getCLSpec() external view returns (CLSpec.CLSpecStruct memory);
-
-    /// @notice Retrieve the current frame details
-    /// @return _startEpochId The epoch at the beginning of the frame
-    /// @return _startTime The timestamp of the beginning of the frame in seconds
-    /// @return _endTime The timestamp of the end of the frame in seconds
-    function getCurrentFrame() external view returns (uint256 _startEpochId, uint256 _startTime, uint256 _endTime);
-
-    /// @notice Retrieve the first epoch id of the frame of the provided epoch id
-    /// @param _epochId Epoch id used to get the frame
-    /// @return The first epoch id of the frame containing the given epoch id
-    function getFrameFirstEpochId(uint256 _epochId) external view returns (uint256);
-
-    /// @notice Retrieve the report bounds
-    /// @return The report bounds
-    function getReportBounds() external view returns (ReportBounds.ReportBoundsStruct memory);
-
-    /// @notice Retrieve the last consensus layer report
-    /// @return The stored consensus layer report
-    function getLastConsensusLayerReport() external view returns (IOracleManagerV1.StoredConsensusLayerReport memory);
-
-    /// @notice Set the oracle address
-    /// @param _oracleAddress Address of the oracle
-    function setOracle(address _oracleAddress) external;
-
-    /// @notice Set the consensus layer spec
-    /// @param _newValue The new consensus layer spec value
-    function setCLSpec(CLSpec.CLSpecStruct calldata _newValue) external;
-
-    /// @notice Set the report bounds
-    /// @param _newValue The new report bounds value
-    function setReportBounds(ReportBounds.ReportBoundsStruct calldata _newValue) external;
-
-    /// @notice Performs all the reporting logics
-    /// @param _report The consensus layer report structure
-    function setConsensusLayerData(ConsensusLayerReport calldata _report) external;
-}
diff -ruN src/interfaces/components/ISharesManager.1.sol interfaces/components/ISharesManager.1.sol
--- src/interfaces/components/ISharesManager.1.sol	2023-12-15 12:39:37
+++ interfaces/components/ISharesManager.1.sol	2024-01-16 15:06:39
@@ -1,108 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
-
-/// @title Shares Manager Interface (v1)
-/// @author Kiln
-/// @notice This interface exposes methods to handle the shares of the depositor and the ERC20 interface
-interface ISharesManagerV1 is IERC20 {
-    /// @notice Emitted when the total supply is changed
-    event SetTotalSupply(uint256 totalSupply);
-
-    /// @notice Balance too low to perform operation
-    error BalanceTooLow();
-
-    /// @notice Allowance too low to perform operation
-    /// @param _from Account where funds are sent from
-    /// @param _operator Account attempting the transfer
-    /// @param _allowance Current allowance
-    /// @param _value Requested transfer value in shares
-    error AllowanceTooLow(address _from, address _operator, uint256 _allowance, uint256 _value);
-
-    /// @notice Invalid empty transfer
-    error NullTransfer();
-
-    /// @notice Invalid transfer recipients
-    /// @param _from Account sending the funds in the invalid transfer
-    /// @param _to Account receiving the funds in the invalid transfer
-    error UnauthorizedTransfer(address _from, address _to);
-
-    /// @notice Retrieve the token name
-    /// @return The token name
-    function name() external pure returns (string memory);
-
-    /// @notice Retrieve the token symbol
-    /// @return The token symbol
-    function symbol() external pure returns (string memory);
-
-    /// @notice Retrieve the decimal count
-    /// @return The decimal count
-    function decimals() external pure returns (uint8);
-
-    /// @notice Retrieve the total token supply
-    /// @return The total supply in shares
-    function totalSupply() external view returns (uint256);
-
-    /// @notice Retrieve the total underlying asset supply
-    /// @return The total underlying asset supply
-    function totalUnderlyingSupply() external view returns (uint256);
-
-    /// @notice Retrieve the balance of an account
-    /// @param _owner Address to be checked
-    /// @return The balance of the account in shares
-    function balanceOf(address _owner) external view returns (uint256);
-
-    /// @notice Retrieve the underlying asset balance of an account
-    /// @param _owner Address to be checked
-    /// @return The underlying balance of the account
-    function balanceOfUnderlying(address _owner) external view returns (uint256);
-
-    /// @notice Retrieve the underlying asset balance from an amount of shares
-    /// @param _shares Amount of shares to convert
-    /// @return The underlying asset balance represented by the shares
-    function underlyingBalanceFromShares(uint256 _shares) external view returns (uint256);
-
-    /// @notice Retrieve the shares count from an underlying asset amount
-    /// @param _underlyingAssetAmount Amount of underlying asset to convert
-    /// @return The amount of shares worth the underlying asset amopunt
-    function sharesFromUnderlyingBalance(uint256 _underlyingAssetAmount) external view returns (uint256);
-
-    /// @notice Retrieve the allowance value for a spender
-    /// @param _owner Address that issued the allowance
-    /// @param _spender Address that received the allowance
-    /// @return The allowance in shares for a given spender
-    function allowance(address _owner, address _spender) external view returns (uint256);
-
-    /// @notice Performs a transfer from the message sender to the provided account
-    /// @param _to Address receiving the tokens
-    /// @param _value Amount of shares to be sent
-    /// @return True if success
-    function transfer(address _to, uint256 _value) external returns (bool);
-
-    /// @notice Performs a transfer between two recipients
-    /// @param _from Address sending the tokens
-    /// @param _to Address receiving the tokens
-    /// @param _value Amount of shares to be sent
-    /// @return True if success
-    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);
-
-    /// @notice Approves an account for future spendings
-    /// @dev An approved account can use transferFrom to transfer funds on behalf of the token owner
-    /// @param _spender Address that is allowed to spend the tokens
-    /// @param _value The allowed amount in shares, will override previous value
-    /// @return True if success
-    function approve(address _spender, uint256 _value) external returns (bool);
-
-    /// @notice Increase allowance to another account
-    /// @param _spender Spender that receives the allowance
-    /// @param _additionalValue Amount of shares to add
-    /// @return True if success
-    function increaseAllowance(address _spender, uint256 _additionalValue) external returns (bool);
-
-    /// @notice Decrease allowance to another account
-    /// @param _spender Spender that receives the allowance
-    /// @param _subtractableValue Amount of shares to subtract
-    /// @return True if success
-    function decreaseAllowance(address _spender, uint256 _subtractableValue) external returns (bool);
-}
diff -ruN src/interfaces/components/IUserDepositManager.1.sol interfaces/components/IUserDepositManager.1.sol
--- src/interfaces/components/IUserDepositManager.1.sol	2023-12-11 15:38:07
+++ interfaces/components/IUserDepositManager.1.sol	2024-01-16 15:06:39
@@ -1,29 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title User Deposit Manager (v1)
-/// @author Kiln
-/// @notice This interface exposes methods to handle the inbound transfers cases or the explicit submissions
-interface IUserDepositManagerV1 {
-    /// @notice User deposited ETH in the system
-    /// @param depositor Address performing the deposit
-    /// @param recipient Address receiving the minted shares
-    /// @param amount Amount in ETH deposited
-    event UserDeposit(address indexed depositor, address indexed recipient, uint256 amount);
-
-    /// @notice And empty deposit attempt was made
-    error EmptyDeposit();
-
-    /// @notice Explicit deposit method to mint on msg.sender
-    function deposit() external payable;
-
-    /// @notice Explicit deposit method to mint on msg.sender and transfer to _recipient
-    /// @param _recipient Address receiving the minted LsETH
-    function depositAndTransfer(address _recipient) external payable;
-
-    /// @notice Implicit deposit method, when the user performs a regular transfer to the contract
-    receive() external payable;
-
-    /// @notice Invalid call, when the user sends a transaction with a data payload but no method matched
-    fallback() external payable;
-}
diff -ruN src/libraries/LibAdministrable.sol libraries/LibAdministrable.sol
--- src/libraries/LibAdministrable.sol	2023-12-11 15:38:07
+++ libraries/LibAdministrable.sol	2024-01-16 15:06:39
@@ -1,34 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../state/shared/AdministratorAddress.sol";
-import "../state/shared/PendingAdministratorAddress.sol";
-
-/// @title Lib Administrable
-/// @author Kiln
-/// @notice This library handles the admin and pending admin storage vars
-library LibAdministrable {
-    /// @notice Retrieve the system admin
-    /// @return The address of the system admin
-    function _getAdmin() internal view returns (address) {
-        return AdministratorAddress.get();
-    }
-
-    /// @notice Retrieve the pending system admin
-    /// @return The adress of the pending system admin
-    function _getPendingAdmin() internal view returns (address) {
-        return PendingAdministratorAddress.get();
-    }
-
-    /// @notice Sets the system admin
-    /// @param _admin New system admin
-    function _setAdmin(address _admin) internal {
-        AdministratorAddress.set(_admin);
-    }
-
-    /// @notice Sets the pending system admin
-    /// @param _pendingAdmin New pending system admin
-    function _setPendingAdmin(address _pendingAdmin) internal {
-        PendingAdministratorAddress.set(_pendingAdmin);
-    }
-}
diff -ruN src/libraries/LibAllowlistMasks.sol libraries/LibAllowlistMasks.sol
--- src/libraries/LibAllowlistMasks.sol	2023-12-11 15:38:07
+++ libraries/LibAllowlistMasks.sol	2024-01-16 15:06:39
@@ -1,15 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Lib Allowlist Masks
-/// @notice Holds all the mask values
-library LibAllowlistMasks {
-    /// @notice Mask used for denied accounts
-    uint256 internal constant DENY_MASK = 0x1 << 255;
-    /// @notice The mask for the deposit right
-    uint256 internal constant DEPOSIT_MASK = 0x1;
-    /// @notice The mask for the donation right
-    uint256 internal constant DONATE_MASK = 0x1 << 1;
-    /// @notice The mask for the redeem right
-    uint256 internal constant REDEEM_MASK = 0x1 << 2;
-}
diff -ruN src/libraries/LibBasisPoints.sol libraries/LibBasisPoints.sol
--- src/libraries/LibBasisPoints.sol	2023-12-11 15:38:07
+++ libraries/LibBasisPoints.sol	2024-01-16 15:06:39
@@ -1,9 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Lib Basis Points
-/// @notice Holds the basis points max value
-library LibBasisPoints {
-    /// @notice The max value for basis points (represents 100%)
-    uint256 internal constant BASIS_POINTS_MAX = 10_000;
-}
diff -ruN src/libraries/LibBytes.sol libraries/LibBytes.sol
--- src/libraries/LibBytes.sol	2023-12-11 15:38:07
+++ libraries/LibBytes.sol	2024-01-16 15:06:39
@@ -1,83 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Lib Bytes
-/// @notice This library helps manipulating bytes
-library LibBytes {
-    /// @notice The length overflows an uint
-    error SliceOverflow();
-
-    /// @notice The slice is outside of the initial bytes bounds
-    error SliceOutOfBounds();
-
-    /// @notice Slices the provided bytes
-    /// @param _bytes Bytes to slice
-    /// @param _start The starting index of the slice
-    /// @param _length The length of the slice
-    /// @return The slice of _bytes starting at _start of length _length
-    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {
-        unchecked {
-            if (_length + 31 < _length) {
-                revert SliceOverflow();
-            }
-        }
-        if (_bytes.length < _start + _length) {
-            revert SliceOutOfBounds();
-        }
-
-        bytes memory tempBytes;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            switch iszero(_length)
-            case 0 {
-                // Get a location of some free memory and store it in tempBytes as
-                // Solidity does for memory variables.
-                tempBytes := mload(0x40)
-
-                // The first word of the slice result is potentially a partial
-                // word read from the original array. To read it, we calculate
-                // the length of that partial word and start copying that many
-                // bytes into the array. The first word we copy will start with
-                // data we don't care about, but the last `lengthmod` bytes will
-                // land at the beginning of the contents of the new array. When
-                // we're done copying, we overwrite the full first word with
-                // the actual length of the slice.
-                let lengthmod := and(_length, 31)
-
-                // The multiplication in the next line is necessary
-                // because when slicing multiples of 32 bytes (lengthmod == 0)
-                // the following copy loop was copying the origin's length
-                // and then ending prematurely not copying everything it should.
-                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))
-                let end := add(mc, _length)
-
-                for {
-                    // The multiplication in the next line has the same exact purpose
-                    // as the one above.
-                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)
-                } lt(mc, end) {
-                    mc := add(mc, 0x20)
-                    cc := add(cc, 0x20)
-                } { mstore(mc, mload(cc)) }
-
-                mstore(tempBytes, _length)
-
-                //update free-memory pointer
-                //allocating the array padded to 32 bytes like the compiler does now
-                mstore(0x40, and(add(mc, 31), not(31)))
-            }
-            //if we want a zero-length slice let's just return a zero-length array
-            default {
-                tempBytes := mload(0x40)
-                //zero out the 32 bytes slice we are about to return
-                //we need to do it because Solidity does not garbage collect
-                mstore(tempBytes, 0)
-
-                mstore(0x40, add(tempBytes, 0x20))
-            }
-        }
-
-        return tempBytes;
-    }
-}
diff -ruN src/libraries/LibErrors.sol libraries/LibErrors.sol
--- src/libraries/LibErrors.sol	2023-12-11 15:38:07
+++ libraries/LibErrors.sol	2024-01-16 15:06:39
@@ -1,25 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Lib Errors
-/// @notice Library of common errors
-library LibErrors {
-    /// @notice The operator is unauthorized for the caller
-    /// @param caller Address performing the call
-    error Unauthorized(address caller);
-
-    /// @notice The call was invalid
-    error InvalidCall();
-
-    /// @notice The argument was invalid
-    error InvalidArgument();
-
-    /// @notice The address is zero
-    error InvalidZeroAddress();
-
-    /// @notice The string is empty
-    error InvalidEmptyString();
-
-    /// @notice The fee is invalid
-    error InvalidFee();
-}
diff -ruN src/libraries/LibSanitize.sol libraries/LibSanitize.sol
--- src/libraries/LibSanitize.sol	2023-12-11 15:38:07
+++ libraries/LibSanitize.sol	2024-01-16 15:06:39
@@ -1,33 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "./LibErrors.sol";
-import "./LibBasisPoints.sol";
-
-/// @title Lib Sanitize
-/// @notice Utilities to sanitize input values
-library LibSanitize {
-    /// @notice Reverts if address is 0
-    /// @param _address Address to check
-    function _notZeroAddress(address _address) internal pure {
-        if (_address == address(0)) {
-            revert LibErrors.InvalidZeroAddress();
-        }
-    }
-
-    /// @notice Reverts if string is empty
-    /// @param _string String to check
-    function _notEmptyString(string memory _string) internal pure {
-        if (bytes(_string).length == 0) {
-            revert LibErrors.InvalidEmptyString();
-        }
-    }
-
-    /// @notice Reverts if fee is invalid
-    /// @param _fee Fee to check
-    function _validFee(uint256 _fee) internal pure {
-        if (_fee > LibBasisPoints.BASIS_POINTS_MAX) {
-            revert LibErrors.InvalidFee();
-        }
-    }
-}
diff -ruN src/libraries/LibUint256.sol libraries/LibUint256.sol
--- src/libraries/LibUint256.sol	2023-12-11 15:38:07
+++ libraries/LibUint256.sol	2024-01-16 15:06:39
@@ -1,64 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Lib Uint256
-/// @notice Utilities to perform uint operations
-library LibUint256 {
-    /// @notice Converts a value to little endian (64 bits)
-    /// @param _value The value to convert
-    /// @return result The converted value
-    function toLittleEndian64(uint256 _value) internal pure returns (uint256 result) {
-        result = 0;
-        uint256 tempValue = _value;
-        result = tempValue & 0xFF;
-        tempValue >>= 8;
-
-        result = (result << 8) | (tempValue & 0xFF);
-        tempValue >>= 8;
-
-        result = (result << 8) | (tempValue & 0xFF);
-        tempValue >>= 8;
-
-        result = (result << 8) | (tempValue & 0xFF);
-        tempValue >>= 8;
-
-        result = (result << 8) | (tempValue & 0xFF);
-        tempValue >>= 8;
-
-        result = (result << 8) | (tempValue & 0xFF);
-        tempValue >>= 8;
-
-        result = (result << 8) | (tempValue & 0xFF);
-        tempValue >>= 8;
-
-        result = (result << 8) | (tempValue & 0xFF);
-        tempValue >>= 8;
-
-        assert(0 == tempValue); // fully converted
-        result <<= (24 * 8);
-    }
-
-    /// @notice Returns the minimum value
-    /// @param _a First value
-    /// @param _b Second value
-    /// @return Smallest value between _a and _b
-    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {
-        return (_a > _b ? _b : _a);
-    }
-
-    /// @notice Returns the max value
-    /// @param _a First value
-    /// @param _b Second value
-    /// @return Highest value between _a and _b
-    function max(uint256 _a, uint256 _b) internal pure returns (uint256) {
-        return (_a < _b ? _b : _a);
-    }
-
-    /// @notice Performs a ceiled division
-    /// @param _a Numerator
-    /// @param _b Denominator
-    /// @return ceil(_a / _b)
-    function ceil(uint256 _a, uint256 _b) internal pure returns (uint256) {
-        return (_a / _b) + (_a % _b > 0 ? 1 : 0);
-    }
-}
diff -ruN src/libraries/LibUnstructuredStorage.sol libraries/LibUnstructuredStorage.sol
--- src/libraries/LibUnstructuredStorage.sol	2023-12-11 15:38:07
+++ libraries/LibUnstructuredStorage.sol	2024-01-16 15:06:39
@@ -1,87 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity 0.8.20;
-
-/// @title Lib Unstructured Storage
-/// @notice Utilities to work with unstructured storage
-library LibUnstructuredStorage {
-    /// @notice Retrieve a bool value at a storage slot
-    /// @param _position The storage slot to retrieve
-    /// @return data The bool value
-    function getStorageBool(bytes32 _position) internal view returns (bool data) {
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            data := sload(_position)
-        }
-    }
-
-    /// @notice Retrieve an address value at a storage slot
-    /// @param _position The storage slot to retrieve
-    /// @return data The address value
-    function getStorageAddress(bytes32 _position) internal view returns (address data) {
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            data := sload(_position)
-        }
-    }
-
-    /// @notice Retrieve a bytes32 value at a storage slot
-    /// @param _position The storage slot to retrieve
-    /// @return data The bytes32 value
-    function getStorageBytes32(bytes32 _position) internal view returns (bytes32 data) {
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            data := sload(_position)
-        }
-    }
-
-    /// @notice Retrieve an uint256 value at a storage slot
-    /// @param _position The storage slot to retrieve
-    /// @return data The uint256 value
-    function getStorageUint256(bytes32 _position) internal view returns (uint256 data) {
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            data := sload(_position)
-        }
-    }
-
-    /// @notice Sets a bool value at a storage slot
-    /// @param _position The storage slot to set
-    /// @param _data The bool value to set
-    function setStorageBool(bytes32 _position, bool _data) internal {
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            sstore(_position, _data)
-        }
-    }
-
-    /// @notice Sets an address value at a storage slot
-    /// @param _position The storage slot to set
-    /// @param _data The address value to set
-    function setStorageAddress(bytes32 _position, address _data) internal {
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            sstore(_position, _data)
-        }
-    }
-
-    /// @notice Sets a bytes32 value at a storage slot
-    /// @param _position The storage slot to set
-    /// @param _data The bytes32 value to set
-    function setStorageBytes32(bytes32 _position, bytes32 _data) internal {
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            sstore(_position, _data)
-        }
-    }
-
-    /// @notice Sets an uint256 value at a storage slot
-    /// @param _position The storage slot to set
-    /// @param _data The uint256 value to set
-    function setStorageUint256(bytes32 _position, uint256 _data) internal {
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            sstore(_position, _data)
-        }
-    }
-}
diff -ruN src/migration/TLC_globalUnlockScheduleMigration.sol migration/TLC_globalUnlockScheduleMigration.sol
--- src/migration/TLC_globalUnlockScheduleMigration.sol	2023-12-15 08:57:43
+++ migration/TLC_globalUnlockScheduleMigration.sol	2024-01-16 15:06:39
@@ -1,416 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../state/tlc/VestingSchedules.2.sol";
-import "../state/tlc/IgnoreGlobalUnlockSchedule.sol";
-
-struct VestingScheduleMigration {
-    // number of consecutive schedules to migrate with the same parameters
-    uint8 scheduleCount;
-    // The new lock duration
-    uint32 newLockDuration;
-    // if != 0, the new start value
-    uint64 newStart;
-    // if != 0, the new end value
-    uint64 newEnd;
-    // set cliff to 0 if true
-    bool setCliff;
-    // if true set vesting duration to 86400
-    bool setDuration;
-    // if true set vesting period duration to 86400
-    bool setPeriodDuration;
-    // if true schedule will not be subject to global unlock schedule
-    bool ignoreGlobalUnlock;
-}
-
-uint256 constant OCTOBER_16_2024 = 1729036800;
-
-contract TlcMigration {
-    error CliffTooLong(uint256 i);
-    error WrongUnlockDate(uint256 i);
-    error WrongEnd(uint256 i);
-
-    function migrate() external {
-        VestingScheduleMigration[] memory migrations = new VestingScheduleMigration[](30);
-        // 0 -> 6
-        migrations[0] = VestingScheduleMigration({
-            scheduleCount: 7,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 75772800,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: false
-        });
-        // 7
-        migrations[1] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 70329600,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: false
-        });
-        // 8
-        migrations[2] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 65491200,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: false
-        });
-        // 9 -> 12
-        migrations[3] = VestingScheduleMigration({
-            scheduleCount: 4,
-            newStart: 0,
-            newEnd: 1656720000,
-            newLockDuration: 72403200,
-            setCliff: true,
-            setDuration: true,
-            setPeriodDuration: true,
-            ignoreGlobalUnlock: false
-        });
-        // 13
-        migrations[4] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 67046400,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: false
-        });
-        // 14
-        migrations[5] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 56505600,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: false
-        });
-        // 15
-        migrations[6] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 58233600,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: false
-        });
-        // 16
-        migrations[7] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 57974400,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: false
-        });
-        // 17
-        migrations[8] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 53740800,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: true
-        });
-        // 18
-        migrations[9] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 75772800,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: false
-        });
-        // 19
-        migrations[10] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 49474800,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: false
-        });
-        // 20
-        migrations[11] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 75772800,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: false
-        });
-        // 21
-        migrations[12] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 49474800,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: false
-        });
-        // 22
-        migrations[13] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 75772800,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: false
-        });
-        // 23
-        migrations[14] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 49474800,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: false
-        });
-        // 24 -> 26
-        migrations[15] = VestingScheduleMigration({
-            scheduleCount: 3,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 75772800,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: false
-        });
-        // 27
-        migrations[16] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 70329600,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: false
-        });
-        // 28 -> 29
-        migrations[17] = VestingScheduleMigration({
-            scheduleCount: 2,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 50371200,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: false
-        });
-        // 30
-        migrations[18] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 50716800,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: true
-        });
-        // 31
-        migrations[19] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 50803200,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: true
-        });
-        // 32
-        migrations[20] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 50889600,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: true
-        });
-        // 33
-        migrations[21] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 50716800,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: true
-        });
-        // 34 -> 35
-        migrations[22] = VestingScheduleMigration({
-            scheduleCount: 2,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 50889600,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: true
-        });
-        // 36 -> 60
-        migrations[23] = VestingScheduleMigration({
-            scheduleCount: 25,
-            newStart: 1686175200,
-            newEnd: 1686261600,
-            newLockDuration: 42861600,
-            setCliff: false,
-            setDuration: true,
-            setPeriodDuration: true,
-            ignoreGlobalUnlock: false
-        });
-        // 61
-        migrations[24] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 40953600,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: false
-        });
-        // 62
-        migrations[25] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 48729600,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: false
-        });
-        // 63
-        migrations[26] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 41644800,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: true
-        });
-        // 64
-        migrations[27] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 47001600,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: true
-        });
-        // 65
-        migrations[28] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 45014400,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: true
-        });
-        // 66
-        migrations[29] = VestingScheduleMigration({
-            scheduleCount: 1,
-            newStart: 0,
-            newEnd: 0,
-            newLockDuration: 38188800,
-            setCliff: false,
-            setDuration: false,
-            setPeriodDuration: false,
-            ignoreGlobalUnlock: true
-        });
-        // All schedules covered
-
-        uint256 index = 0;
-        for (uint256 i = 0; i < migrations.length; i++) {
-            VestingScheduleMigration memory migration = migrations[i];
-            for (uint256 j = 0; j < migration.scheduleCount; j++) {
-                VestingSchedulesV2.VestingSchedule storage sch = VestingSchedulesV2.get(index);
-
-                bool isRevoked = false;
-                if (sch.start + sch.duration != sch.end) {
-                    isRevoked = true;
-                }
-                // Modifications
-                sch.lockDuration = migration.newLockDuration;
-                if (migration.newStart != 0) {
-                    sch.start = migration.newStart;
-                }
-                if (migration.newEnd != 0) {
-                    sch.end = migration.newEnd;
-                }
-                if (migration.setCliff) {
-                    sch.cliffDuration = 0;
-                }
-                if (migration.setDuration) {
-                    sch.duration = 86400;
-                }
-                if (migration.setPeriodDuration) {
-                    sch.periodDuration = 86400;
-                }
-                if (migration.ignoreGlobalUnlock) {
-                    IgnoreGlobalUnlockSchedule.set(index, true);
-                }
-
-                // Post effects checks
-                // check cliff is not longer than duration
-                if (sch.cliffDuration > sch.duration) {
-                    revert CliffTooLong(index);
-                }
-                // sanity checks on non revoked schedules
-                if (!isRevoked && (sch.end != sch.start + sch.duration)) {
-                    revert WrongEnd(index);
-                }
-                // check all the schedules are locked until unix : 1729036800
-                if (sch.start + sch.lockDuration != OCTOBER_16_2024) {
-                    revert WrongUnlockDate(index);
-                }
-
-                index += 1;
-            }
-        }
-    }
-}
diff -ruN src/mock/DepositContractMock.sol mock/DepositContractMock.sol
--- src/mock/DepositContractMock.sol	2023-12-11 15:38:07
+++ mock/DepositContractMock.sol	2024-01-16 15:06:39
@@ -1,45 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../interfaces/IDepositContract.sol";
-
-contract DepositContractMock is IDepositContract {
-    event DepositEvent(bytes pubkey, bytes withdrawal_credentials, bytes amount, bytes signature, bytes index);
-
-    uint256 public depositCount;
-    address public receiver;
-
-    constructor(address _receiver) {
-        receiver = _receiver;
-    }
-
-    function to_little_endian_64(uint64 value) internal pure returns (bytes memory ret) {
-        ret = new bytes(8);
-        bytes8 bytesValue = bytes8(value);
-        // Byteswapping during copying to bytes.
-        ret[0] = bytesValue[7];
-        ret[1] = bytesValue[6];
-        ret[2] = bytesValue[5];
-        ret[3] = bytesValue[4];
-        ret[4] = bytesValue[3];
-        ret[5] = bytesValue[2];
-        ret[6] = bytesValue[1];
-        ret[7] = bytesValue[0];
-    }
-
-    function deposit(bytes calldata pubkey, bytes calldata withdrawalCredentials, bytes calldata signature, bytes32)
-        external
-        payable
-    {
-        emit DepositEvent(
-            pubkey,
-            withdrawalCredentials,
-            to_little_endian_64(uint64(msg.value / 1 gwei)),
-            signature,
-            to_little_endian_64(uint64(depositCount))
-        );
-        depositCount += 1;
-        (bool sent,) = receiver.call{value: address(this).balance}("");
-        require(sent, "Fund transfer failed");
-    }
-}
diff -ruN src/state/allowlist/AllowerAddress.sol state/allowlist/AllowerAddress.sol
--- src/state/allowlist/AllowerAddress.sol	2023-12-11 15:38:07
+++ state/allowlist/AllowerAddress.sol	2024-01-16 15:06:39
@@ -1,25 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-import "../../libraries/LibSanitize.sol";
-
-/// @title Allower Address Storage
-/// @notice Utility to manage the Allower Address in storage
-library AllowerAddress {
-    /// @notice Storage slot of the Allower Address
-    bytes32 internal constant ALLOWER_ADDRESS_SLOT = bytes32(uint256(keccak256("river.state.allowerAddress")) - 1);
-
-    /// @notice Retrieve the Allower Address
-    /// @return The Allower Address
-    function get() internal view returns (address) {
-        return LibUnstructuredStorage.getStorageAddress(ALLOWER_ADDRESS_SLOT);
-    }
-
-    /// @notice Sets the Allower Address
-    /// @param _newValue New Allower Address
-    function set(address _newValue) internal {
-        LibSanitize._notZeroAddress(_newValue);
-        LibUnstructuredStorage.setStorageAddress(ALLOWER_ADDRESS_SLOT, _newValue);
-    }
-}
diff -ruN src/state/allowlist/Allowlist.sol state/allowlist/Allowlist.sol
--- src/state/allowlist/Allowlist.sol	2023-12-11 15:38:07
+++ state/allowlist/Allowlist.sol	2024-01-16 15:06:39
@@ -1,47 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Allowlist Storage
-/// @notice Utility to manage the Allowlist mapping in storage
-library Allowlist {
-    /// @notice Storage slot of the Allowlist mapping
-    bytes32 internal constant ALLOWLIST_SLOT = bytes32(uint256(keccak256("river.state.allowlist")) - 1);
-
-    /// @notice Structure stored in storage slot
-    struct Slot {
-        /// @custom:attribute Mapping keeping track of permissions per account
-        mapping(address => uint256) value;
-    }
-
-    /// @notice Retrieve the Allowlist value of an account
-    /// @param _account The account to verify
-    /// @return The Allowlist value
-    function get(address _account) internal view returns (uint256) {
-        bytes32 slot = ALLOWLIST_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        return r.value[_account];
-    }
-
-    /// @notice Sets the Allowlist value of an account
-    /// @param _account The account value to set
-    /// @param _status The value to set
-    function set(address _account, uint256 _status) internal {
-        bytes32 slot = ALLOWLIST_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        r.value[_account] = _status;
-    }
-}
diff -ruN src/state/allowlist/DenierAddress.sol state/allowlist/DenierAddress.sol
--- src/state/allowlist/DenierAddress.sol	2023-12-11 15:38:07
+++ state/allowlist/DenierAddress.sol	2024-01-16 15:06:39
@@ -1,25 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-import "../../libraries/LibSanitize.sol";
-
-/// @title Denier Address Storage
-/// @notice Utility to manage the Denier Address in storage
-library DenierAddress {
-    /// @notice Storage slot of the Denier Address
-    bytes32 internal constant DENIER_ADDRESS_SLOT = bytes32(uint256(keccak256("river.state.denierAddress")) - 1);
-
-    /// @notice Retrieve the Denier Address
-    /// @return The Denier Address
-    function get() internal view returns (address) {
-        return LibUnstructuredStorage.getStorageAddress(DENIER_ADDRESS_SLOT);
-    }
-
-    /// @notice Sets the Denier Address
-    /// @param _newValue New Denier Address
-    function set(address _newValue) internal {
-        LibSanitize._notZeroAddress(_newValue);
-        LibUnstructuredStorage.setStorageAddress(DENIER_ADDRESS_SLOT, _newValue);
-    }
-}
diff -ruN src/state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_KeyIndex.sol state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_KeyIndex.sol
--- src/state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_KeyIndex.sol	2023-12-11 15:38:07
+++ state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_KeyIndex.sol	2024-01-16 15:06:39
@@ -1,17 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-
-library OperatorsRegistry_FundedKeyEventRebroadcasting_KeyIndex {
-    bytes32 internal constant KEY_INDEX_SLOT =
-        bytes32(uint256(keccak256("river.state.migration.operatorsRegistry.fundedKeyEventRebroadcasting.keyIndex")) - 1);
-
-    function get() internal view returns (uint256) {
-        return LibUnstructuredStorage.getStorageUint256(KEY_INDEX_SLOT);
-    }
-
-    function set(uint256 _newValue) internal {
-        LibUnstructuredStorage.setStorageUint256(KEY_INDEX_SLOT, _newValue);
-    }
-}
diff -ruN src/state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex.sol state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex.sol
--- src/state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex.sol	2023-12-11 15:38:07
+++ state/migration/OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex.sol	2024-01-16 15:06:39
@@ -1,18 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-
-library OperatorsRegistry_FundedKeyEventRebroadcasting_OperatorIndex {
-    bytes32 internal constant OPERATOR_INDEX_SLOT = bytes32(
-        uint256(keccak256("river.state.migration.operatorsRegistry.fundedKeyEventRebroadcasting.operatorIndex")) - 1
-    );
-
-    function get() internal view returns (uint256) {
-        return LibUnstructuredStorage.getStorageUint256(OPERATOR_INDEX_SLOT);
-    }
-
-    function set(uint256 _newValue) internal {
-        LibUnstructuredStorage.setStorageUint256(OPERATOR_INDEX_SLOT, _newValue);
-    }
-}
diff -ruN src/state/operatorsRegistry/CurrentValidatorExitsDemand.sol state/operatorsRegistry/CurrentValidatorExitsDemand.sol
--- src/state/operatorsRegistry/CurrentValidatorExitsDemand.sol	2023-12-11 15:38:07
+++ state/operatorsRegistry/CurrentValidatorExitsDemand.sol	2024-01-16 15:06:39
@@ -1,26 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-
-/// @title CurrentValidatorExitsDemand Storage
-/// @notice This value controls the current demand for exits that still need to be triggered
-/// @notice in order to notify the operators
-/// @notice Utility to manage the CurrentValidatorExitsDemand in storage
-library CurrentValidatorExitsDemand {
-    /// @notice Storage slot of the CurrentValidatorExitsDemand
-    bytes32 internal constant CURRENT_VALIDATOR_EXITS_DEMAND_SLOT =
-        bytes32(uint256(keccak256("river.state.currentValidatorExitsDemand")) - 1);
-
-    /// @notice Retrieve the CurrentValidatorExitsDemand
-    /// @return The CurrentValidatorExitsDemand
-    function get() internal view returns (uint256) {
-        return LibUnstructuredStorage.getStorageUint256(CURRENT_VALIDATOR_EXITS_DEMAND_SLOT);
-    }
-
-    /// @notice Sets the CurrentValidatorExitsDemand
-    /// @param _newValue New CurrentValidatorExitsDemand
-    function set(uint256 _newValue) internal {
-        return LibUnstructuredStorage.setStorageUint256(CURRENT_VALIDATOR_EXITS_DEMAND_SLOT, _newValue);
-    }
-}
diff -ruN src/state/operatorsRegistry/Operators.1.sol state/operatorsRegistry/Operators.1.sol
--- src/state/operatorsRegistry/Operators.1.sol	2023-12-11 15:38:07
+++ state/operatorsRegistry/Operators.1.sol	2024-01-16 15:06:39
@@ -1,239 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibSanitize.sol";
-
-/// @title Operators Storage
-/// @notice Utility to manage the Operators in storage
-/// @notice This state variable is deprecated and was kept due to migration logic needs
-library OperatorsV1 {
-    /// @notice Storage slot of the Operators
-    bytes32 internal constant OPERATORS_SLOT = bytes32(uint256(keccak256("river.state.operators")) - 1);
-
-    /// @notice The Operator structure in storage
-    struct Operator {
-        /// @custom:attribute True if the operator is active and allowed to operate on River
-        bool active;
-        /// @custom:attribute Display name of the operator
-        string name;
-        /// @custom:attribute Address of the operator
-        address operator;
-        /// @dev The following values respect this invariant:
-        /// @dev     keys >= limit >= funded >= stopped
-
-        /// @custom:attribute Staking limit of the operator
-        uint256 limit;
-        /// @custom:attribute The count of funded validators
-        uint256 funded;
-        /// @custom:attribute The total count of keys of the operator
-        uint256 keys;
-        /// @custom:attribute The count of stopped validators. Stopped validators are validators
-        ///                   that exited the consensus layer (voluntary or slashed)
-        uint256 stopped;
-        uint256 latestKeysEditBlockNumber;
-    }
-
-    /// @notice The Operator structure when loaded in memory
-    struct CachedOperator {
-        /// @custom:attribute True if the operator is active and allowed to operate on River
-        bool active;
-        /// @custom:attribute Display name of the operator
-        string name;
-        /// @custom:attribute Address of the operator
-        address operator;
-        /// @custom:attribute Staking limit of the operator
-        uint256 limit;
-        /// @custom:attribute The count of funded validators
-        uint256 funded;
-        /// @custom:attribute The total count of keys of the operator
-        uint256 keys;
-        /// @custom:attribute The count of stopped validators
-        uint256 stopped;
-        /// @custom:attribute The count of stopped validators. Stopped validators are validators
-        ///                   that exited the consensus layer (voluntary or slashed)
-        uint256 index;
-        /// @custom:attribute The amount of picked keys, buffer used before changing funded in storage
-        uint256 picked;
-    }
-
-    /// @notice The structure at the storage slot
-    struct SlotOperator {
-        /// @custom:attribute Array containing all the operators
-        Operator[] value;
-    }
-
-    /// @notice The operator was not found
-    /// @param index The provided index
-    error OperatorNotFound(uint256 index);
-
-    /// @notice Retrieve the operator in storage
-    /// @param _index The index of the operator
-    /// @return The Operator structure
-    function get(uint256 _index) internal view returns (Operator storage) {
-        bytes32 slot = OPERATORS_SLOT;
-
-        SlotOperator storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        if (r.value.length <= _index) {
-            revert OperatorNotFound(_index);
-        }
-
-        return r.value[_index];
-    }
-
-    /// @notice Retrieve the operator count in storage
-    /// @return The count of operators in storage
-    function getCount() internal view returns (uint256) {
-        bytes32 slot = OPERATORS_SLOT;
-
-        SlotOperator storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        return r.value.length;
-    }
-
-    /// @notice Retrieve all the active operators
-    /// @return The list of active operator structures
-    function getAllActive() internal view returns (Operator[] memory) {
-        bytes32 slot = OPERATORS_SLOT;
-
-        SlotOperator storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        uint256 activeCount = 0;
-        uint256 operatorCount = r.value.length;
-
-        for (uint256 idx = 0; idx < operatorCount;) {
-            if (r.value[idx].active) {
-                unchecked {
-                    ++activeCount;
-                }
-            }
-            unchecked {
-                ++idx;
-            }
-        }
-
-        Operator[] memory activeOperators = new Operator[](activeCount);
-
-        uint256 activeIdx = 0;
-        for (uint256 idx = 0; idx < operatorCount;) {
-            if (r.value[idx].active) {
-                activeOperators[activeIdx] = r.value[idx];
-                unchecked {
-                    ++activeIdx;
-                }
-            }
-            unchecked {
-                ++idx;
-            }
-        }
-
-        return activeOperators;
-    }
-
-    /// @notice Retrieve all the active and fundable operators
-    /// @return The list of active and fundable operators
-    function getAllFundable() internal view returns (CachedOperator[] memory) {
-        bytes32 slot = OPERATORS_SLOT;
-
-        SlotOperator storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        uint256 activeCount = 0;
-        uint256 operatorCount = r.value.length;
-
-        for (uint256 idx = 0; idx < operatorCount;) {
-            if (_hasFundableKeys(r.value[idx])) {
-                unchecked {
-                    ++activeCount;
-                }
-            }
-            unchecked {
-                ++idx;
-            }
-        }
-
-        CachedOperator[] memory activeOperators = new CachedOperator[](activeCount);
-
-        uint256 activeIdx = 0;
-        for (uint256 idx = 0; idx < operatorCount;) {
-            Operator memory op = r.value[idx];
-            if (_hasFundableKeys(op)) {
-                activeOperators[activeIdx] = CachedOperator({
-                    active: op.active,
-                    name: op.name,
-                    operator: op.operator,
-                    limit: op.limit,
-                    funded: op.funded,
-                    keys: op.keys,
-                    stopped: op.stopped,
-                    index: idx,
-                    picked: 0
-                });
-                unchecked {
-                    ++activeIdx;
-                }
-            }
-            unchecked {
-                ++idx;
-            }
-        }
-
-        return activeOperators;
-    }
-
-    /// @notice Add a new operator in storage
-    /// @param _newOperator Value of the new operator
-    /// @return The size of the operator array after the operation
-    function push(Operator memory _newOperator) internal returns (uint256) {
-        LibSanitize._notZeroAddress(_newOperator.operator);
-        LibSanitize._notEmptyString(_newOperator.name);
-        bytes32 slot = OPERATORS_SLOT;
-
-        SlotOperator storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        r.value.push(_newOperator);
-
-        return r.value.length;
-    }
-
-    /// @notice Atomic operation to set the key count and update the latestKeysEditBlockNumber field at the same time
-    /// @param _index The operator index
-    /// @param _newKeys The new value for the key count
-    function setKeys(uint256 _index, uint256 _newKeys) internal {
-        Operator storage op = get(_index);
-
-        op.keys = _newKeys;
-        op.latestKeysEditBlockNumber = block.number;
-    }
-
-    /// @notice Checks if an operator is active and has fundable keys
-    /// @param _operator The operator details
-    /// @return True if active and fundable
-    function _hasFundableKeys(OperatorsV1.Operator memory _operator) internal pure returns (bool) {
-        return (_operator.active && _operator.limit > _operator.funded);
-    }
-}
diff -ruN src/state/operatorsRegistry/Operators.2.sol state/operatorsRegistry/Operators.2.sol
--- src/state/operatorsRegistry/Operators.2.sol	2023-12-11 15:38:07
+++ state/operatorsRegistry/Operators.2.sol	2024-01-16 15:06:39
@@ -1,347 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibSanitize.sol";
-
-/// @title Operators Storage
-/// @notice Utility to manage the Operators in storage
-library OperatorsV2 {
-    /// @notice Storage slot of the Operators
-    bytes32 internal constant OPERATORS_SLOT = bytes32(uint256(keccak256("river.state.v2.operators")) - 1);
-
-    /// @notice The Operator structure in storage
-    struct Operator {
-        /// @dev The following values respect this invariant:
-        /// @dev     keys >= limit >= funded >= RequestedExits
-
-        /// @custom:attribute Staking limit of the operator
-        uint32 limit;
-        /// @custom:attribute The count of funded validators
-        uint32 funded;
-        /// @custom:attribute The count of exit requests made to this operator
-        uint32 requestedExits;
-        /// @custom:attribute The total count of keys of the operator
-        uint32 keys;
-        /// @custom attribute The block at which the last edit happened in the operator details
-        uint64 latestKeysEditBlockNumber;
-        /// @custom:attribute True if the operator is active and allowed to operate on River
-        bool active;
-        /// @custom:attribute Display name of the operator
-        string name;
-        /// @custom:attribute Address of the operator
-        address operator;
-    }
-
-    /// @notice The Operator structure when loaded in memory
-    struct CachedOperator {
-        /// @custom:attribute Staking limit of the operator
-        uint32 limit;
-        /// @custom:attribute The count of funded validators
-        uint32 funded;
-        /// @custom:attribute The count of exit requests made to this operator
-        uint32 requestedExits;
-        /// @custom:attribute The original index of the operator
-        uint32 index;
-        /// @custom:attribute The amount of picked keys, buffer used before changing funded in storage
-        uint32 picked;
-    }
-
-    /// @notice The Operator structure when loaded in memory for the exit selection
-    struct CachedExitableOperator {
-        /// @custom:attribute The count of funded validators
-        uint32 funded;
-        /// @custom:attribute The count of exit requests made to this operator
-        uint32 requestedExits;
-        /// @custom:attribute The original index of the operator
-        uint32 index;
-        /// @custom:attribute The amount of picked keys, buffer used before changing funded in storage
-        uint32 picked;
-    }
-
-    /// @notice The structure at the storage slot
-    struct SlotOperator {
-        /// @custom:attribute Array containing all the operators
-        Operator[] value;
-    }
-
-    /// @notice The operator was not found
-    /// @param index The provided index
-    error OperatorNotFound(uint256 index);
-
-    /// @notice Retrieve the operator in storage
-    /// @param _index The index of the operator
-    /// @return The Operator structure
-    function get(uint256 _index) internal view returns (Operator storage) {
-        bytes32 slot = OPERATORS_SLOT;
-
-        SlotOperator storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        if (r.value.length <= _index) {
-            revert OperatorNotFound(_index);
-        }
-
-        return r.value[_index];
-    }
-
-    /// @notice Retrieve the operators in storage
-    /// @return The Operator structure array
-    function getAll() internal view returns (Operator[] storage) {
-        bytes32 slot = OPERATORS_SLOT;
-
-        SlotOperator storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        return r.value;
-    }
-
-    /// @notice Retrieve the operator count in storage
-    /// @return The count of operators in storage
-    function getCount() internal view returns (uint256) {
-        bytes32 slot = OPERATORS_SLOT;
-
-        SlotOperator storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        return r.value.length;
-    }
-
-    /// @notice Retrieve all the active operators
-    /// @return The list of active operator structures
-    function getAllActive() internal view returns (Operator[] memory) {
-        bytes32 slot = OPERATORS_SLOT;
-
-        SlotOperator storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        uint256 activeCount = 0;
-        uint256 operatorCount = r.value.length;
-
-        for (uint256 idx = 0; idx < operatorCount;) {
-            if (r.value[idx].active) {
-                unchecked {
-                    ++activeCount;
-                }
-            }
-            unchecked {
-                ++idx;
-            }
-        }
-
-        Operator[] memory activeOperators = new Operator[](activeCount);
-
-        uint256 activeIdx = 0;
-        for (uint256 idx = 0; idx < operatorCount;) {
-            if (r.value[idx].active) {
-                activeOperators[activeIdx] = r.value[idx];
-                unchecked {
-                    ++activeIdx;
-                }
-            }
-            unchecked {
-                ++idx;
-            }
-        }
-
-        return activeOperators;
-    }
-
-    /// @notice Retrieve the stopped validator count for an operator by its index
-    /// @param stoppedValidatorCounts The storage pointer to the raw array containing the stopped validator counts
-    /// @param index The index of the operator to lookup
-    /// @return The amount of stopped validators for the given operator index
-    function _getStoppedValidatorCountAtIndex(uint32[] storage stoppedValidatorCounts, uint256 index)
-        internal
-        view
-        returns (uint32)
-    {
-        if (index + 1 >= stoppedValidatorCounts.length) {
-            return 0;
-        }
-        return stoppedValidatorCounts[index + 1];
-    }
-
-    /// @notice Retrieve all the active and fundable operators
-    /// @dev This method will return a memory array of length equal to the number of operator, but only
-    /// @dev populated up to the fundable operator count, also returned by the method
-    /// @return The list of active and fundable operators
-    /// @return The count of active and fundable operators
-    function getAllFundable() internal view returns (CachedOperator[] memory, uint256) {
-        bytes32 slot = OPERATORS_SLOT;
-
-        SlotOperator storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        uint256 fundableCount = 0;
-        uint256 operatorCount = r.value.length;
-        CachedOperator[] memory fundableOperators = new CachedOperator[](operatorCount);
-
-        uint32[] storage stoppedValidatorCounts = getStoppedValidators();
-
-        for (uint256 idx = 0; idx < operatorCount;) {
-            if (
-                _hasFundableKeys(r.value[idx])
-                    && _getStoppedValidatorCountAtIndex(stoppedValidatorCounts, idx) >= r.value[idx].requestedExits
-            ) {
-                Operator storage op = r.value[idx];
-                fundableOperators[fundableCount] = CachedOperator({
-                    limit: op.limit,
-                    funded: op.funded,
-                    requestedExits: op.requestedExits,
-                    index: uint32(idx),
-                    picked: 0
-                });
-                unchecked {
-                    ++fundableCount;
-                }
-            }
-            unchecked {
-                ++idx;
-            }
-        }
-
-        return (fundableOperators, fundableCount);
-    }
-
-    /// @notice Retrieve all the active and exitable operators
-    /// @dev This method will return a memory array of length equal to the number of operator, but only
-    /// @dev populated up to the exitable operator count, also returned by the method
-    /// @return The list of active and exitable operators
-    /// @return The count of active and exitable operators
-    function getAllExitable() internal view returns (CachedExitableOperator[] memory, uint256) {
-        bytes32 slot = OPERATORS_SLOT;
-
-        SlotOperator storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        uint256 exitableCount = 0;
-        uint256 operatorCount = r.value.length;
-
-        CachedExitableOperator[] memory exitableOperators = new CachedExitableOperator[](operatorCount);
-
-        for (uint256 idx = 0; idx < operatorCount;) {
-            if (_hasExitableKeys(r.value[idx])) {
-                Operator storage op = r.value[idx];
-                exitableOperators[exitableCount] = CachedExitableOperator({
-                    funded: op.funded,
-                    requestedExits: op.requestedExits,
-                    index: uint32(idx),
-                    picked: 0
-                });
-                unchecked {
-                    ++exitableCount;
-                }
-            }
-            unchecked {
-                ++idx;
-            }
-        }
-
-        return (exitableOperators, exitableCount);
-    }
-
-    /// @notice Add a new operator in storage
-    /// @param _newOperator Value of the new operator
-    /// @return The size of the operator array after the operation
-    function push(Operator memory _newOperator) internal returns (uint256) {
-        LibSanitize._notZeroAddress(_newOperator.operator);
-        LibSanitize._notEmptyString(_newOperator.name);
-        bytes32 slot = OPERATORS_SLOT;
-
-        SlotOperator storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        r.value.push(_newOperator);
-
-        return r.value.length;
-    }
-
-    /// @notice Atomic operation to set the key count and update the latestKeysEditBlockNumber field at the same time
-    /// @param _index The operator index
-    /// @param _newKeys The new value for the key count
-    function setKeys(uint256 _index, uint32 _newKeys) internal {
-        Operator storage op = get(_index);
-
-        op.keys = _newKeys;
-        op.latestKeysEditBlockNumber = uint64(block.number);
-    }
-
-    /// @notice Checks if an operator is active and has fundable keys
-    /// @param _operator The operator details
-    /// @return True if active and fundable
-    function _hasFundableKeys(OperatorsV2.Operator memory _operator) internal pure returns (bool) {
-        return (_operator.active && _operator.limit > _operator.funded);
-    }
-
-    /// @notice Checks if an operator is active and has exitable keys
-    /// @param _operator The operator details
-    /// @return True if active and exitable
-    function _hasExitableKeys(OperatorsV2.Operator memory _operator) internal pure returns (bool) {
-        return (_operator.active && _operator.funded > _operator.requestedExits);
-    }
-
-    /// @notice Storage slot of the Stopped Validators
-    bytes32 internal constant STOPPED_VALIDATORS_SLOT = bytes32(uint256(keccak256("river.state.stoppedValidators")) - 1);
-
-    struct SlotStoppedValidators {
-        uint32[] value;
-    }
-
-    /// @notice Retrieve the storage pointer of the Stopped Validators array
-    /// @return The Stopped Validators storage pointer
-    function getStoppedValidators() internal view returns (uint32[] storage) {
-        bytes32 slot = STOPPED_VALIDATORS_SLOT;
-
-        SlotStoppedValidators storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        return r.value;
-    }
-
-    /// @notice Sets the entire stopped validators array
-    /// @param value The new stopped validators array
-    function setRawStoppedValidators(uint32[] memory value) internal {
-        bytes32 slot = STOPPED_VALIDATORS_SLOT;
-
-        SlotStoppedValidators storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        r.value = value;
-    }
-}
diff -ruN src/state/operatorsRegistry/TotalValidatorExitsRequested.sol state/operatorsRegistry/TotalValidatorExitsRequested.sol
--- src/state/operatorsRegistry/TotalValidatorExitsRequested.sol	2023-12-11 15:38:07
+++ state/operatorsRegistry/TotalValidatorExitsRequested.sol	2024-01-16 15:06:39
@@ -1,25 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-
-/// @title TotalValidatorExitsRequested Storage
-/// @notice This value is the amount of performed exit requests, only increased when there is current exit demand
-/// @notice Utility to manage the TotalValidatorExitsRequested in storage
-library TotalValidatorExitsRequested {
-    /// @notice Storage slot of the TotalValidatorExitsRequested
-    bytes32 internal constant TOTAL_VALIDATOR_EXITS_REQUESTED_SLOT =
-        bytes32(uint256(keccak256("river.state.totalValidatorExitsRequested")) - 1);
-
-    /// @notice Retrieve the TotalValidatorExitsRequested
-    /// @return The TotalValidatorExitsRequested
-    function get() internal view returns (uint256) {
-        return LibUnstructuredStorage.getStorageUint256(TOTAL_VALIDATOR_EXITS_REQUESTED_SLOT);
-    }
-
-    /// @notice Sets the TotalValidatorExitsRequested
-    /// @param _newValue New TotalValidatorExitsRequested
-    function set(uint256 _newValue) internal {
-        return LibUnstructuredStorage.setStorageUint256(TOTAL_VALIDATOR_EXITS_REQUESTED_SLOT, _newValue);
-    }
-}
diff -ruN src/state/operatorsRegistry/ValidatorKeys.sol state/operatorsRegistry/ValidatorKeys.sol
--- src/state/operatorsRegistry/ValidatorKeys.sol	2023-12-11 15:38:07
+++ state/operatorsRegistry/ValidatorKeys.sol	2024-01-16 15:06:39
@@ -1,121 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibBytes.sol";
-
-/// @title Validator Keys Storage
-/// @notice Utility to manage the validator keys in storage
-library ValidatorKeys {
-    /// @notice Storage slot of the Validator Keys
-    bytes32 internal constant VALIDATOR_KEYS_SLOT = bytes32(uint256(keccak256("river.state.validatorKeys")) - 1);
-
-    /// @notice Length in bytes of a BLS Public Key used for validator deposits
-    uint256 internal constant PUBLIC_KEY_LENGTH = 48;
-
-    /// @notice Length in bytes of a BLS Signature used for validator deposits
-    uint256 internal constant SIGNATURE_LENGTH = 96;
-
-    /// @notice The provided public key is not matching the expected length
-    error InvalidPublicKey();
-
-    /// @notice The provided signature is not matching the expected length
-    error InvalidSignature();
-
-    /// @notice Structure of the Validator Keys in storage
-    struct Slot {
-        /// @custom:attribute The mapping from operator index to key index to key value
-        mapping(uint256 => mapping(uint256 => bytes)) value;
-    }
-
-    /// @notice Retrieve the Validator Key of an operator at a specific index
-    /// @param _operatorIndex The operator index
-    /// @param _idx the Validator Key index
-    /// @return publicKey The Validator Key public key
-    /// @return signature The Validator Key signature
-    function get(uint256 _operatorIndex, uint256 _idx)
-        internal
-        view
-        returns (bytes memory publicKey, bytes memory signature)
-    {
-        bytes32 slot = VALIDATOR_KEYS_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        bytes storage entry = r.value[_operatorIndex][_idx];
-
-        publicKey = LibBytes.slice(entry, 0, PUBLIC_KEY_LENGTH);
-        signature = LibBytes.slice(entry, PUBLIC_KEY_LENGTH, SIGNATURE_LENGTH);
-    }
-
-    /// @notice Retrieve the raw concatenated Validator Keys
-    /// @param _operatorIndex The operator index
-    /// @param _idx The Validator Key index
-    /// @return The concatenated public key and signature
-    function getRaw(uint256 _operatorIndex, uint256 _idx) internal view returns (bytes memory) {
-        bytes32 slot = VALIDATOR_KEYS_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        return r.value[_operatorIndex][_idx];
-    }
-
-    /// @notice Retrieve multiple keys of an operator starting at an index
-    /// @param _operatorIndex The operator index
-    /// @param _startIdx The starting index to retrieve the keys from
-    /// @param _amount The amount of keys to retrieve
-    /// @return publicKeys The public keys retrieved
-    /// @return signatures The signatures associated with the public keys
-    function getKeys(uint256 _operatorIndex, uint256 _startIdx, uint256 _amount)
-        internal
-        view
-        returns (bytes[] memory publicKeys, bytes[] memory signatures)
-    {
-        publicKeys = new bytes[](_amount);
-        signatures = new bytes[](_amount);
-
-        bytes32 slot = VALIDATOR_KEYS_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-        uint256 idx;
-        for (; idx < _amount;) {
-            bytes memory rawCredentials = r.value[_operatorIndex][idx + _startIdx];
-            publicKeys[idx] = LibBytes.slice(rawCredentials, 0, PUBLIC_KEY_LENGTH);
-            signatures[idx] = LibBytes.slice(rawCredentials, PUBLIC_KEY_LENGTH, SIGNATURE_LENGTH);
-            unchecked {
-                ++idx;
-            }
-        }
-    }
-
-    /// @notice Set the concatenated Validator Keys at an index for an operator
-    /// @param _operatorIndex The operator index
-    /// @param _idx The key index to write on
-    /// @param _publicKeyAndSignature The concatenated Validator Keys
-    function set(uint256 _operatorIndex, uint256 _idx, bytes memory _publicKeyAndSignature) internal {
-        bytes32 slot = VALIDATOR_KEYS_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        r.value[_operatorIndex][_idx] = _publicKeyAndSignature;
-    }
-}
diff -ruN src/state/oracle/LastEpochId.sol state/oracle/LastEpochId.sol
--- src/state/oracle/LastEpochId.sol	2023-12-11 15:38:07
+++ state/oracle/LastEpochId.sol	2024-01-16 15:06:39
@@ -1,23 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-
-/// @title Last Epoch Id Storage
-/// @notice Utility to manage the Last Epoch Id in storage
-library LastEpochId {
-    /// @notice Storage slot of the Last Epoch Id
-    bytes32 internal constant LAST_EPOCH_ID_SLOT = bytes32(uint256(keccak256("river.state.lastEpochId")) - 1);
-
-    /// @notice Retrieve the Last Epoch Id
-    /// @return The Last Epoch Id
-    function get() internal view returns (uint256) {
-        return LibUnstructuredStorage.getStorageUint256(LAST_EPOCH_ID_SLOT);
-    }
-
-    /// @notice Sets the Last Epoch Id
-    /// @param _newValue New Last Epoch Id
-    function set(uint256 _newValue) internal {
-        LibUnstructuredStorage.setStorageUint256(LAST_EPOCH_ID_SLOT, _newValue);
-    }
-}
diff -ruN src/state/oracle/OracleMembers.sol state/oracle/OracleMembers.sol
--- src/state/oracle/OracleMembers.sol	2023-12-11 15:38:07
+++ state/oracle/OracleMembers.sol	2024-01-16 15:06:39
@@ -1,111 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibSanitize.sol";
-
-/// @title Oracle Members Storage
-/// @notice Utility to manage the Oracle Members in storage
-/// @dev There can only be up to 256 oracle members. This is due to how report statuses are stored in Reports Positions
-library OracleMembers {
-    /// @notice Storage slot of the Oracle Members
-    bytes32 internal constant ORACLE_MEMBERS_SLOT = bytes32(uint256(keccak256("river.state.oracleMembers")) - 1);
-
-    /// @notice The structure in storage
-    struct Slot {
-        /// @custom:attribute The array of oracle members
-        address[] value;
-    }
-
-    /// @notice Retrieve the list of oracle members
-    /// @return List of oracle members
-    function get() internal view returns (address[] memory) {
-        bytes32 slot = ORACLE_MEMBERS_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        return r.value;
-    }
-
-    /// @notice Add a new oracle member to the list
-    /// @param _newOracleMember Address of the new oracle member
-    function push(address _newOracleMember) internal {
-        LibSanitize._notZeroAddress(_newOracleMember);
-
-        bytes32 slot = ORACLE_MEMBERS_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        r.value.push(_newOracleMember);
-    }
-
-    /// @notice Set an address in the oracle member list
-    /// @param _index The index to edit
-    /// @param _newOracleAddress The new value of the oracle member
-    function set(uint256 _index, address _newOracleAddress) internal {
-        bytes32 slot = ORACLE_MEMBERS_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        r.value[_index] = _newOracleAddress;
-    }
-
-    /// @notice Retrieve the index of the oracle member
-    /// @param _memberAddress The address to lookup
-    /// @return The index of the member, -1 if not found
-    function indexOf(address _memberAddress) internal view returns (int256) {
-        bytes32 slot = ORACLE_MEMBERS_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        for (uint256 idx = 0; idx < r.value.length;) {
-            if (r.value[idx] == _memberAddress) {
-                return int256(idx);
-            }
-            unchecked {
-                ++idx;
-            }
-        }
-
-        return int256(-1);
-    }
-
-    /// @notice Delete the oracle member at the given index
-    /// @param _idx The index of the member to remove
-    function deleteItem(uint256 _idx) internal {
-        bytes32 slot = ORACLE_MEMBERS_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        uint256 lastIdx = r.value.length - 1;
-        if (lastIdx != _idx) {
-            r.value[_idx] = r.value[lastIdx];
-        }
-
-        r.value.pop();
-    }
-}
diff -ruN src/state/oracle/Quorum.sol state/oracle/Quorum.sol
--- src/state/oracle/Quorum.sol	2023-12-11 15:38:07
+++ state/oracle/Quorum.sol	2024-01-16 15:06:39
@@ -1,23 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-
-/// @title Quorum Storage
-/// @notice Utility to manage the Quorum in storage
-library Quorum {
-    /// @notice Storage slot of the Quorum
-    bytes32 internal constant QUORUM_SLOT = bytes32(uint256(keccak256("river.state.quorum")) - 1);
-
-    /// @notice Retrieve the Quorum
-    /// @return The Quorum
-    function get() internal view returns (uint256) {
-        return LibUnstructuredStorage.getStorageUint256(QUORUM_SLOT);
-    }
-
-    /// @notice Sets the Quorum
-    /// @param _newValue New Quorum
-    function set(uint256 _newValue) internal {
-        return LibUnstructuredStorage.setStorageUint256(QUORUM_SLOT, _newValue);
-    }
-}
diff -ruN src/state/oracle/ReportsPositions.sol state/oracle/ReportsPositions.sol
--- src/state/oracle/ReportsPositions.sol	2023-12-11 15:38:07
+++ state/oracle/ReportsPositions.sol	2024-01-16 15:06:39
@@ -1,40 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-
-/// @title Reports Positions Storage
-/// @notice Utility to manage the Reports Positions in storage
-/// @dev Each bit in the stored uint256 value tells if the member at a given index has reported
-library ReportsPositions {
-    /// @notice Storage slot of the Reports Positions
-    bytes32 internal constant REPORTS_POSITIONS_SLOT = bytes32(uint256(keccak256("river.state.reportsPositions")) - 1);
-
-    /// @notice Retrieve the Reports Positions at index
-    /// @param _idx The index to retrieve
-    /// @return True if already reported
-    function get(uint256 _idx) internal view returns (bool) {
-        uint256 mask = 1 << _idx;
-        return LibUnstructuredStorage.getStorageUint256(REPORTS_POSITIONS_SLOT) & mask == mask;
-    }
-
-    /// @notice Retrieve the raw Reports Positions from storage
-    /// @return Raw Reports Positions
-    function getRaw() internal view returns (uint256) {
-        return LibUnstructuredStorage.getStorageUint256(REPORTS_POSITIONS_SLOT);
-    }
-
-    /// @notice Register an index as reported
-    /// @param _idx The index to register
-    function register(uint256 _idx) internal {
-        uint256 mask = 1 << _idx;
-        return LibUnstructuredStorage.setStorageUint256(
-            REPORTS_POSITIONS_SLOT, LibUnstructuredStorage.getStorageUint256(REPORTS_POSITIONS_SLOT) | mask
-        );
-    }
-
-    /// @notice Clears all the report positions in storage
-    function clear() internal {
-        return LibUnstructuredStorage.setStorageUint256(REPORTS_POSITIONS_SLOT, 0);
-    }
-}
diff -ruN src/state/oracle/ReportsVariants.sol state/oracle/ReportsVariants.sol
--- src/state/oracle/ReportsVariants.sol	2023-12-11 15:38:07
+++ state/oracle/ReportsVariants.sol	2024-01-16 15:06:39
@@ -1,105 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Reports Variants Storage
-/// @notice Utility to manage the Reports Variants in storage
-library ReportsVariants {
-    /// @notice Storage slot of the Reports Variants
-    bytes32 internal constant REPORT_VARIANTS_SLOT = bytes32(uint256(keccak256("river.state.reportsVariants")) - 1);
-
-    struct ReportVariantDetails {
-        bytes32 variant;
-        uint256 votes;
-    }
-
-    /// @notice Structure in storage
-    struct Slot {
-        /// @custom:attribute The list of variants
-        ReportVariantDetails[] value;
-    }
-
-    /// @notice Retrieve the Reports Variants from storage
-    /// @return The Reports Variants
-    function get() internal view returns (ReportVariantDetails[] storage) {
-        bytes32 slot = REPORT_VARIANTS_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        return r.value;
-    }
-
-    /// @notice Set the Reports Variants value at index
-    /// @param _idx The index to set
-    /// @param _val The value to set
-    function set(uint256 _idx, ReportVariantDetails memory _val) internal {
-        bytes32 slot = REPORT_VARIANTS_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        r.value[_idx] = _val;
-    }
-
-    /// @notice Add a new variant in the list
-    /// @param _variant The new variant to add
-    function push(ReportVariantDetails memory _variant) internal {
-        bytes32 slot = REPORT_VARIANTS_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        r.value.push(_variant);
-    }
-
-    /// @notice Retrieve the index of a specific variant, ignoring the count field
-    /// @param _variant Variant value to lookup
-    /// @return The index of the variant, -1 if not found
-    function indexOfReport(bytes32 _variant) internal view returns (int256) {
-        bytes32 slot = REPORT_VARIANTS_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        for (uint256 idx = 0; idx < r.value.length;) {
-            if (r.value[idx].variant == _variant) {
-                return int256(idx);
-            }
-            unchecked {
-                ++idx;
-            }
-        }
-
-        return int256(-1);
-    }
-
-    /// @notice Clear all variants from storage
-    function clear() internal {
-        bytes32 slot = REPORT_VARIANTS_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        delete r.value;
-    }
-}
diff -ruN src/state/redeemManager/BufferedExceedingEth.sol state/redeemManager/BufferedExceedingEth.sol
--- src/state/redeemManager/BufferedExceedingEth.sol	2023-12-11 15:38:07
+++ state/redeemManager/BufferedExceedingEth.sol	2024-01-16 15:06:39
@@ -1,24 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-
-/// @title Buffered Exceeding Eth storage
-/// @notice Redeen Manager utility to manage the exceeding ETH with a redeem request
-library BufferedExceedingEth {
-    /// @notice Storage slot of the Redeem Buffered Eth
-    bytes32 internal constant BUFFERED_EXCEEDING_ETH_SLOT =
-        bytes32(uint256(keccak256("river.state.bufferedExceedingEth")) - 1);
-
-    /// @notice Retrieve the Redeem Buffered Eth Value
-    /// @return The Redeem Buffered Eth Value
-    function get() internal view returns (uint256) {
-        return LibUnstructuredStorage.getStorageUint256(BUFFERED_EXCEEDING_ETH_SLOT);
-    }
-
-    /// @notice Sets the Redeem Buffered Eth Value
-    /// @param newValue The new value
-    function set(uint256 newValue) internal {
-        LibUnstructuredStorage.setStorageUint256(BUFFERED_EXCEEDING_ETH_SLOT, newValue);
-    }
-}
diff -ruN src/state/redeemManager/RedeemDemand.sol state/redeemManager/RedeemDemand.sol
--- src/state/redeemManager/RedeemDemand.sol	2023-12-11 15:38:07
+++ state/redeemManager/RedeemDemand.sol	2024-01-16 15:06:39
@@ -1,23 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-
-/// @title Redeem Demand storage
-/// @notice Redeem Manager utility to store the current demand in LsETH
-library RedeemDemand {
-    /// @notice Storage slot of the Redeem Demand
-    bytes32 internal constant REDEEM_DEMAND_SLOT = bytes32(uint256(keccak256("river.state.redeemDemand")) - 1);
-
-    /// @notice Retrieve the Redeem Demand Value
-    /// @return The Redeem Demand Value
-    function get() internal view returns (uint256) {
-        return LibUnstructuredStorage.getStorageUint256(REDEEM_DEMAND_SLOT);
-    }
-
-    /// @notice Sets the Redeem Demand Value
-    /// @param newValue The new value
-    function set(uint256 newValue) internal {
-        LibUnstructuredStorage.setStorageUint256(REDEEM_DEMAND_SLOT, newValue);
-    }
-}
diff -ruN src/state/redeemManager/RedeemQueue.sol state/redeemManager/RedeemQueue.sol
--- src/state/redeemManager/RedeemQueue.sol	2023-12-11 15:38:07
+++ state/redeemManager/RedeemQueue.sol	2024-01-16 15:06:39
@@ -1,30 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Redeem Manager Redeem Queue storage
-/// @notice Utility to manage the Redeem Queue in the Redeem Manager
-library RedeemQueue {
-    /// @notice Storage slot of the Redeem Queue
-    bytes32 internal constant REDEEM_QUEUE_ID_SLOT = bytes32(uint256(keccak256("river.state.redeemQueue")) - 1);
-
-    /// @notice The Redeemer structure represents the redeem request made by a user
-    struct RedeemRequest {
-        /// @custom:attribute The amount of the redeem request in LsETH
-        uint256 amount;
-        /// @custom:attribute The maximum amount of ETH redeemable by this request
-        uint256 maxRedeemableEth;
-        /// @custom:attribute The owner of the redeem request
-        address owner;
-        /// @custom:attribute The height is the cumulative sum of all the sizes of preceding redeem requests
-        uint256 height;
-    }
-
-    /// @notice Retrieve the Redeem Queue array storage pointer
-    /// @return data The Redeem Queue array storage pointer
-    function get() internal pure returns (RedeemRequest[] storage data) {
-        bytes32 position = REDEEM_QUEUE_ID_SLOT;
-        assembly {
-            data.slot := position
-        }
-    }
-}
diff -ruN src/state/redeemManager/WithdrawalStack.sol state/redeemManager/WithdrawalStack.sol
--- src/state/redeemManager/WithdrawalStack.sol	2023-12-11 15:38:07
+++ state/redeemManager/WithdrawalStack.sol	2024-01-16 15:06:39
@@ -1,28 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Redeem Manager Withdrawal Stack storage
-/// @notice Utility to manage the Withdrawal Stack in the Redeem Manager
-library WithdrawalStack {
-    /// @notice Storage slot of the Withdrawal Stack
-    bytes32 internal constant WITHDRAWAL_STACK_ID_SLOT = bytes32(uint256(keccak256("river.state.withdrawalStack")) - 1);
-
-    /// @notice The Redeemer structure represents the withdrawal events made by River
-    struct WithdrawalEvent {
-        /// @custom:attribute The amount of the withdrawal event in LsETH
-        uint256 amount;
-        /// @custom:attribute The amount of the withdrawal event in ETH
-        uint256 withdrawnEth;
-        /// @custom:attribute The height is the cumulative sum of all the sizes of preceding withdrawal events
-        uint256 height;
-    }
-
-    /// @notice Retrieve the Withdrawal Stack array storage pointer
-    /// @return data The Withdrawal Stack array storage pointer
-    function get() internal pure returns (WithdrawalEvent[] storage data) {
-        bytes32 position = WITHDRAWAL_STACK_ID_SLOT;
-        assembly {
-            data.slot := position
-        }
-    }
-}
diff -ruN src/state/river/AllowlistAddress.sol state/river/AllowlistAddress.sol
--- src/state/river/AllowlistAddress.sol	2023-12-11 15:38:07
+++ state/river/AllowlistAddress.sol	2024-01-16 15:06:39
@@ -1,25 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-import "../../libraries/LibSanitize.sol";
-
-/// @title Allowlist Address Storage
-/// @notice Utility to manage the Allowlist Address in storage
-library AllowlistAddress {
-    /// @notice Storage slot of the Allowlist Address
-    bytes32 internal constant ALLOWLIST_ADDRESS_SLOT = bytes32(uint256(keccak256("river.state.allowlistAddress")) - 1);
-
-    /// @notice Retrieve the Allowlist Address
-    /// @return The Allowlist Address
-    function get() internal view returns (address) {
-        return LibUnstructuredStorage.getStorageAddress(ALLOWLIST_ADDRESS_SLOT);
-    }
-
-    /// @notice Sets the Allowlist Address
-    /// @param _newValue New Allowlist Address
-    function set(address _newValue) internal {
-        LibSanitize._notZeroAddress(_newValue);
-        LibUnstructuredStorage.setStorageAddress(ALLOWLIST_ADDRESS_SLOT, _newValue);
-    }
-}
diff -ruN src/state/river/BalanceToDeposit.sol state/river/BalanceToDeposit.sol
--- src/state/river/BalanceToDeposit.sol	2023-12-11 15:38:07
+++ state/river/BalanceToDeposit.sol	2024-01-16 15:06:39
@@ -1,16 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-
-library BalanceToDeposit {
-    bytes32 internal constant BALANCE_TO_DEPOSIT_SLOT = bytes32(uint256(keccak256("river.state.balanceToDeposit")) - 1);
-
-    function get() internal view returns (uint256) {
-        return LibUnstructuredStorage.getStorageUint256(BALANCE_TO_DEPOSIT_SLOT);
-    }
-
-    function set(uint256 newValue) internal {
-        LibUnstructuredStorage.setStorageUint256(BALANCE_TO_DEPOSIT_SLOT, newValue);
-    }
-}
diff -ruN src/state/river/BalanceToRedeem.sol state/river/BalanceToRedeem.sol
--- src/state/river/BalanceToRedeem.sol	2023-12-11 15:38:07
+++ state/river/BalanceToRedeem.sol	2024-01-16 15:06:39
@@ -1,16 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-
-library BalanceToRedeem {
-    bytes32 internal constant BALANCE_TO_REDEEM_SLOT = bytes32(uint256(keccak256("river.state.balanceToRedeem")) - 1);
-
-    function get() internal view returns (uint256) {
-        return LibUnstructuredStorage.getStorageUint256(BALANCE_TO_REDEEM_SLOT);
-    }
-
-    function set(uint256 newValue) internal {
-        LibUnstructuredStorage.setStorageUint256(BALANCE_TO_REDEEM_SLOT, newValue);
-    }
-}
diff -ruN src/state/river/CLSpec.sol state/river/CLSpec.sol
--- src/state/river/CLSpec.sol	2023-12-11 15:38:07
+++ state/river/CLSpec.sol	2024-01-16 15:06:39
@@ -1,59 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Consensus Layer Spec Storage
-/// @notice Utility to manage the Consensus Layer Spec in storage
-library CLSpec {
-    /// @notice Storage slot of the Consensus Layer Spec
-    bytes32 internal constant CL_SPEC_SLOT = bytes32(uint256(keccak256("river.state.clSpec")) - 1);
-
-    /// @notice The Consensus Layer Spec structure
-    struct CLSpecStruct {
-        /// @custom:attribute The count of epochs per frame, 225 means 24h
-        uint64 epochsPerFrame;
-        /// @custom:attribute The count of slots in an epoch (32 on mainnet)
-        uint64 slotsPerEpoch;
-        /// @custom:attribute The seconds in a slot (12 on mainnet)
-        uint64 secondsPerSlot;
-        /// @custom:attribute The block timestamp of the first consensus layer block
-        uint64 genesisTime;
-        /// @custom:attribute The count of epochs before considering an epoch final on-chain
-        uint64 epochsToAssumedFinality;
-    }
-
-    /// @notice The structure in storage
-    struct Slot {
-        /// @custom:attribute The structure in storage
-        CLSpecStruct value;
-    }
-
-    /// @notice Retrieve the Consensus Layer Spec from storage
-    /// @return The Consensus Layer Spec
-    function get() internal view returns (CLSpecStruct memory) {
-        bytes32 slot = CL_SPEC_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        return r.value;
-    }
-
-    /// @notice Set the Consensus Layer Spec value in storage
-    /// @param _newCLSpec The new value to set in storage
-    function set(CLSpecStruct memory _newCLSpec) internal {
-        bytes32 slot = CL_SPEC_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        r.value = _newCLSpec;
-    }
-}
diff -ruN src/state/river/CLValidatorCount.sol state/river/CLValidatorCount.sol
--- src/state/river/CLValidatorCount.sol	2023-12-11 15:38:07
+++ state/river/CLValidatorCount.sol	2024-01-16 15:06:39
@@ -1,24 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-
-/// @title Consensus Layer Validator Count Storage
-/// @notice Utility to manage the Consensus Layer Validator Count in storage
-/// @notice This state variable is deprecated and was kept due to migration logic needs
-library CLValidatorCount {
-    /// @notice Storage slot of the Consensus Layer Validator Count
-    bytes32 internal constant CL_VALIDATOR_COUNT_SLOT = bytes32(uint256(keccak256("river.state.clValidatorCount")) - 1);
-
-    /// @notice Retrieve the Consensus Layer Validator Count
-    /// @return The Consensus Layer Validator Count
-    function get() internal view returns (uint256) {
-        return LibUnstructuredStorage.getStorageUint256(CL_VALIDATOR_COUNT_SLOT);
-    }
-
-    /// @notice Sets the Consensus Layer Validator Count
-    /// @param _newValue New Consensus Layer Validator Count
-    function set(uint256 _newValue) internal {
-        LibUnstructuredStorage.setStorageUint256(CL_VALIDATOR_COUNT_SLOT, _newValue);
-    }
-}
diff -ruN src/state/river/CLValidatorTotalBalance.sol state/river/CLValidatorTotalBalance.sol
--- src/state/river/CLValidatorTotalBalance.sol	2023-12-11 15:38:07
+++ state/river/CLValidatorTotalBalance.sol	2024-01-16 15:06:39
@@ -1,25 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-
-/// @title Consensus Layer Validator Total Balance Storage
-/// @notice Utility to manage the Consensus Layer Validator Total Balance in storage
-/// @notice This state variable is deprecated and was kept due to migration logic needs
-library CLValidatorTotalBalance {
-    /// @notice Storage slot of the Consensus Layer Validator Total Balance
-    bytes32 internal constant CL_VALIDATOR_TOTAL_BALANCE_SLOT =
-        bytes32(uint256(keccak256("river.state.clValidatorTotalBalance")) - 1);
-
-    /// @notice Retrieve the Consensus Layer Validator Total Balance
-    /// @return The Consensus Layer Validator Total Balance
-    function get() internal view returns (uint256) {
-        return LibUnstructuredStorage.getStorageUint256(CL_VALIDATOR_TOTAL_BALANCE_SLOT);
-    }
-
-    /// @notice Sets the Consensus Layer Validator Total Balance
-    /// @param _newValue New Consensus Layer Validator Total Balance
-    function set(uint256 _newValue) internal {
-        LibUnstructuredStorage.setStorageUint256(CL_VALIDATOR_TOTAL_BALANCE_SLOT, _newValue);
-    }
-}
diff -ruN src/state/river/CollectorAddress.sol state/river/CollectorAddress.sol
--- src/state/river/CollectorAddress.sol	2023-12-11 15:38:07
+++ state/river/CollectorAddress.sol	2024-01-16 15:06:39
@@ -1,25 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-import "../../libraries/LibSanitize.sol";
-
-/// @title Collector Address Storage
-/// @notice Utility to manage the Collector Address in storage
-library CollectorAddress {
-    /// @notice Storage slot of the Collector Address
-    bytes32 internal constant COLLECTOR_ADDRESS_SLOT = bytes32(uint256(keccak256("river.state.collectorAddress")) - 1);
-
-    /// @notice Retrieve the Collector Address
-    /// @return The Collector Address
-    function get() internal view returns (address) {
-        return LibUnstructuredStorage.getStorageAddress(COLLECTOR_ADDRESS_SLOT);
-    }
-
-    /// @notice Sets the Collector Address
-    /// @param _newValue New Collector Address
-    function set(address _newValue) internal {
-        LibSanitize._notZeroAddress(_newValue);
-        LibUnstructuredStorage.setStorageAddress(COLLECTOR_ADDRESS_SLOT, _newValue);
-    }
-}
diff -ruN src/state/river/CommittedBalance.sol state/river/CommittedBalance.sol
--- src/state/river/CommittedBalance.sol	2023-12-11 15:38:07
+++ state/river/CommittedBalance.sol	2024-01-16 15:06:39
@@ -1,16 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-
-library CommittedBalance {
-    bytes32 internal constant COMMITTED_BALANCE_SLOT = bytes32(uint256(keccak256("river.state.committedBalance")) - 1);
-
-    function get() internal view returns (uint256) {
-        return LibUnstructuredStorage.getStorageUint256(COMMITTED_BALANCE_SLOT);
-    }
-
-    function set(uint256 newValue) internal {
-        LibUnstructuredStorage.setStorageUint256(COMMITTED_BALANCE_SLOT, newValue);
-    }
-}
diff -ruN src/state/river/CoverageFundAddress.sol state/river/CoverageFundAddress.sol
--- src/state/river/CoverageFundAddress.sol	2023-12-11 15:38:07
+++ state/river/CoverageFundAddress.sol	2024-01-16 15:06:39
@@ -1,26 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-import "../../libraries/LibSanitize.sol";
-
-/// @title Coverage Fund Address Storage
-/// @notice Utility to manage the Coverage Fund Address in storage
-library CoverageFundAddress {
-    /// @notice Storage slot of the Coverage Fund Address
-    bytes32 internal constant COVERAGE_FUND_ADDRESS_SLOT =
-        bytes32(uint256(keccak256("river.state.coverageFundAddress")) - 1);
-
-    /// @notice Retrieve the Coverage Fund Address
-    /// @return The Coverage Fund Address
-    function get() internal view returns (address) {
-        return LibUnstructuredStorage.getStorageAddress(COVERAGE_FUND_ADDRESS_SLOT);
-    }
-
-    /// @notice Sets the Coverage Fund Address
-    /// @param _newValue New Coverage Fund Address
-    function set(address _newValue) internal {
-        LibSanitize._notZeroAddress(_newValue);
-        LibUnstructuredStorage.setStorageAddress(COVERAGE_FUND_ADDRESS_SLOT, _newValue);
-    }
-}
diff -ruN src/state/river/DailyCommittableLimits.sol state/river/DailyCommittableLimits.sol
--- src/state/river/DailyCommittableLimits.sol	2023-12-11 15:38:07
+++ state/river/DailyCommittableLimits.sol	2024-01-16 15:06:39
@@ -1,54 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibSanitize.sol";
-
-/// @title Daily Committable Limits storage
-/// @notice Utility to manage the Daily Committable Limits in storage
-library DailyCommittableLimits {
-    /// @notice Storage slot of the Daily Committable Limits storage
-    bytes32 internal constant DAILY_COMMITTABLE_LIMITS_SLOT =
-        bytes32(uint256(keccak256("river.state.dailyCommittableLimits")) - 1);
-
-    /// @notice The daily committable limits structure
-    struct DailyCommittableLimitsStruct {
-        uint128 minDailyNetCommittableAmount;
-        uint128 maxDailyRelativeCommittableAmount;
-    }
-
-    /// @notice The structure in storage
-    struct Slot {
-        /// @custom:attribute The structure in storage
-        DailyCommittableLimitsStruct value;
-    }
-
-    /// @notice Retrieve the Daily Committable Limits from storage
-    /// @return The Daily Committable Limits
-    function get() internal view returns (DailyCommittableLimitsStruct memory) {
-        bytes32 slot = DAILY_COMMITTABLE_LIMITS_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        return r.value;
-    }
-
-    /// @notice Set the Daily Committable Limits value in storage
-    /// @param _newValue The new value to set in storage
-    function set(DailyCommittableLimitsStruct memory _newValue) internal {
-        bytes32 slot = DAILY_COMMITTABLE_LIMITS_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        r.value = _newValue;
-    }
-}
diff -ruN src/state/river/DepositContractAddress.sol state/river/DepositContractAddress.sol
--- src/state/river/DepositContractAddress.sol	2023-12-11 15:38:07
+++ state/river/DepositContractAddress.sol	2024-01-16 15:06:39
@@ -1,26 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibSanitize.sol";
-import "../../libraries/LibUnstructuredStorage.sol";
-
-/// @title Deposit Contract Address Storage
-/// @notice Utility to manage the Deposit Contract Address in storage
-library DepositContractAddress {
-    /// @notice Storage slot of the Deposit Contract Address
-    bytes32 internal constant DEPOSIT_CONTRACT_ADDRESS_SLOT =
-        bytes32(uint256(keccak256("river.state.depositContractAddress")) - 1);
-
-    /// @notice Retrieve the Deposit Contract Address
-    /// @return The Deposit Contract Address
-    function get() internal view returns (address) {
-        return LibUnstructuredStorage.getStorageAddress(DEPOSIT_CONTRACT_ADDRESS_SLOT);
-    }
-
-    /// @notice Sets the Deposit Contract Address
-    /// @param _newValue New Deposit Contract Address
-    function set(address _newValue) internal {
-        LibSanitize._notZeroAddress(_newValue);
-        LibUnstructuredStorage.setStorageAddress(DEPOSIT_CONTRACT_ADDRESS_SLOT, _newValue);
-    }
-}
diff -ruN src/state/river/DepositedValidatorCount.sol state/river/DepositedValidatorCount.sol
--- src/state/river/DepositedValidatorCount.sol	2023-12-11 15:38:07
+++ state/river/DepositedValidatorCount.sol	2024-01-16 15:06:39
@@ -1,24 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-
-/// @title Deposited Validator Count Storage
-/// @notice Utility to manage the Deposited Validator Count in storage
-library DepositedValidatorCount {
-    /// @notice Storage slot of the Deposited Validator Count
-    bytes32 internal constant DEPOSITED_VALIDATOR_COUNT_SLOT =
-        bytes32(uint256(keccak256("river.state.depositedValidatorCount")) - 1);
-
-    /// @notice Retrieve the Deposited Validator Count
-    /// @return The Deposited Validator Count
-    function get() internal view returns (uint256) {
-        return LibUnstructuredStorage.getStorageUint256(DEPOSITED_VALIDATOR_COUNT_SLOT);
-    }
-
-    /// @notice Sets the Deposited Validator Count
-    /// @param _newValue New Deposited Validator Count
-    function set(uint256 _newValue) internal {
-        LibUnstructuredStorage.setStorageUint256(DEPOSITED_VALIDATOR_COUNT_SLOT, _newValue);
-    }
-}
diff -ruN src/state/river/ELFeeRecipientAddress.sol state/river/ELFeeRecipientAddress.sol
--- src/state/river/ELFeeRecipientAddress.sol	2023-12-11 15:38:07
+++ state/river/ELFeeRecipientAddress.sol	2024-01-16 15:06:39
@@ -1,26 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-import "../../libraries/LibSanitize.sol";
-
-/// @title Execution Layer Fee Recipient Address Storage
-/// @notice Utility to manage the Execution Layer Fee Recipient Address in storage
-library ELFeeRecipientAddress {
-    /// @notice Storage slot of the Execution Layer Fee Recipient Address
-    bytes32 internal constant EL_FEE_RECIPIENT_ADDRESS =
-        bytes32(uint256(keccak256("river.state.elFeeRecipientAddress")) - 1);
-
-    /// @notice Retrieve the Execution Layer Fee Recipient Address
-    /// @return The Execution Layer Fee Recipient Address
-    function get() internal view returns (address) {
-        return LibUnstructuredStorage.getStorageAddress(EL_FEE_RECIPIENT_ADDRESS);
-    }
-
-    /// @notice Sets the Execution Layer Fee Recipient Address
-    /// @param _newValue New Execution Layer Fee Recipient Address
-    function set(address _newValue) internal {
-        LibSanitize._notZeroAddress(_newValue);
-        LibUnstructuredStorage.setStorageAddress(EL_FEE_RECIPIENT_ADDRESS, _newValue);
-    }
-}
diff -ruN src/state/river/GlobalFee.sol state/river/GlobalFee.sol
--- src/state/river/GlobalFee.sol	2023-12-11 15:38:07
+++ state/river/GlobalFee.sol	2024-01-16 15:06:39
@@ -1,25 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibSanitize.sol";
-import "../../libraries/LibUnstructuredStorage.sol";
-
-/// @title Global Fee Storage
-/// @notice Utility to manage the Global Fee in storage
-library GlobalFee {
-    /// @notice Storage slot of the Global Fee
-    bytes32 internal constant GLOBAL_FEE_SLOT = bytes32(uint256(keccak256("river.state.globalFee")) - 1);
-
-    /// @notice Retrieve the Global Fee
-    /// @return The Global Fee
-    function get() internal view returns (uint256) {
-        return LibUnstructuredStorage.getStorageUint256(GLOBAL_FEE_SLOT);
-    }
-
-    /// @notice Sets the Global Fee
-    /// @param _newValue New Global Fee
-    function set(uint256 _newValue) internal {
-        LibSanitize._validFee(_newValue);
-        LibUnstructuredStorage.setStorageUint256(GLOBAL_FEE_SLOT, _newValue);
-    }
-}
diff -ruN src/state/river/LastConsensusLayerReport.sol state/river/LastConsensusLayerReport.sol
--- src/state/river/LastConsensusLayerReport.sol	2023-12-11 15:38:07
+++ state/river/LastConsensusLayerReport.sol	2024-01-16 15:06:39
@@ -1,48 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../interfaces/components/IOracleManager.1.sol";
-
-/// @title Last Consensus Layer Report Storage
-/// @notice Utility to manage the Last Consensus Layer Report in storage
-library LastConsensusLayerReport {
-    /// @notice Storage slot of the Last Consensus Layer Report
-    bytes32 internal constant LAST_CONSENSUS_LAYER_REPORT_SLOT =
-        bytes32(uint256(keccak256("river.state.lastConsensusLayerReport")) - 1);
-
-    /// @notice The structure in storage
-    struct Slot {
-        /// @custom:attribute The structure in storage
-        IOracleManagerV1.StoredConsensusLayerReport value;
-    }
-
-    /// @notice Retrieve the Last Consensus Layer Report from storage
-    /// @return The Last Consensus Layer Report
-    function get() internal view returns (IOracleManagerV1.StoredConsensusLayerReport storage) {
-        bytes32 slot = LAST_CONSENSUS_LAYER_REPORT_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        return r.value;
-    }
-
-    /// @notice Set the Last Consensus Layer Report value in storage
-    /// @param _newValue The new value to set in storage
-    function set(IOracleManagerV1.StoredConsensusLayerReport memory _newValue) internal {
-        bytes32 slot = LAST_CONSENSUS_LAYER_REPORT_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        r.value = _newValue;
-    }
-}
diff -ruN src/state/river/LastOracleRoundId.sol state/river/LastOracleRoundId.sol
--- src/state/river/LastOracleRoundId.sol	2023-12-11 15:38:07
+++ state/river/LastOracleRoundId.sol	2024-01-16 15:06:39
@@ -1,25 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-
-/// @title Last Oracle Round Id Storage
-/// @notice Utility to manage the Last Oracle Round Id in storage
-/// @notice This state variable is deprecated and was kept due to migration logic needs
-library LastOracleRoundId {
-    /// @notice Storage slot of the Last Oracle Round Id
-    bytes32 internal constant LAST_ORACLE_ROUND_ID_SLOT =
-        bytes32(uint256(keccak256("river.state.lastOracleRoundId")) - 1);
-
-    /// @notice Retrieve the Last Oracle Round Id
-    /// @return The Last Oracle Round Id
-    function get() internal view returns (bytes32) {
-        return LibUnstructuredStorage.getStorageBytes32(LAST_ORACLE_ROUND_ID_SLOT);
-    }
-
-    /// @notice Sets the Last Oracle Round Id
-    /// @param _newValue New Last Oracle Round Id
-    function set(bytes32 _newValue) internal {
-        LibUnstructuredStorage.setStorageBytes32(LAST_ORACLE_ROUND_ID_SLOT, _newValue);
-    }
-}
diff -ruN src/state/river/MetadataURI.sol state/river/MetadataURI.sol
--- src/state/river/MetadataURI.sol	2023-12-11 15:38:07
+++ state/river/MetadataURI.sol	2024-01-16 15:06:39
@@ -1,45 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Metadata URI Storage
-/// @notice Utility to manage the Metadata in storage
-library MetadataURI {
-    /// @notice Storage slot of the Metadata URI
-    bytes32 internal constant METADATA_URI_SLOT = bytes32(uint256(keccak256("river.state.metadataUri")) - 1);
-
-    /// @notice Structure in storage
-    struct Slot {
-        /// @custom:attribute The metadata value
-        string value;
-    }
-
-    /// @notice Retrieve the metadata URI
-    /// @return The metadata URI string
-    function get() internal view returns (string memory) {
-        bytes32 slot = METADATA_URI_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        return r.value;
-    }
-
-    /// @notice Set the metadata URI value
-    /// @param _newValue The new metadata URI value
-    function set(string memory _newValue) internal {
-        bytes32 slot = METADATA_URI_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        r.value = _newValue;
-    }
-}
diff -ruN src/state/river/OperatorsRegistryAddress.sol state/river/OperatorsRegistryAddress.sol
--- src/state/river/OperatorsRegistryAddress.sol	2023-12-11 15:38:07
+++ state/river/OperatorsRegistryAddress.sol	2024-01-16 15:06:39
@@ -1,26 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-import "../../libraries/LibSanitize.sol";
-
-/// @title Operators Registry Address Storage
-/// @notice Utility to manage the Operators Registry Address in storage
-library OperatorsRegistryAddress {
-    /// @notice Storage slot of the Operators Registry Address
-    bytes32 internal constant OPERATORS_REGISTRY_ADDRESS_SLOT =
-        bytes32(uint256(keccak256("river.state.operatorsRegistryAddress")) - 1);
-
-    /// @notice Retrieve the Operators Registry Address
-    /// @return The Operators Registry Address
-    function get() internal view returns (address) {
-        return LibUnstructuredStorage.getStorageAddress(OPERATORS_REGISTRY_ADDRESS_SLOT);
-    }
-
-    /// @notice Sets the Operators Registry Address
-    /// @param _newValue New Operators Registry Address
-    function set(address _newValue) internal {
-        LibSanitize._notZeroAddress(_newValue);
-        LibUnstructuredStorage.setStorageAddress(OPERATORS_REGISTRY_ADDRESS_SLOT, _newValue);
-    }
-}
diff -ruN src/state/river/OracleAddress.sol state/river/OracleAddress.sol
--- src/state/river/OracleAddress.sol	2023-12-11 15:38:07
+++ state/river/OracleAddress.sol	2024-01-16 15:06:39
@@ -1,25 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-import "../../libraries/LibSanitize.sol";
-
-/// @title Oracle Address Storage
-/// @notice Utility to manage the Oracle Address in storage
-library OracleAddress {
-    /// @notice Storage slot of the Oracle Address
-    bytes32 internal constant ORACLE_ADDRESS_SLOT = bytes32(uint256(keccak256("river.state.oracleAddress")) - 1);
-
-    /// @notice Retrieve the Oracle Address
-    /// @return The Oracle Address
-    function get() internal view returns (address) {
-        return LibUnstructuredStorage.getStorageAddress(ORACLE_ADDRESS_SLOT);
-    }
-
-    /// @notice Sets the Oracle Address
-    /// @param _newValue New Oracle Address
-    function set(address _newValue) internal {
-        LibSanitize._notZeroAddress(_newValue);
-        LibUnstructuredStorage.setStorageAddress(ORACLE_ADDRESS_SLOT, _newValue);
-    }
-}
diff -ruN src/state/river/RedeemManagerAddress.sol state/river/RedeemManagerAddress.sol
--- src/state/river/RedeemManagerAddress.sol	2023-12-11 15:38:07
+++ state/river/RedeemManagerAddress.sol	2024-01-16 15:06:39
@@ -1,26 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-import "../../libraries/LibSanitize.sol";
-
-/// @title Redeem Manager Address Storage
-/// @notice Utility to manage the Redeem Manager Address in storage
-library RedeemManagerAddress {
-    /// @notice Storage slot of the Redeem Manager Address
-    bytes32 internal constant REDEEM_MANAGER_ADDRESS_SLOT =
-        bytes32(uint256(keccak256("river.state.redeemManagerAddress")) - 1);
-
-    /// @notice Retrieve the Redeem Manager Address
-    /// @return The Redeem Manager Address
-    function get() internal view returns (address) {
-        return LibUnstructuredStorage.getStorageAddress(REDEEM_MANAGER_ADDRESS_SLOT);
-    }
-
-    /// @notice Sets the Redeem Manager Address
-    /// @param _newValue New Redeem Manager Address
-    function set(address _newValue) internal {
-        LibSanitize._notZeroAddress(_newValue);
-        LibUnstructuredStorage.setStorageAddress(REDEEM_MANAGER_ADDRESS_SLOT, _newValue);
-    }
-}
diff -ruN src/state/river/ReportBounds.sol state/river/ReportBounds.sol
--- src/state/river/ReportBounds.sol	2023-12-11 15:38:07
+++ state/river/ReportBounds.sol	2024-01-16 15:06:39
@@ -1,53 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Report Bounds Storage
-/// @notice Utility to manage the Report Bounds in storage
-library ReportBounds {
-    /// @notice Storage slot of the Report Bounds
-    bytes32 internal constant REPORT_BOUNDS_SLOT = bytes32(uint256(keccak256("river.state.reportBounds")) - 1);
-
-    /// @notice The Report Bounds structure
-    struct ReportBoundsStruct {
-        /// @custom:attribute The maximum allowed annual apr, checked before submitting a report to River
-        uint256 annualAprUpperBound;
-        /// @custom:attribute The maximum allowed balance decrease, also checked before submitting a report to River
-        uint256 relativeLowerBound;
-    }
-
-    /// @notice The structure in storage
-    struct Slot {
-        /// @custom:attribute The structure in storage
-        ReportBoundsStruct value;
-    }
-
-    /// @notice Retrieve the Report Bounds from storage
-    /// @return The Report Bounds
-    function get() internal view returns (ReportBoundsStruct memory) {
-        bytes32 slot = REPORT_BOUNDS_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        return r.value;
-    }
-
-    /// @notice Set the Report Bounds in storage
-    /// @param _newReportBounds The new Report Bounds value
-    function set(ReportBoundsStruct memory _newReportBounds) internal {
-        bytes32 slot = REPORT_BOUNDS_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        r.value = _newReportBounds;
-    }
-}
diff -ruN src/state/river/Shares.sol state/river/Shares.sol
--- src/state/river/Shares.sol	2023-12-11 15:38:07
+++ state/river/Shares.sol	2024-01-16 15:06:39
@@ -1,23 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-
-/// @title Shares Count Storage
-/// @notice Utility to manage the Shares Count in storage
-library Shares {
-    /// @notice Storage slot of the Shares Count
-    bytes32 internal constant SHARES_SLOT = bytes32(uint256(keccak256("river.state.shares")) - 1);
-
-    /// @notice Retrieve the Shares Count
-    /// @return The Shares Count
-    function get() internal view returns (uint256) {
-        return LibUnstructuredStorage.getStorageUint256(SHARES_SLOT);
-    }
-
-    /// @notice Sets the Shares Count
-    /// @param _newValue New Shares Count
-    function set(uint256 _newValue) internal {
-        LibUnstructuredStorage.setStorageUint256(SHARES_SLOT, _newValue);
-    }
-}
diff -ruN src/state/river/SharesPerOwner.sol state/river/SharesPerOwner.sol
--- src/state/river/SharesPerOwner.sol	2023-12-11 15:38:07
+++ state/river/SharesPerOwner.sol	2024-01-16 15:06:39
@@ -1,47 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Shares Per Owner Storage
-/// @notice Utility to manage the Shares Per Owner in storage
-library SharesPerOwner {
-    /// @notice Storage slot of the Shares Per Owner
-    bytes32 internal constant SHARES_PER_OWNER_SLOT = bytes32(uint256(keccak256("river.state.sharesPerOwner")) - 1);
-
-    /// @notice Structure in storage
-    struct Slot {
-        /// @custom:attribute The mapping from an owner to its share count
-        mapping(address => uint256) value;
-    }
-
-    /// @notice Retrieve the share count for given owner
-    /// @param _owner The address to get the balance of
-    /// @return The amount of shares
-    function get(address _owner) internal view returns (uint256) {
-        bytes32 slot = SHARES_PER_OWNER_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        return r.value[_owner];
-    }
-
-    /// @notice Set the amount of shares for an owner
-    /// @param _owner The owner of the shares to edit
-    /// @param _newValue The new shares value for the owner
-    function set(address _owner, uint256 _newValue) internal {
-        bytes32 slot = SHARES_PER_OWNER_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        r.value[_owner] = _newValue;
-    }
-}
diff -ruN src/state/river/WithdrawalCredentials.sol state/river/WithdrawalCredentials.sol
--- src/state/river/WithdrawalCredentials.sol	2023-12-11 15:38:07
+++ state/river/WithdrawalCredentials.sol	2024-01-16 15:06:39
@@ -1,34 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibErrors.sol";
-import "../../libraries/LibUnstructuredStorage.sol";
-
-/// @title Withdrawal Credentials Storage
-/// @notice Utility to manage the Withdrawal Credentials in storage
-library WithdrawalCredentials {
-    /// @notice Storage slot of the Withdrawal Credentials
-    bytes32 internal constant WITHDRAWAL_CREDENTIALS_SLOT =
-        bytes32(uint256(keccak256("river.state.withdrawalCredentials")) - 1);
-
-    /// @notice Retrieve the Withdrawal Credentials
-    /// @return The Withdrawal Credentials
-    function get() internal view returns (bytes32) {
-        return LibUnstructuredStorage.getStorageBytes32(WITHDRAWAL_CREDENTIALS_SLOT);
-    }
-
-    /// @notice Retrieve the Withdrawal Credential under its address format
-    /// @return The Withdrawal Credentials in its address format
-    function getAddress() internal view returns (address) {
-        return LibUnstructuredStorage.getStorageAddress(WITHDRAWAL_CREDENTIALS_SLOT);
-    }
-
-    /// @notice Sets the Withdrawal Credentials
-    /// @param _newValue New Withdrawal Credentials
-    function set(bytes32 _newValue) internal {
-        if (_newValue == bytes32(0)) {
-            revert LibErrors.InvalidArgument();
-        }
-        LibUnstructuredStorage.setStorageBytes32(WITHDRAWAL_CREDENTIALS_SLOT, _newValue);
-    }
-}
diff -ruN src/state/shared/AdministratorAddress.sol state/shared/AdministratorAddress.sol
--- src/state/shared/AdministratorAddress.sol	2023-12-11 15:38:07
+++ state/shared/AdministratorAddress.sol	2024-01-16 15:06:39
@@ -1,26 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-import "../../libraries/LibSanitize.sol";
-
-/// @title Administrator Address Storage
-/// @notice Utility to manage the Administrator Address in storage
-library AdministratorAddress {
-    /// @notice Storage slot of the Administrator Address
-    bytes32 public constant ADMINISTRATOR_ADDRESS_SLOT =
-        bytes32(uint256(keccak256("river.state.administratorAddress")) - 1);
-
-    /// @notice Retrieve the Administrator Address
-    /// @return The Administrator Address
-    function get() internal view returns (address) {
-        return LibUnstructuredStorage.getStorageAddress(ADMINISTRATOR_ADDRESS_SLOT);
-    }
-
-    /// @notice Sets the Administrator Address
-    /// @param _newValue New Administrator Address
-    function set(address _newValue) internal {
-        LibSanitize._notZeroAddress(_newValue);
-        LibUnstructuredStorage.setStorageAddress(ADMINISTRATOR_ADDRESS_SLOT, _newValue);
-    }
-}
diff -ruN src/state/shared/ApprovalsPerOwner.sol state/shared/ApprovalsPerOwner.sol
--- src/state/shared/ApprovalsPerOwner.sol	2023-12-11 15:38:07
+++ state/shared/ApprovalsPerOwner.sol	2024-01-16 15:06:39
@@ -1,50 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Approvals Per Owner Storage
-/// @notice Utility to manage the Approvals Per Owner in storage
-library ApprovalsPerOwner {
-    /// @notice Storage slot of the Approvals Per Owner
-    bytes32 internal constant APPROVALS_PER_OWNER_SLOT =
-        bytes32(uint256(keccak256("river.state.approvalsPerOwner")) - 1);
-
-    /// @notice The structure in storage
-    struct Slot {
-        /// @custom:attribute The mapping from an owner to an operator to the approval amount
-        mapping(address => mapping(address => uint256)) value;
-    }
-
-    /// @notice Retrieve the approval for an owner to an operator
-    /// @param _owner The account that gave the approval
-    /// @param _operator The account receiving the approval
-    /// @return The value of the approval
-    function get(address _owner, address _operator) internal view returns (uint256) {
-        bytes32 slot = APPROVALS_PER_OWNER_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        return r.value[_owner][_operator];
-    }
-
-    /// @notice Set the approval value for an owner to an operator
-    /// @param _owner The account that gives the approval
-    /// @param _operator The account receiving the approval
-    /// @param _newValue The value of the approval
-    function set(address _owner, address _operator, uint256 _newValue) internal {
-        bytes32 slot = APPROVALS_PER_OWNER_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        r.value[_owner][_operator] = _newValue;
-    }
-}
diff -ruN src/state/shared/PendingAdministratorAddress.sol state/shared/PendingAdministratorAddress.sol
--- src/state/shared/PendingAdministratorAddress.sol	2023-12-11 15:38:07
+++ state/shared/PendingAdministratorAddress.sol	2024-01-16 15:06:39
@@ -1,24 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-
-/// @title Pending Administrator Address Storage
-/// @notice Utility to manage the Pending Administrator Address in storage
-library PendingAdministratorAddress {
-    /// @notice Storage slot of the Pending Administrator Address
-    bytes32 public constant PENDING_ADMINISTRATOR_ADDRESS_SLOT =
-        bytes32(uint256(keccak256("river.state.pendingAdministratorAddress")) - 1);
-
-    /// @notice Retrieve the Pending Administrator Address
-    /// @return The Pending Administrator Address
-    function get() internal view returns (address) {
-        return LibUnstructuredStorage.getStorageAddress(PENDING_ADMINISTRATOR_ADDRESS_SLOT);
-    }
-
-    /// @notice Sets the Pending Administrator Address
-    /// @param _newValue New Pending Administrator Address
-    function set(address _newValue) internal {
-        LibUnstructuredStorage.setStorageAddress(PENDING_ADMINISTRATOR_ADDRESS_SLOT, _newValue);
-    }
-}
diff -ruN src/state/shared/RiverAddress.sol state/shared/RiverAddress.sol
--- src/state/shared/RiverAddress.sol	2023-12-11 15:38:07
+++ state/shared/RiverAddress.sol	2024-01-16 15:06:39
@@ -1,25 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibSanitize.sol";
-import "../../libraries/LibUnstructuredStorage.sol";
-
-/// @title River Address Storage
-/// @notice Utility to manage the River Address in storage
-library RiverAddress {
-    /// @notice Storage slot of the River Address
-    bytes32 internal constant RIVER_ADDRESS_SLOT = bytes32(uint256(keccak256("river.state.riverAddress")) - 1);
-
-    /// @notice Retrieve the River Address
-    /// @return The River Address
-    function get() internal view returns (address) {
-        return LibUnstructuredStorage.getStorageAddress(RIVER_ADDRESS_SLOT);
-    }
-
-    /// @notice Sets the River Address
-    /// @param _newValue New River Address
-    function set(address _newValue) internal {
-        LibSanitize._notZeroAddress(_newValue);
-        LibUnstructuredStorage.setStorageAddress(RIVER_ADDRESS_SLOT, _newValue);
-    }
-}
diff -ruN src/state/shared/Version.sol state/shared/Version.sol
--- src/state/shared/Version.sol	2023-12-11 15:38:07
+++ state/shared/Version.sol	2024-01-16 15:06:39
@@ -1,23 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-
-/// @title Version Storage
-/// @notice Utility to manage the Version in storage
-library Version {
-    /// @notice Storage slot of the Version
-    bytes32 public constant VERSION_SLOT = bytes32(uint256(keccak256("river.state.version")) - 1);
-
-    /// @notice Retrieve the Version
-    /// @return The Version
-    function get() internal view returns (uint256) {
-        return LibUnstructuredStorage.getStorageUint256(VERSION_SLOT);
-    }
-
-    /// @notice Sets the Version
-    /// @param _newValue New Version
-    function set(uint256 _newValue) internal {
-        LibUnstructuredStorage.setStorageUint256(VERSION_SLOT, _newValue);
-    }
-}
diff -ruN src/state/slashingCoverage/BalanceForCoverage.sol state/slashingCoverage/BalanceForCoverage.sol
--- src/state/slashingCoverage/BalanceForCoverage.sol	2023-12-11 15:38:07
+++ state/slashingCoverage/BalanceForCoverage.sol	2024-01-16 15:06:39
@@ -1,24 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "../../libraries/LibUnstructuredStorage.sol";
-
-/// @title Balance For Coverage Value Storage
-/// @notice Utility to manage the Balance For Coverrage value in storage
-library BalanceForCoverage {
-    /// @notice Storage slot of the Balance For Coverage Address
-    bytes32 internal constant BALANCE_FOR_COVERAGE_SLOT =
-        bytes32(uint256(keccak256("river.state.balanceForCoverage")) - 1);
-
-    /// @notice Get the Balance for Coverage value
-    /// @return The balance for coverage value
-    function get() internal view returns (uint256) {
-        return LibUnstructuredStorage.getStorageUint256(BALANCE_FOR_COVERAGE_SLOT);
-    }
-
-    /// @notice Sets the Balance for Coverage value
-    /// @param _newValue New Balance for Coverage value
-    function set(uint256 _newValue) internal {
-        LibUnstructuredStorage.setStorageUint256(BALANCE_FOR_COVERAGE_SLOT, _newValue);
-    }
-}
diff -ruN src/state/tlc/IgnoreGlobalUnlockSchedule.sol state/tlc/IgnoreGlobalUnlockSchedule.sol
--- src/state/tlc/IgnoreGlobalUnlockSchedule.sol	2023-12-11 15:38:07
+++ state/tlc/IgnoreGlobalUnlockSchedule.sol	2024-01-16 15:06:39
@@ -1,49 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Global unlock schedule activation storage
-/// @notice Utility to manage the global unlock schedule activation mapping in storage
-/// @notice The global unlock schedule releases 1/24th of the total scheduled amount every month after the local lock end
-library IgnoreGlobalUnlockSchedule {
-    /// @notice Storage slot of the global unlock schedule activation mapping
-    bytes32 internal constant GLOBAL_UNLOCK_ACTIVATION_SLOT =
-        bytes32(uint256(keccak256("tlc.state.globalUnlockScheduleActivation")) - 1);
-
-    /// @notice Structure stored in storage slot
-    struct Slot {
-        /// @custom:attribute Mapping keeping track of activation per schedule
-        mapping(uint256 => bool) value;
-    }
-
-    /// @notice Retrieve the global unlock schedule activation value of a schedule, true if the global lock should be ignored
-    /// @param _scheduleId The schedule id
-    /// @return The global unlock activation value
-    function get(uint256 _scheduleId) internal view returns (bool) {
-        bytes32 slot = GLOBAL_UNLOCK_ACTIVATION_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        return r.value[_scheduleId];
-    }
-
-    /// @notice Sets the global unlock schedule activation value of a schedule
-    /// @param _scheduleId The id of the schedule to modify
-    /// @param _ignoreGlobalUnlock The value to set, true if the global lock should be ignored
-    function set(uint256 _scheduleId, bool _ignoreGlobalUnlock) internal {
-        bytes32 slot = GLOBAL_UNLOCK_ACTIVATION_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        r.value[_scheduleId] = _ignoreGlobalUnlock;
-    }
-}
diff -ruN src/state/tlc/VestingSchedules.1.sol state/tlc/VestingSchedules.1.sol
--- src/state/tlc/VestingSchedules.1.sol	2023-12-11 15:38:07
+++ state/tlc/VestingSchedules.1.sol	2024-01-16 15:06:39
@@ -1,97 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title VestingSchedulesV1 Storage
-/// @notice Utility to manage VestingSchedulesV1 in storage
-library VestingSchedulesV1 {
-    /// @notice Storage slot of the Vesting Schedules
-    bytes32 internal constant VESTING_SCHEDULES_SLOT =
-        bytes32(uint256(keccak256("erc20VestableVotes.state.schedules")) - 1);
-
-    struct VestingSchedule {
-        // start time of the vesting period
-        uint64 start;
-        // date at which the vesting is ended
-        // initially it is equal to start+duration then to revoke date in case of revoke
-        uint64 end;
-        // duration before which first tokens gets ownable
-        uint32 cliffDuration;
-        // duration before tokens gets unlocked. can exceed the duration of the vesting chedule
-        uint32 lockDuration;
-        // duration of the entire vesting (sum of all vesting period durations)
-        uint32 duration;
-        // duration of a single period of vesting
-        uint32 periodDuration;
-        // amount of tokens granted by the vesting schedule
-        uint256 amount;
-        // creator of the token vesting
-        address creator;
-        // beneficiary of tokens after they are releaseVestingScheduled
-        address beneficiary;
-        // whether the schedule can be revoked
-        bool revocable;
-    }
-
-    /// @notice The structure at the storage slot
-    struct SlotVestingSchedule {
-        /// @custom:attribute Array containing all the vesting schedules
-        VestingSchedule[] value;
-    }
-
-    /// @notice The VestingSchedule was not found
-    /// @param index vesting schedule index
-    error VestingScheduleNotFound(uint256 index);
-
-    /// @notice Retrieve the vesting schedule in storage
-    /// @param _index index of the vesting schedule
-    /// @return the vesting schedule
-    function get(uint256 _index) internal view returns (VestingSchedule storage) {
-        bytes32 slot = VESTING_SCHEDULES_SLOT;
-
-        SlotVestingSchedule storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        if (r.value.length <= _index) {
-            revert VestingScheduleNotFound(_index);
-        }
-
-        return r.value[_index];
-    }
-
-    /// @notice Get vesting schedule count in storage
-    /// @return The count of vesting schedule in storage
-    function getCount() internal view returns (uint256) {
-        bytes32 slot = VESTING_SCHEDULES_SLOT;
-
-        SlotVestingSchedule storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        return r.value.length;
-    }
-
-    /// @notice Add a new vesting schedule in storage
-    /// @param _newSchedule new vesting schedule to create
-    /// @return The size of the vesting schedule array after the operation
-    function push(VestingSchedule memory _newSchedule) internal returns (uint256) {
-        bytes32 slot = VESTING_SCHEDULES_SLOT;
-
-        SlotVestingSchedule storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        r.value.push(_newSchedule);
-
-        return r.value.length;
-    }
-}
diff -ruN src/state/tlc/VestingSchedules.2.sol state/tlc/VestingSchedules.2.sol
--- src/state/tlc/VestingSchedules.2.sol	2023-12-11 15:38:07
+++ state/tlc/VestingSchedules.2.sol	2024-01-16 15:06:39
@@ -1,125 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-import "./VestingSchedules.1.sol";
-
-/// @title VestingSchedulesV2 Storage
-/// @notice Utility to manage VestingSchedulesV2 in storage
-library VestingSchedulesV2 {
-    /// @notice Storage slot of the Vesting Schedules (note the slot is different from v1)
-    bytes32 internal constant VESTING_SCHEDULES_SLOT =
-        bytes32(uint256(keccak256("erc20VestableVotes.state.v2.schedules")) - 1);
-
-    struct VestingSchedule {
-        // start time of the vesting period
-        uint64 start;
-        // date at which the vesting is ended
-        // initially it is equal to start+duration then to revoke date in case of revoke
-        uint64 end;
-        // duration before which first tokens gets ownable
-        uint32 cliffDuration;
-        // duration before tokens gets unlocked. can exceed the duration of the vesting chedule
-        uint32 lockDuration;
-        // duration of the entire vesting (sum of all vesting period durations)
-        uint32 duration;
-        // duration of a single period of vesting
-        uint32 periodDuration;
-        // amount of tokens granted by the vesting schedule
-        uint256 amount;
-        // creator of the token vesting
-        address creator;
-        // beneficiary of tokens after they are releaseVestingScheduled
-        address beneficiary;
-        // whether the schedule can be revoked
-        bool revocable;
-        // amount of released tokens
-        uint256 releasedAmount;
-    }
-
-    /// @notice The structure at the storage slot
-    struct SlotVestingSchedule {
-        /// @custom:attribute Array containing all the vesting schedules
-        VestingSchedule[] value;
-    }
-
-    /// @notice The VestingSchedule was not found
-    /// @param index vesting schedule index
-    error VestingScheduleNotFound(uint256 index);
-
-    /// @notice Retrieve the vesting schedule in storage
-    /// @param _index index of the vesting schedule
-    /// @return the vesting schedule
-    function get(uint256 _index) internal view returns (VestingSchedule storage) {
-        bytes32 slot = VESTING_SCHEDULES_SLOT;
-
-        SlotVestingSchedule storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        if (r.value.length <= _index) {
-            revert VestingScheduleNotFound(_index);
-        }
-
-        return r.value[_index];
-    }
-
-    /// @notice Get vesting schedule count in storage
-    /// @return The count of vesting schedule in storage
-    function getCount() internal view returns (uint256) {
-        bytes32 slot = VESTING_SCHEDULES_SLOT;
-
-        SlotVestingSchedule storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        return r.value.length;
-    }
-
-    /// @notice Add a new vesting schedule in storage
-    /// @param _newSchedule new vesting schedule to create
-    /// @return The size of the vesting schedule array after the operation
-    function push(VestingSchedule memory _newSchedule) internal returns (uint256) {
-        bytes32 slot = VESTING_SCHEDULES_SLOT;
-
-        SlotVestingSchedule storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        r.value.push(_newSchedule);
-
-        return r.value.length;
-    }
-
-    /// @notice Migrate a VestingSchedule from v1 to v2
-    /// @notice Takes a VestingSchedule in v1 format in stores it in v2 format
-    /// @param _index of the schedule in v1 to be migrated
-    /// @param _releasedAmount The released amount to keep in storage
-    /// @return The index of the created schedule in v2 format
-    function migrateVestingScheduleFromV1(uint256 _index, uint256 _releasedAmount) internal returns (uint256) {
-        VestingSchedulesV1.VestingSchedule memory scheduleV1 = VestingSchedulesV1.get(_index);
-        VestingSchedulesV2.VestingSchedule memory scheduleV2 = VestingSchedulesV2.VestingSchedule({
-            start: scheduleV1.start,
-            end: scheduleV1.end,
-            lockDuration: scheduleV1.lockDuration,
-            cliffDuration: scheduleV1.cliffDuration,
-            duration: scheduleV1.duration,
-            periodDuration: scheduleV1.periodDuration,
-            amount: scheduleV1.amount,
-            creator: scheduleV1.creator,
-            beneficiary: scheduleV1.beneficiary,
-            revocable: scheduleV1.revocable,
-            releasedAmount: _releasedAmount
-        });
-
-        return push(scheduleV2) - 1;
-    }
-}
diff -ruN src/state/wlseth/BalanceOf.sol state/wlseth/BalanceOf.sol
--- src/state/wlseth/BalanceOf.sol	2023-12-11 15:38:07
+++ state/wlseth/BalanceOf.sol	2024-01-16 15:06:39
@@ -1,47 +0,0 @@
-//SPDX-License-Identifier: BUSL-1.1
-pragma solidity 0.8.20;
-
-/// @title Balance Storage
-/// @notice Utility to manage the Balance in storage
-library BalanceOf {
-    /// @notice Storage slot of the Balance
-    bytes32 internal constant BALANCE_OF_SLOT = bytes32(uint256(keccak256("river.state.balanceOf")) - 1);
-
-    /// @notice The structure in storage
-    struct Slot {
-        /// @custom:attribute The mapping from an owner to its balance
-        mapping(address => uint256) value;
-    }
-
-    /// @notice Retrieve balance of an owner
-    /// @param _owner The owner of the balance
-    /// @return The balance of the owner
-    function get(address _owner) internal view returns (uint256) {
-        bytes32 slot = BALANCE_OF_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        return r.value[_owner];
-    }
-
-    /// @notice Set the balance of an owner
-    /// @param _owner The owner to change the balance of
-    /// @param _newValue New balance value for the owner
-    function set(address _owner, uint256 _newValue) internal {
-        bytes32 slot = BALANCE_OF_SLOT;
-
-        Slot storage r;
-
-        // solhint-disable-next-line no-inline-assembly
-        assembly {
-            r.slot := slot
-        }
-
-        r.value[_owner] = _newValue;
-    }
-}
