--- ../contracts/src/RedeemManager.1.sol	2024-01-29 14:26:37.854553848 +0200
+++ 	2024-01-29 14:40:35.744454296 +0200
@@ -26,11 +26,11 @@
     int64 internal constant RESOLVE_FULLY_CLAIMED = -3;
 
     /// @notice Status value returned when fully claiming a redeem request
-    uint8 internal constant CLAIM_FULLY_CLAIMED = 0;
+    uint8 public constant CLAIM_FULLY_CLAIMED = 0;
     /// @notice Status value returned when partially claiming a redeem request
-    uint8 internal constant CLAIM_PARTIALLY_CLAIMED = 1;
+    uint8 public constant CLAIM_PARTIALLY_CLAIMED = 1;
     /// @notice Status value returned when a redeem request is already claimed and skipped during a claim
-    uint8 internal constant CLAIM_SKIPPED = 2;
+    uint8 public constant CLAIM_SKIPPED = 2;
 
     modifier onlyRiver() {
         if (msg.sender != RiverAddress.get()) {
@@ -369,12 +369,14 @@
                 LibUint256.min(_params.redeemRequest.amount, withdrawalEventEndPosition - _params.redeemRequest.height);
             // we can now compute the equivalent eth amount based on the withdrawal event details
             vars.ethAmount =
-                (vars.matchingAmount * _params.withdrawalEvent.withdrawnEth) / _params.withdrawalEvent.amount;
+            //    (vars.matchingAmount * _params.withdrawalEvent.withdrawnEth) / _params.withdrawalEvent.amount;
+            math.mulDiv(vars.matchingAmount, _params.withdrawalEvent.withdrawnEth, _params.withdrawalEvent.amount);
 
             // as each request has a maximum withdrawable amount, we verify that the eth amount is not exceeding this amount, pro rata
             // the amount that is matched
             uint256 maxRedeemableEthAmount =
-                (vars.matchingAmount * _params.redeemRequest.maxRedeemableEth) / _params.redeemRequest.amount;
+            //    (vars.matchingAmount * _params.redeemRequest.maxRedeemableEth) / _params.redeemRequest.amount;
+            math.mulDiv(vars.matchingAmount, _params.redeemRequest.maxRedeemableEth, _params.redeemRequest.amount);
 
             if (maxRedeemableEthAmount < vars.ethAmount) {
                 vars.exceedingEthAmount = vars.ethAmount - maxRedeemableEthAmount;
@@ -529,3 +531,9 @@
         RedeemDemand.set(_newValue);
     }
 }
+
+library math {
+    function mulDiv(uint256 x, uint256 y, uint256 z) internal pure returns (uint256) {
+        return (x * y) / z;
+    }
+}
--- ../contracts/src/River.1.sol	2024-01-29 14:26:37.854553848 +0200
+++ 	2024-01-29 14:37:42.534475205 +0200
@@ -369,9 +369,11 @@
         }
         uint256 newTotalBalance = _assetBalance();
         uint256 globalFee = GlobalFee.get();
-        uint256 numerator = _amount * oldTotalSupply * globalFee;
+        //uint256 numerator = _amount * oldTotalSupply * globalFee;
+        //uint256 denominator = (newTotalBalance * LibBasisPoints.BASIS_POINTS_MAX) - (_amount * globalFee);
+        //uint256 sharesToMint = denominator == 0 ? 0 : (numerator / denominator);
         uint256 denominator = (newTotalBalance * LibBasisPoints.BASIS_POINTS_MAX) - (_amount * globalFee);
-        uint256 sharesToMint = denominator == 0 ? 0 : (numerator / denominator);
+        uint256 sharesToMint = denominator == 0 ? 0 : math.mulDiv(_amount * oldTotalSupply, globalFee, denominator);
 
         if (sharesToMint > 0) {
             address collector = CollectorAddress.get();
@@ -589,12 +591,15 @@
         // this value is computed by subtracting the current balance to deposit from the underlying asset balance
         uint256 currentMaxDailyCommittableAmount = LibUint256.max(
             dcl.minDailyNetCommittableAmount,
-            (uint256(dcl.maxDailyRelativeCommittableAmount) * (underlyingAssetBalance - currentBalanceToDeposit))
-                / LibBasisPoints.BASIS_POINTS_MAX
+            //(uint256(dcl.maxDailyRelativeCommittableAmount) * (underlyingAssetBalance - currentBalanceToDeposit))
+            //    / LibBasisPoints.BASIS_POINTS_MAX
+            math.mulDiv(uint256(dcl.maxDailyRelativeCommittableAmount), 
+                underlyingAssetBalance - currentBalanceToDeposit, LibBasisPoints.BASIS_POINTS_MAX)
         );
         // we adapt the value for the reporting period by using the asset balance as upper bound
         uint256 currentMaxCommittableAmount =
-            LibUint256.min((currentMaxDailyCommittableAmount * _period) / 1 days, currentBalanceToDeposit);
+            //LibUint256.min((currentMaxDailyCommittableAmount * _period) / 1 days, currentBalanceToDeposit);
+            LibUint256.min(math.mulDiv(currentMaxDailyCommittableAmount, _period, 1 days), currentBalanceToDeposit);
         // we only commit multiples of 32 ETH
         currentMaxCommittableAmount = (currentMaxCommittableAmount / DEPOSIT_SIZE) * DEPOSIT_SIZE;
 
--- ../contracts/src/components/SharesManager.1.sol	2024-01-29 14:26:37.864553848 +0200
+++ 	2024-01-29 14:37:42.544475203 +0200
@@ -202,7 +202,8 @@
             return 0;
         }
 
-        return ((_shares * _assetBalance())) / _totalSharesValue;
+        //return ((_shares * _assetBalance())) / _totalSharesValue;
+        return math.mulDiv(_shares, _assetBalance(), _totalSharesValue);
     }
 
     /// @notice Internal utility to retrieve the shares count for a given underlying asset amount
@@ -215,7 +216,8 @@
             return 0;
         }
 
-        return (_balance * _totalSharesValue) / _assetBalance();
+        //return (_balance * _totalSharesValue) / _assetBalance();
+        return  math.mulDiv(_balance, _totalSharesValue, _assetBalance());
     }
 
     /// @notice Internal utility to mint shares for the specified user
@@ -230,7 +232,8 @@
             sharesToMint = _underlyingAssetValue;
             _mintRawShares(_owner, _underlyingAssetValue);
         } else {
-            sharesToMint = (_underlyingAssetValue * _totalSupply()) / oldTotalAssetBalance;
+            //sharesToMint = (_underlyingAssetValue * _totalSupply()) / oldTotalAssetBalance;
+            sharesToMint = math.mulDiv(_underlyingAssetValue, _totalSupply(), oldTotalAssetBalance);
             _mintRawShares(_owner, sharesToMint);
         }
     }
@@ -267,3 +270,10 @@
         emit SetTotalSupply(newTotalSupply);
     }
 }
+
+library math {
+    function mulDiv(uint256 x, uint256 y, uint256 z) internal pure returns (uint256) {
+        return (x * y) / z;
+    }
+}
+
--- ../contracts/src/components/OracleManager.1.sol	2024-01-29 14:26:37.874553846 +0200
+++ 	2024-01-29 14:37:42.544475203 +0200
@@ -255,13 +255,7 @@
         ConsensusLayerDataReportingTrace trace;
     }
 
-    /// @inheritdoc IOracleManagerV1
-    function setConsensusLayerData(IOracleManagerV1.ConsensusLayerReport calldata _report) external {
-        // only the oracle is allowed to call this endpoint
-        if (msg.sender != OracleAddress.get()) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-
+    function helper1_fillUpVarsAndPullCL(IOracleManagerV1.ConsensusLayerReport calldata _report) public returns (ConsensusLayerDataReportingVariables memory) {
         CLSpec.CLSpecStruct memory cls = CLSpec.get();
 
         // we start by verifying that the reported epoch is valid based on the consensus layer spec
@@ -320,20 +314,108 @@
             _pullCLFunds(vars.skimmedAmountIncrease, vars.exitedAmountIncrease);
         }
 
-        {
-            // we update the system parameters, this will have an impact on how the total underlying balance is computed
-            IOracleManagerV1.StoredConsensusLayerReport memory storedReport;
+        return vars;
+    }
+
+    function helper2_updateLastReport(IOracleManagerV1.ConsensusLayerReport calldata _report) public {
+        // we update the system parameters, this will have an impact on how the total underlying balance is computed
+        IOracleManagerV1.StoredConsensusLayerReport memory storedReport;
+
+        storedReport.epoch = _report.epoch;
+        storedReport.validatorsBalance = _report.validatorsBalance;
+        storedReport.validatorsSkimmedBalance = _report.validatorsSkimmedBalance;
+        storedReport.validatorsExitedBalance = _report.validatorsExitedBalance;
+        storedReport.validatorsExitingBalance = _report.validatorsExitingBalance;
+        storedReport.validatorsCount = _report.validatorsCount;
+        storedReport.rebalanceDepositToRedeemMode = _report.rebalanceDepositToRedeemMode;
+        storedReport.slashingContainmentMode = _report.slashingContainmentMode;
+        LastConsensusLayerReport.set(storedReport);
+    }
+
+    function helper3_checkBounds(ConsensusLayerDataReportingVariables memory vars, ReportBounds.ReportBoundsStruct memory rb, uint256 maxDecrease) public {
+        if (
+                vars.postReportUnderlyingBalance
+                    < vars.preReportUnderlyingBalance - LibUint256.min(maxDecrease, vars.preReportUnderlyingBalance)
+        ) {
+            revert TotalValidatorBalanceDecreaseOutOfBound(
+                vars.preReportUnderlyingBalance,
+                vars.postReportUnderlyingBalance,
+                vars.timeElapsedSinceLastReport,
+                rb.relativeLowerBound
+            );
+        }
+    }
+
+    function helper4_pullELFees(ConsensusLayerDataReportingVariables memory vars) public returns (ConsensusLayerDataReportingVariables memory) {
+        // if we have available amount to upper bound after the reporting values are applied
+        if (vars.availableAmountToUpperBound > 0) {
+            // we pull the funds from the execution layer fee recipient
+            vars.trace.pulledELFees = _pullELFees(vars.availableAmountToUpperBound);
+            // we update the rewards
+            vars.trace.rewards += vars.trace.pulledELFees;
+            // we update the available amount accordingly
+            vars.availableAmountToUpperBound -= vars.trace.pulledELFees;
+        }
+        return vars;
+    }
+
+    function helper5_pullRedeemManagerExceedingEth(ConsensusLayerDataReportingVariables memory vars) public {
+        // if we have available amount to upper bound after the execution layer fees are pulled
+        if (vars.availableAmountToUpperBound > 0) {
+            // we pull the funds from the exceeding eth buffer of the redeem manager
+            vars.trace.pulledRedeemManagerExceedingEthBuffer =
+                _pullRedeemManagerExceedingEth(vars.availableAmountToUpperBound);
+            // we update the available amount accordingly
+            vars.availableAmountToUpperBound -= vars.trace.pulledRedeemManagerExceedingEthBuffer;
+        }
+    }
 
-            storedReport.epoch = _report.epoch;
-            storedReport.validatorsBalance = _report.validatorsBalance;
-            storedReport.validatorsSkimmedBalance = _report.validatorsSkimmedBalance;
-            storedReport.validatorsExitedBalance = _report.validatorsExitedBalance;
-            storedReport.validatorsExitingBalance = _report.validatorsExitingBalance;
-            storedReport.validatorsCount = _report.validatorsCount;
-            storedReport.rebalanceDepositToRedeemMode = _report.rebalanceDepositToRedeemMode;
-            storedReport.slashingContainmentMode = _report.slashingContainmentMode;
-            LastConsensusLayerReport.set(storedReport);
+    function helper6_pullCoverageFunds(ConsensusLayerDataReportingVariables memory vars) public {
+        // if we have available amount to upper bound after pulling the exceeding eth buffer, we attempt to pull coverage funds
+        if (vars.availableAmountToUpperBound > 0) {
+            // we pull the funds from the coverage recipient
+            vars.trace.pulledCoverageFunds = _pullCoverageFunds(vars.availableAmountToUpperBound);
+            // we do not update the rewards as coverage is not considered rewards
+            // we do not update the available amount as there are no more pulling actions to perform afterwards
         }
+    }
+
+    function helper7_onEarnings(ConsensusLayerDataReportingVariables memory vars) public {
+        // if our rewards are not null, we dispatch the fee to the collector
+        if (vars.trace.rewards > 0) {
+            _onEarnings(vars.trace.rewards);
+        }
+    }
+    function helper8_requestExitsBasedOnRedeemDemandAfterRebalancings(ConsensusLayerDataReportingVariables memory vars, IOracleManagerV1.ConsensusLayerReport calldata _report) public {
+        _requestExitsBasedOnRedeemDemandAfterRebalancings(
+            _report.validatorsExitingBalance,
+            _report.stoppedValidatorCountPerOperator,
+            _report.rebalanceDepositToRedeemMode,
+            _report.slashingContainmentMode
+        );
+    }
+    function helper9_reportWithdrawToRedeemManager(ConsensusLayerDataReportingVariables memory vars) public {
+        // we use the updated balanceToRedeem value to report a withdraw event on the redeem manager
+        _reportWithdrawToRedeemManager();
+    }
+    function helper10_skimExcessBalanceToRedeem(ConsensusLayerDataReportingVariables memory vars) public {
+        // if funds are left in the balance to redeem, we move them to the deposit balance
+        _skimExcessBalanceToRedeem();
+    }
+    function helper11_commitBalanceToDeposit(ConsensusLayerDataReportingVariables memory vars) public {
+        // we update the committable amount based on daily maximum allowed
+        _commitBalanceToDeposit(vars.timeElapsedSinceLastReport);
+    }
+
+    /// @inheritdoc IOracleManagerV1
+    function setConsensusLayerData(IOracleManagerV1.ConsensusLayerReport calldata _report) external {
+        // only the oracle is allowed to call this endpoint
+        if (msg.sender != OracleAddress.get()) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+        ConsensusLayerDataReportingVariables memory vars = helper1_fillUpVarsAndPullCL(_report);
+
+        helper2_updateLastReport(_report);
 
         ReportBounds.ReportBoundsStruct memory rb = ReportBounds.get();
 
@@ -370,70 +452,28 @@
             uint256 maxDecrease = _maxDecrease(rb, vars.preReportUnderlyingBalance);
 
             // we verify that the bound is not crossed
-            if (
-                vars.postReportUnderlyingBalance
-                    < vars.preReportUnderlyingBalance - LibUint256.min(maxDecrease, vars.preReportUnderlyingBalance)
-            ) {
-                revert TotalValidatorBalanceDecreaseOutOfBound(
-                    vars.preReportUnderlyingBalance,
-                    vars.postReportUnderlyingBalance,
-                    vars.timeElapsedSinceLastReport,
-                    rb.relativeLowerBound
-                );
-            }
+            helper3_checkBounds(vars, rb, maxDecrease);
 
             // we update the available amount to upper bound to be equal to the maximum allowed increase plus the negative delta due to the loss
             vars.availableAmountToUpperBound =
                 maxIncrease + (vars.preReportUnderlyingBalance - vars.postReportUnderlyingBalance);
         }
 
-        // if we have available amount to upper bound after the reporting values are applied
-        if (vars.availableAmountToUpperBound > 0) {
-            // we pull the funds from the execution layer fee recipient
-            vars.trace.pulledELFees = _pullELFees(vars.availableAmountToUpperBound);
-            // we update the rewards
-            vars.trace.rewards += vars.trace.pulledELFees;
-            // we update the available amount accordingly
-            vars.availableAmountToUpperBound -= vars.trace.pulledELFees;
-        }
+        helper4_pullELFees(vars);
 
-        // if we have available amount to upper bound after the execution layer fees are pulled
-        if (vars.availableAmountToUpperBound > 0) {
-            // we pull the funds from the exceeding eth buffer of the redeem manager
-            vars.trace.pulledRedeemManagerExceedingEthBuffer =
-                _pullRedeemManagerExceedingEth(vars.availableAmountToUpperBound);
-            // we update the available amount accordingly
-            vars.availableAmountToUpperBound -= vars.trace.pulledRedeemManagerExceedingEthBuffer;
-        }
+        helper5_pullRedeemManagerExceedingEth(vars);
 
-        // if we have available amount to upper bound after pulling the exceeding eth buffer, we attempt to pull coverage funds
-        if (vars.availableAmountToUpperBound > 0) {
-            // we pull the funds from the coverage recipient
-            vars.trace.pulledCoverageFunds = _pullCoverageFunds(vars.availableAmountToUpperBound);
-            // we do not update the rewards as coverage is not considered rewards
-            // we do not update the available amount as there are no more pulling actions to perform afterwards
-        }
+        helper6_pullCoverageFunds(vars);
 
-        // if our rewards are not null, we dispatch the fee to the collector
-        if (vars.trace.rewards > 0) {
-            _onEarnings(vars.trace.rewards);
-        }
+        helper7_onEarnings(vars);
 
-        _requestExitsBasedOnRedeemDemandAfterRebalancings(
-            _report.validatorsExitingBalance,
-            _report.stoppedValidatorCountPerOperator,
-            _report.rebalanceDepositToRedeemMode,
-            _report.slashingContainmentMode
-        );
+        helper8_requestExitsBasedOnRedeemDemandAfterRebalancings(vars, _report);
 
-        // we use the updated balanceToRedeem value to report a withdraw event on the redeem manager
-        _reportWithdrawToRedeemManager();
+        helper9_reportWithdrawToRedeemManager(vars);
 
-        // if funds are left in the balance to redeem, we move them to the deposit balance
-        _skimExcessBalanceToRedeem();
+        helper10_skimExcessBalanceToRedeem(vars);
 
-        // we update the committable amount based on daily maximum allowed
-        _commitBalanceToDeposit(vars.timeElapsedSinceLastReport);
+        helper11_commitBalanceToDeposit(vars);
 
         // we emit a summary event with all the reporting details
         emit ProcessedConsensusLayerReport(_report, vars.trace);
@@ -494,4 +534,4 @@
     {
         return (_epochNow - _epochPast) * (_cls.secondsPerSlot * _cls.slotsPerEpoch);
     }
-}
+}
\ No newline at end of file
