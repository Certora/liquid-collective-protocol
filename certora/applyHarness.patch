Binary files src/.DS_Store and contracts/src/.DS_Store differ
diff -ruN src/RedeemManager.1.sol contracts/src/RedeemManager.1.sol
--- src/RedeemManager.1.sol	2023-12-15 14:04:57
+++ contracts/src/RedeemManager.1.sol	2024-01-16 15:06:39
@@ -369,12 +369,14 @@
                 LibUint256.min(_params.redeemRequest.amount, withdrawalEventEndPosition - _params.redeemRequest.height);
             // we can now compute the equivalent eth amount based on the withdrawal event details
             vars.ethAmount =
-                (vars.matchingAmount * _params.withdrawalEvent.withdrawnEth) / _params.withdrawalEvent.amount;
+                mulDivDown(vars.matchingAmount, _params.withdrawalEvent.withdrawnEth, _params.withdrawalEvent.amount);
+                // (vars.matchingAmount * _params.withdrawalEvent.withdrawnEth) / _params.withdrawalEvent.amount; // Munged by Certora
 
             // as each request has a maximum withdrawable amount, we verify that the eth amount is not exceeding this amount, pro rata
             // the amount that is matched
             uint256 maxRedeemableEthAmount =
-                (vars.matchingAmount * _params.redeemRequest.maxRedeemableEth) / _params.redeemRequest.amount;
+                mulDivDown(vars.matchingAmount, _params.redeemRequest.maxRedeemableEth, _params.redeemRequest.amount);
+                // (vars.matchingAmount * _params.redeemRequest.maxRedeemableEth) / _params.redeemRequest.amount; // Munged by Certora
 
             if (maxRedeemableEthAmount < vars.ethAmount) {
                 vars.exceedingEthAmount = vars.ethAmount - maxRedeemableEthAmount;
@@ -527,5 +529,9 @@
     function _setRedeemDemand(uint256 _newValue) internal {
         emit SetRedeemDemand(RedeemDemand.get(), _newValue);
         RedeemDemand.set(_newValue);
+    }
+
+    function mulDivDown(uint256 a, uint256 b, uint256 c) internal pure returns (uint256 res) {
+            res = a * b / c;
     }
 }
diff -ruN src/River.1.sol contracts/src/River.1.sol
--- src/River.1.sol	2024-01-16 15:03:11
+++ contracts/src/River.1.sol	2024-01-16 15:19:47
@@ -28,6 +28,11 @@
 import "./state/river/MetadataURI.sol";
 import "./state/river/LastConsensusLayerReport.sol";
 
+// munged by certora
+// interface ICVL {
+//     function increment_onDepositCounter() external view returns(bool);
+// }
+
 /// @title River (v1)
 /// @author Kiln
 /// @notice This contract merges all the manager contracts and implements all the virtual methods stitching all components together
@@ -298,10 +303,13 @@
         }
     }
 
+    function _onDepositCalledMunged(address _depositor, address _recipient, uint256 _amount) internal {} // munged by certora, this can be fixed once finished with CERT-4706
     /// @notice Overridden handler called whenever a user deposits ETH to the system. Mints the adequate amount of shares.
     /// @param _depositor User address that made the deposit
     /// @param _amount Amount of ETH deposited
     function _onDeposit(address _depositor, address _recipient, uint256 _amount) internal override {
+        // ICVL(address(0xdeadc0de)).increment_onDepositCounter();
+        _onDepositCalledMunged(_depositor, _recipient, _amount); // munged by Certora
         uint256 mintedShares = SharesManagerV1._mintShares(_depositor, _amount);
         IAllowlistV1 allowlist = IAllowlistV1(AllowlistAddress.get());
         if (_depositor == _recipient) {
@@ -360,9 +368,11 @@
         return collectedCoverageFunds;
     }
 
+    function _onEarningsCalledMunged(uint256 _profits) internal {} // munged by Certora, this can be fixed once finished with CERT-4706
     /// @notice Overridden handler called whenever the balance of ETH handled by the system increases. Computes the fees paid to the collector
     /// @param _amount Additional ETH received
     function _onEarnings(uint256 _amount) internal override {
+        _onEarningsCalledMunged(_amount); // munged by Certora
         uint256 oldTotalSupply = _totalSupply();
         if (oldTotalSupply == 0) {
             revert ZeroMintedShares();
diff -ruN src/components/OracleManager.1.sol contracts/src/components/OracleManager.1.sol
--- src/components/OracleManager.1.sol	2024-01-15 16:50:23
+++ contracts/src/components/OracleManager.1.sol	2024-01-24 14:17:25
@@ -255,13 +255,7 @@
         ConsensusLayerDataReportingTrace trace;
     }
 
-    /// @inheritdoc IOracleManagerV1
-    function setConsensusLayerData(IOracleManagerV1.ConsensusLayerReport calldata _report) external {
-        // only the oracle is allowed to call this endpoint
-        if (msg.sender != OracleAddress.get()) {
-            revert LibErrors.Unauthorized(msg.sender);
-        }
-
+    function helper1(IOracleManagerV1.ConsensusLayerReport calldata _report) public returns (ConsensusLayerDataReportingVariables memory) {
         CLSpec.CLSpecStruct memory cls = CLSpec.get();
 
         // we start by verifying that the reported epoch is valid based on the consensus layer spec
@@ -313,13 +307,10 @@
 
         // we retrieve the current total underlying balance before any reporting data is applied to the system
         vars.preReportUnderlyingBalance = _assetBalance();
+        return vars;
+    }
 
-        // if we have new exited / skimmed eth available, we pull funds from the consensus layer recipient
-        if (vars.exitedAmountIncrease + vars.skimmedAmountIncrease > 0) {
-            // this method pulls and updates ethToDeposit / ethToRedeem accordingly
-            _pullCLFunds(vars.skimmedAmountIncrease, vars.exitedAmountIncrease);
-        }
-
+    function helper2(IOracleManagerV1.ConsensusLayerReport calldata _report) public {
         {
             // we update the system parameters, this will have an impact on how the total underlying balance is computed
             IOracleManagerV1.StoredConsensusLayerReport memory storedReport;
@@ -334,7 +325,39 @@
             storedReport.slashingContainmentMode = _report.slashingContainmentMode;
             LastConsensusLayerReport.set(storedReport);
         }
+    }
 
+    function helper3_checkBounds(ConsensusLayerDataReportingVariables memory vars, ReportBounds.ReportBoundsStruct memory rb, uint256 maxDecrease) public {
+        if (
+                vars.postReportUnderlyingBalance
+                    < vars.preReportUnderlyingBalance - LibUint256.min(maxDecrease, vars.preReportUnderlyingBalance)
+        ) {
+            revert TotalValidatorBalanceDecreaseOutOfBound(
+                vars.preReportUnderlyingBalance,
+                vars.postReportUnderlyingBalance,
+                vars.timeElapsedSinceLastReport,
+                rb.relativeLowerBound
+            );
+        }
+    }
+
+    /// @inheritdoc IOracleManagerV1
+    function setConsensusLayerData(IOracleManagerV1.ConsensusLayerReport calldata _report) external {
+        // only the oracle is allowed to call this endpoint
+        if (msg.sender != OracleAddress.get()) {
+            revert LibErrors.Unauthorized(msg.sender);
+        }
+        ConsensusLayerDataReportingVariables memory vars = helper1(_report);
+
+
+        // if we have new exited / skimmed eth available, we pull funds from the consensus layer recipient
+        if (vars.exitedAmountIncrease + vars.skimmedAmountIncrease > 0) {
+            // this method pulls and updates ethToDeposit / ethToRedeem accordingly
+            _pullCLFunds(vars.skimmedAmountIncrease, vars.exitedAmountIncrease);
+        }
+
+        helper2(_report);
+
         ReportBounds.ReportBoundsStruct memory rb = ReportBounds.get();
 
         // we compute the maximum allowed increase in balance based on the pre report value
@@ -370,17 +393,8 @@
             uint256 maxDecrease = _maxDecrease(rb, vars.preReportUnderlyingBalance);
 
             // we verify that the bound is not crossed
-            if (
-                vars.postReportUnderlyingBalance
-                    < vars.preReportUnderlyingBalance - LibUint256.min(maxDecrease, vars.preReportUnderlyingBalance)
-            ) {
-                revert TotalValidatorBalanceDecreaseOutOfBound(
-                    vars.preReportUnderlyingBalance,
-                    vars.postReportUnderlyingBalance,
-                    vars.timeElapsedSinceLastReport,
-                    rb.relativeLowerBound
-                );
-            }
+            helper3_checkBounds(vars, rb, maxDecrease);
+            
 
             // we update the available amount to upper bound to be equal to the maximum allowed increase plus the negative delta due to the loss
             vars.availableAmountToUpperBound =
@@ -494,4 +508,4 @@
     {
         return (_epochNow - _epochPast) * (_cls.secondsPerSlot * _cls.slotsPerEpoch);
     }
-}
+}
\ No newline at end of file
diff -ruN src/components/SharesManager.1.sol contracts/src/components/SharesManager.1.sol
--- src/components/SharesManager.1.sol	2023-12-11 15:38:07
+++ contracts/src/components/SharesManager.1.sol	2024-01-16 15:06:39
@@ -192,6 +192,11 @@
         return true;
     }
 
+    function mulDivDown(uint256 a, uint256 b, uint256 c) internal pure returns (uint256 res)
+    {
+        res = a * b / c;
+    }
+
     /// @notice Internal utility to retrieve the underlying asset balance for the given shares
     /// @param _shares Amount of shares to convert
     /// @return The balance from the given shares
@@ -202,7 +207,8 @@
             return 0;
         }
 
-        return ((_shares * _assetBalance())) / _totalSharesValue;
+        // return ((_shares * _assetBalance())) / _totalSharesValue;
+        return mulDivDown(_shares , _assetBalance(), _totalSharesValue); // Munged by Certora
     }
 
     /// @notice Internal utility to retrieve the shares count for a given underlying asset amount
@@ -215,7 +221,8 @@
             return 0;
         }
 
-        return (_balance * _totalSharesValue) / _assetBalance();
+        // return (_balance * _totalSharesValue) / _assetBalance();
+        return mulDivDown(_balance, _totalSharesValue, _assetBalance()); // Munged by Certora
     }
 
     /// @notice Internal utility to mint shares for the specified user
@@ -230,7 +237,8 @@
             sharesToMint = _underlyingAssetValue;
             _mintRawShares(_owner, _underlyingAssetValue);
         } else {
-            sharesToMint = (_underlyingAssetValue * _totalSupply()) / oldTotalAssetBalance;
+            // sharesToMint = (_underlyingAssetValue * _totalSupply()) / oldTotalAssetBalance;
+            sharesToMint = mulDivDown(_underlyingAssetValue, _totalSupply(), oldTotalAssetBalance); // Munged by Certora
             _mintRawShares(_owner, sharesToMint);
         }
     }
