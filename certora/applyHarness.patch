Binary files src/.DS_Store and contracts/src/.DS_Store differ
diff -ruN src/RedeemManager.1.sol contracts/src/RedeemManager.1.sol
--- src/RedeemManager.1.sol	2023-12-15 14:04:57
+++ contracts/src/RedeemManager.1.sol	2024-01-16 15:06:39
@@ -369,12 +369,14 @@
                 LibUint256.min(_params.redeemRequest.amount, withdrawalEventEndPosition - _params.redeemRequest.height);
             // we can now compute the equivalent eth amount based on the withdrawal event details
             vars.ethAmount =
-                (vars.matchingAmount * _params.withdrawalEvent.withdrawnEth) / _params.withdrawalEvent.amount;
+                mulDivDown(vars.matchingAmount, _params.withdrawalEvent.withdrawnEth, _params.withdrawalEvent.amount);
+                // (vars.matchingAmount * _params.withdrawalEvent.withdrawnEth) / _params.withdrawalEvent.amount; // Munged by Certora
 
             // as each request has a maximum withdrawable amount, we verify that the eth amount is not exceeding this amount, pro rata
             // the amount that is matched
             uint256 maxRedeemableEthAmount =
-                (vars.matchingAmount * _params.redeemRequest.maxRedeemableEth) / _params.redeemRequest.amount;
+                mulDivDown(vars.matchingAmount, _params.redeemRequest.maxRedeemableEth, _params.redeemRequest.amount);
+                // (vars.matchingAmount * _params.redeemRequest.maxRedeemableEth) / _params.redeemRequest.amount; // Munged by Certora
 
             if (maxRedeemableEthAmount < vars.ethAmount) {
                 vars.exceedingEthAmount = vars.ethAmount - maxRedeemableEthAmount;
@@ -527,5 +529,9 @@
     function _setRedeemDemand(uint256 _newValue) internal {
         emit SetRedeemDemand(RedeemDemand.get(), _newValue);
         RedeemDemand.set(_newValue);
+    }
+
+    function mulDivDown(uint256 a, uint256 b, uint256 c) internal pure returns (uint256 res) {
+            res = a * b / c;
     }
 }
diff -ruN src/River.1.sol contracts/src/River.1.sol
--- src/River.1.sol	2024-01-16 15:03:11
+++ contracts/src/River.1.sol	2024-01-16 15:19:47
@@ -28,6 +28,11 @@
 import "./state/river/MetadataURI.sol";
 import "./state/river/LastConsensusLayerReport.sol";
 
+// munged by certora
+// interface ICVL {
+//     function increment_onDepositCounter() external view returns(bool);
+// }
+
 /// @title River (v1)
 /// @author Kiln
 /// @notice This contract merges all the manager contracts and implements all the virtual methods stitching all components together
@@ -298,10 +303,13 @@
         }
     }
 
+    function _onDepositCalledMunged(address _depositor, address _recipient, uint256 _amount) internal {} // munged by certora, this can be fixed once finished with CERT-4706
     /// @notice Overridden handler called whenever a user deposits ETH to the system. Mints the adequate amount of shares.
     /// @param _depositor User address that made the deposit
     /// @param _amount Amount of ETH deposited
     function _onDeposit(address _depositor, address _recipient, uint256 _amount) internal override {
+        // ICVL(address(0xdeadc0de)).increment_onDepositCounter();
+        _onDepositCalledMunged(_depositor, _recipient, _amount); // munged by Certora
         uint256 mintedShares = SharesManagerV1._mintShares(_depositor, _amount);
         IAllowlistV1 allowlist = IAllowlistV1(AllowlistAddress.get());
         if (_depositor == _recipient) {
@@ -360,9 +368,11 @@
         return collectedCoverageFunds;
     }
 
+    function _onEarningsCalledMunged(uint256 _profits) internal {} // munged by Certora, this can be fixed once finished with CERT-4706
     /// @notice Overridden handler called whenever the balance of ETH handled by the system increases. Computes the fees paid to the collector
     /// @param _amount Additional ETH received
     function _onEarnings(uint256 _amount) internal override {
+        _onEarningsCalledMunged(_amount); // munged by Certora
         uint256 oldTotalSupply = _totalSupply();
         if (oldTotalSupply == 0) {
             revert ZeroMintedShares();
diff -ruN src/components/SharesManager.1.sol contracts/src/components/SharesManager.1.sol
--- src/components/SharesManager.1.sol	2023-12-11 15:38:07
+++ contracts/src/components/SharesManager.1.sol	2024-01-16 15:06:39
@@ -192,6 +192,11 @@
         return true;
     }
 
+    function mulDivDown(uint256 a, uint256 b, uint256 c) internal pure returns (uint256 res)
+    {
+        res = a * b / c;
+    }
+
     /// @notice Internal utility to retrieve the underlying asset balance for the given shares
     /// @param _shares Amount of shares to convert
     /// @return The balance from the given shares
@@ -202,7 +207,8 @@
             return 0;
         }
 
-        return ((_shares * _assetBalance())) / _totalSharesValue;
+        // return ((_shares * _assetBalance())) / _totalSharesValue;
+        return mulDivDown(_shares , _assetBalance(), _totalSharesValue); // Munged by Certora
     }
 
     /// @notice Internal utility to retrieve the shares count for a given underlying asset amount
@@ -215,7 +221,8 @@
             return 0;
         }
 
-        return (_balance * _totalSharesValue) / _assetBalance();
+        // return (_balance * _totalSharesValue) / _assetBalance();
+        return mulDivDown(_balance, _totalSharesValue, _assetBalance()); // Munged by Certora
     }
 
     /// @notice Internal utility to mint shares for the specified user
@@ -230,7 +237,8 @@
             sharesToMint = _underlyingAssetValue;
             _mintRawShares(_owner, _underlyingAssetValue);
         } else {
-            sharesToMint = (_underlyingAssetValue * _totalSupply()) / oldTotalAssetBalance;
+            // sharesToMint = (_underlyingAssetValue * _totalSupply()) / oldTotalAssetBalance;
+            sharesToMint = mulDivDown(_underlyingAssetValue, _totalSupply(), oldTotalAssetBalance); // Munged by Certora
             _mintRawShares(_owner, sharesToMint);
         }
     }
